<!DOCTYPE html>
<html>
<head>
  <title>Minesweeper</title>
  <meta charset="utf-8" />
  <link href="mine.css" media="screen" rel="stylesheet" type="text/css" />
  <link href="win98.css" media="screen" rel="stylesheet" type="text/css" />
  <link href="mine-win98.css" media="screen" rel="stylesheet" type="text/css" />
  <style>
    /* 가로 스크롤 허용 */
    html, body { overflow-x: auto; }

    .windows { position: relative; overflow: visible; width: max-content; min-width: 100%; }
    .mine-window { position: relative; display: inline-block; }

    /* 이중 카운터용 컨테이너(아이콘+세그먼트 두 줄) */
    .mine-counters-dual { display: inline-flex; flex-direction: column; gap: 2px; }
    .counter-row { display: flex; align-items: center; gap: 6px; }

    /* 깃발 아이콘 (mine.png는 160x256 스케일 기준) */
    .counter-icon {
      width: 14px; height: 14px;
      background-image: url(mine.png);
      background-size: 160px 256px;
      image-rendering: pixelated;
      flex: 0 0 14px;
    }
    /* (검은지뢰깃발) 원본(288,288~320,320) → 절반 좌표(-144px,-144px) */
    .icon-flag-black { background-position: -145px -145px; }
    /* (하얀지뢰깃발) 원본(0,288~32,320) → 절반 좌표(0,-144px) */
    .icon-flag-white { background-position: -1px -145px; }
    .notice {
    margin: 10px 0 14px;
    padding: 10px 12px;
    border: 1px solid #b5b5b5;
    background: #fcfcfc;
    font-size: 13px;
    line-height: 1.55;
  }
  .notice h3 {
    margin: 0 0 6px;
    font-size: 14px;
  }
  .notice ul { margin: 6px 0 0 18px; padding: 0; }
  .notice li { margin: 2px 0; }
  .notice .warn {
    display: inline-block;
    padding: 0 6px;
    border-radius: 3px;
    background: #fff3cd;
    border: 1px solid #ffe69c;
  }

  /* --- Console 미러 패널 --- */
  .console-panel {
    margin: 10px 0 18px;
    border: 1px solid #b5b5b5;
    background: #ffffff;
  }
  .console-panel .console-head {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 6px 8px;
    background: #f2f2f2;
    border-bottom: 1px solid #d0d0d0;
    font-size: 13px;
  }
  .console-panel .console-head .title { font-weight: 600; margin-right: auto; }
  .console-panel .console-head button,
  .console-panel .console-head label {
    font-size: 12px;
  }
  .console-panel .console-body {
    max-height: 220px;
    overflow: auto;
    background: #ffffff;
    font: 12px/1.5 monospace;
    padding: 8px;
    white-space: pre-wrap;
  }
  .console-line { padding: 1px 0; }
  .console-time { color: #888; }
  .console-lvl-log   { color: #222; }
  .console-lvl-info  { color: #146c94; }
  .console-lvl-warn  { color: #a46c00; }
  .console-lvl-error { color: #b00020; }

  </style>
</head>

<body>
  <div id="hscroll-guard" style="height:1px;width:0;overflow:hidden;"></div>

  <script>
    function updateHScrollGuard() {
      const win = document.querySelector('.mine-window');
      const guard = document.getElementById('hscroll-guard');
      if (win && guard) guard.style.width = (win.offsetWidth + 32) + 'px';
    }
    window.addEventListener('resize', updateHScrollGuard);

    /* ===== 공통 유틸: 숫자/클램프/상한 계산 ===== */
    function toInt(v, d=0){ v=parseInt(v); return isNaN(v)?d:v; }
    function clamp(v, lo, hi){ return Math.min(hi, Math.max(lo, v)); }

    // capBlackTotal = (cells-1)*maxBlackPerCell
    // capWhiteTotal = capBlackTotal - blackTotal(최종값), 음수면 0
function calcCaps(cols, rows, maxBlackPerCell, blackTotalNow, maxWhitePerCell = 0) {
  // 1) 전체 칸수 및 검은지뢰 총 수용량
  const C = Math.max(3, cols | 0);
  const R = Math.max(1, rows | 0);
  const cells = C * R;

  const capBlackPerCell = Math.max(1, maxBlackPerCell | 0);
  const capBlackTotal   = Math.max(0, (cells - 1) * capBlackPerCell);

  // 2) 검은지뢰가 최소로 점유해야 하는 칸 수
  const blackUsed = Math.min(Math.max(0, blackTotalNow | 0), capBlackTotal);
  const minBlackCells = Math.ceil(blackUsed / capBlackPerCell);

  // 3) 흰지뢰를 넣을 수 있는 칸 수
  const whitePlaceableCells = Math.max(0, (cells - 1) - minBlackCells);

  // 4) 칸당 흰지뢰 수용량을 곱해 최대 흰지뢰 총량
  const capWhitePerCell = Math.max(0, maxWhitePerCell | 0);
  const capWhiteTotal   = whitePlaceableCells * capWhitePerCell;

  return { capBlackTotal, capWhiteTotal };
}

    // 폼 입력에 실시간 적용: 상호 의존 상한 보정
     function applyFormCaps(){
    const cols = toInt(x.value, 3);
    const rows = toInt(y.value, 1);

    // 1) 칸당 최대 검은지뢰수 (1~6)
    let maxBlackPerCell = clamp(toInt(m.value, 1), 1, 6);
    m.value = maxBlackPerCell;

    // 2) 칸당 최대 흰지뢰수 (0~6)  ← id는 wm 이 맞습니다.
    let maxWhitePerCell = clamp(toInt(wm.value, 0), 0, 6);
    wm.value = maxWhitePerCell;

    // 3) 검은 총수 보정
    let k = Math.max(1, toInt(t.value, 1));
    let caps = calcCaps(cols, rows, maxBlackPerCell, k, maxWhitePerCell);
    if (k > caps.capBlackTotal) k = caps.capBlackTotal;
    t.value = k;

    // 4) 흰 총수 보정 (검은 확정치 사용)
    caps = calcCaps(cols, rows, maxBlackPerCell, k, maxWhitePerCell);
    let whiteTotal = Math.max(0, toInt(wt.value, 0));
    if (whiteTotal > caps.capWhiteTotal) whiteTotal = caps.capWhiteTotal;
    wt.value = whiteTotal;

    // 5) max 힌트 동기화
    t.max  = String(caps.capBlackTotal);
    wt.max = String(caps.capWhiteTotal);
  }

    /* ---------- 실행 함수 (흰색 지뢰 지원) ---------- */
var execute = function(i, j, k, l = 1, whiteTotal = 0, whiteMax = 0, aiLevel = null) {
  // 1) 입력 정규화
  i = Math.max(3,toInt(i, 3)); j = toInt(j, 1); k = toInt(k, 1); l = clamp(toInt(l, 1), 1, 6);
  whiteTotal = Math.max(0, toInt(whiteTotal, 0));
  whiteMax   = clamp(toInt(whiteMax, 0), 0, 6);

  // 1-1) 지능형 생성 수준 확정 (기본값 0)
  if (aiLevel === null || typeof aiLevel === "undefined") {
    aiLevel = toInt(document.getElementById('ai')?.value, 0);
  } else {
    aiLevel = toInt(aiLevel, 0);
  }

      // 2) 상한 보정(모든 경로에서 동일하게 강제)
      //    2-1) 검은지뢰 총수 k 보정
      let caps = calcCaps(i, j, l, k,whiteMax);
      if (k > caps.capBlackTotal) k = caps.capBlackTotal;

      //    2-2) 흰지뢰 총수 whiteTotal 보정 (검은 확정치 사용)
      caps = calcCaps(i, j, l, k,whiteMax);
      if (whiteTotal > caps.capWhiteTotal) whiteTotal = caps.capWhiteTotal;
  // 3) 폼 값 반영 + 폼 max 힌트 반영
  x.value  = i; y.value  = j; m.value  = l; t.value  = k;
  wm.value = whiteMax; wt.value = whiteTotal;
  const aiSel = document.getElementById('ai');
  if (aiSel) aiSel.value = String(aiLevel);

      t.max  = String(caps.capBlackTotal);
      wt.max = String(caps.capWhiteTotal);

      /* 메뉴 표시 범위 조절 */
      const toggleMenu = (sel, show) => show ? $(sel).removeAttr("style") : $(sel).css({"display":"none"});
      toggleMenu(".menu2",  i>=7);
      toggleMenu(".menu3",  i>=10);
      toggleMenu(".menu4",  i>=13);
      toggleMenu(".menu5",  i>=14);
      toggleMenu(".menu6",  i>=16);
      toggleMenu(".menu7",  i>=19);
      toggleMenu(".menu8",  i>=21);
      toggleMenu(".menu9",  i>=23);
      toggleMenu(".menu10", i>=26);
      toggleMenu(".menu11", i>=29);
      toggleMenu(".menu12", i>=32);
      toggleMenu(".menu13", i>=35);

      /* 보드 생성 (mine.js가 6인자 지원 시 그대로 전달) */

  if (aiLevel === 2) {
    // 찍기 패턴 원천 차단
    minefield.init_board(i, j, k, l, whiteTotal, whiteMax, true);
  } else {
    // 찍기 허용
    minefield.init_board(i, j, k, l, whiteTotal, whiteMax, false);
    if (aiLevel === 1) {
      // 무제한 구제
      minefield.bonus_reloc_count = 1000000;
    }
  }
      

      /* 레이아웃: 이중 카운터면 헤더 높이/창 높이를 키움 */
      const hasWhite = whiteTotal > 0;
      const head = document.querySelector('.window-content .mine-head-area');
      if (head) head.style.height = hasWhite ? '58px' : '38px';

      const extraHead = hasWhite ? 20 : 0; // 58-38
      $(".mine-window").css({ "width": 22 + i*16, "height": (107 + extraHead) + j*16 });
      $(".window-content .mine-head-area ").css({ "width": 2 + i*16 });
      $(".window-content .mine-area").css({ "width": i*16, "height": j*16 });
      $(".inner").css({ "width": i*16, "height": j*16 });
      $(".window-content .mine-head-area .mine-reset-button").css({ "left": -8 + 8*i });
      $(".windows").css({ "height": (112 + extraHead) + j*16 });

      renderCounters(hasWhite);
      update_all_mine_counters();
      updateHScrollGuard();
    };
  </script>

  <div class="windows windows-98" style="height:365px;">
    <div class="window has-menu mine-window">
      <div class="title-bar">
        <div class="title-icon"></div>
        <div class="title">Minesweeper</div>
        <div class="title-button-group">
          <div class="title-button minimize"></div>
          <div class="title-button maximize disabled"></div>
          <div class="title-button close"></div>
        </div>
      </div>

      <ul class="menu-bar">
        <li class="menu1"  onclick="execute(9, 9, 10, 1, 0, 0,2)">초급</li>
        <li class="menu2"  onclick="execute(16, 16, 40, 1, 0, 0,2)">중급</li>
        <li class="menu3"  onclick="execute(30, 16, 99, 1, 0, 0,2)">고급</li>
        <li class="menu4"  onclick="execute(30, 16, 120, 2, 0, 0,0)">초고급</li>
        <li class="menu5"  onclick="execute(30, 16, 160, 3, 0, 0,0)">😱</li>
        <li class="menu6"  onclick="execute(30, 16, 220, 4, 0, 0,0)">💀</li>
        <li class="menu7"  onclick="execute(30, 16, 420, 4, 0, 0,0)">☠️</li>
        <li class="menu8"  onclick="execute(30, 16, 530, 5, 0, 0,0)">☠️☠️</li>
        <li class="menu9"  onclick="execute(30, 16, 680, 6, 0, 0,0)">3☠️</li>
        <li class="menu10" onclick="execute(30, 16, 70, 1, 30, 1,0)">음수지뢰</li>
        <li class="menu11" onclick="execute(118, 58, 1412, 1, 0, 0,0)">대형</li>
        <li class="menu12" onclick="execute(640, 480, 63300, 1, 0, 0,0)" style="display:none">초대형</li>
        <li class="menu13" onclick="execute(1280, 720, 192000, 1, 0, 0,0)" style="display:none">특대형</li>
      </ul>

      <div class="window-content">
        <div class="mine-head-area" style="height:38px;">
          <!-- 단일 카운터(기본) : 절대배치 그대로 사용 -->
          <div id="counters-single" class="counters-single" style="">
            <div class="mine-counter" id="mine-counter-single">
              <div class="digit digit-0"></div>
              <div class="digit digit-0"></div>
              <div class="digit digit-0"></div>
            </div>
          </div>

          <!-- 이중 카운터: 컨테이너만 절대배치, 내부 카운터는 flex로 폭 자동 -->
          <div id="counters-dual" class="mine-counters-dual"
               style="display:none; position:absolute; top:4px; left:6px;">
            <div id="counter-row-black" class="counter-row" style="min-height:23px;">
              <div class="counter-icon icon-flag-black" title="검은 지뢰"></div>
              <div class="mine-counter" id="mine-counter-black"
                   style="position:static; width:auto; height:23px; display:flex;">
                <div class="digit digit-0"></div>
                <div class="digit digit-0"></div>
                <div class="digit digit-0"></div>
              </div>
            </div>
            <div id="counter-row-white" class="counter-row" style="min-height:23px;">
              <div class="counter-icon icon-flag-white" title="하얀(음수) 지뢰"></div>
              <div class="mine-counter" id="mine-counter-white"
                   style="position:static; width:auto; height:23px; display:flex;">
                <div class="digit digit-0"></div>
                <div class="digit digit-0"></div>
                <div class="digit digit-0"></div>
              </div>
            </div>
          </div>

          <div class="mine-reset-button" onclick="minefield.reset_board()">
            <div class="mine-reset-button-inner"></div>
          </div>

          <div class="mine-timer">
            <div class="digit digit-0"></div>
            <div class="digit digit-0"></div>
            <div class="digit digit-0"></div>
          </div>
        </div>

        <div id="mine-area" class="mine-area"></div>
      </div>
    </div>
  </div>

  <div id="userctrl" class="userctrl" style="margin:0">
    <form oninput="applyFormCaps()">
      주문제작:가로
      <input type="number" id="x"  min="3" max="9999" step="1" style="width:60px;" value="30">
      세로
      <input type="number" id="y"  min="1" max="9999" step="1" style="width:60px;" value="16">
      1칸당 최대 지뢰 수
      <input type="number" id="m"  min="1" max="6"    step="1" style="width:60px;" value="1">
      전체 지뢰 수
      <input type="number" id="t"  min="1" step="1"   style="width:80px;" value="99">

      <!-- ▼ 추가: 하얀 지뢰 입력(0 허용) -->
      1칸당 최대 음수지뢰 수
      <input type="number" id="wm" min="0" max="6" step="1" style="width:60px;" value="0">
      전체 음수지뢰 수
      <input type="number" id="wt" min="0" step="1" style="width:80px;" value="0">
      지능형 생성
      <select id="ai" style="width:220px;">
        <option value="0">0: 찍기 패턴 발생 허용 + 최소 구제</option>
        <option value="1">1: 찍기 패턴 발생 허용 + 무제한 구제</option>
        <option value="2">2: 찍기 패턴 발생 원천 차단 (매우 느림)</option>
      </select>
      <input type="button"
        onclick="execute(
          document.getElementById('x').value,
          document.getElementById('y').value,
          document.getElementById('t').value,
          document.getElementById('m').value,
          document.getElementById('wt').value,
          document.getElementById('wm').value,
          document.getElementById('ai').value
        )"
        value="생성">
      <input type="button" onclick="hideViaURL()" value="문구 숨기기">
    </form>
  </div>
<div id="heavy-notice" class="notice">
  <h3>안내 / 성능 주의</h3>
  <ul>
    <li>첫 클릭 직후 <span class="warn">판 생성</span>에 시간이 걸릴 수 있습니다. (지뢰 수↑, 판 크기↑일수록 증가)</li>
    <ul>
      <li>초대형과 특대형 판은 초기화에 약 5~10초가 소요됩니다</li>
    </ul>
    <li><strong>찍기 패턴 발생 허용의 구제 기능 관련</strong>
      <ul>
        <li>복수해가 존재하여 찍기 상황이 발생하였고, 사용자가 지뢰칸을 선택했더라도 사용자의 입력이 이미 공개된 정보에 모순을 만들지 않는다면 그 칸에 지뢰가 없도록 판을 수정합니다</li>
        <li>하지만 무제한 구제는 난이도를 심각하게 낮춥니다</li>
      </ul>
    </li>
    <li><strong>찍기 패턴 원천 차단</strong> 모드 성능 주의:
      <ul>
        <li>음수지뢰가 있으면 매우 느립니다. (중급 크기의 판 이상에서 비권장)</li>
        <li>1칸당 최대 지뢰 수가 3 이상이면 매우 느립니다.</li>
        <li>대형 이상의 큰 판에서는 매우 느립니다.</li>
        <li>해당 모드는 “찍기 없는 풀이 순서”를 <strong>항상 보장</strong>하며,
        개발자 도구 콘솔 또는 아래 <em>실시간 로그</em> 패널에서 확인할 수 있습니다.</li>
      </ul>
    </li>
    
  </ul>
  <div id="console-panel" class="console-panel">
  <div class="console-head">
    <span class="title">실시간 로그 (Console mirror)</span>
    <label><input type="checkbox" id="console-autoscroll" checked> 자동 스크롤</label>
    <button type="button" id="console-pause">일시정지</button>
    <button type="button" id="console-clear">비우기</button>
    <button type="button" id="console-copy">복사</button>
  </div>
  <div class="console-body" id="console-body" aria-live="polite"></div>
</div>
</div>

  <script src="vendor/jquery.min.js"></script>
  <script src="vendor/jquery-ui.min.js"></script>
  <script src="jquery.mswin.js"></script>
  <script src="jquery.mswin.listview.js"></script>
  <script src="jquery.mswin.menu.js"></script>
  <script src="mine.js"></script>

  <script>
    /* GET 파서 */
    function getQueryParams() {
      const p = new URLSearchParams(window.location.search);
      return {
        rows: p.get('rows'),
        cols: p.get('cols'),
        minespercell: p.get('minespercell'),
        mines: p.get('mines'),
        whiteminespercell: p.get('whiteminespercell'),
        whitemines: p.get('whitemines'),
        logic: p.get('logic'),
        hide: p.get('hide'),
      };
    }
    function hasCoreParams(q) {
      return q.rows !== null && q.cols !== null && q.minespercell !== null && q.mines !== null;
    }
    function getQueryDefault0(v){ const n = parseInt(v); return isNaN(n)?0:n; }

    /* 하단 입력 숨기기 */
    function hideUserInputs() {
      const u = document.getElementById('userctrl');
      if (u) u.style.display = 'none';
      const n = document.getElementById('heavy-notice');
      if (n) n.style.display = 'none';
    }

    /* GET 리다이렉트(보내기 전에 상한 보정) */
    function hideViaURL() {
      let cols = clamp(toInt(x.value,3), 3, 999999);
      let rows = clamp(toInt(y.value,1), 1, 999999);
      let mpc  = clamp(toInt(m.value,1), 1, 6);
      let mines= Math.max(1, toInt(t.value,1));
      let wmpc = clamp(toInt(wm.value,0), 0, 6);
      let wmines = Math.max(0, toInt(wt.value,0));

      // 보정 1: 검은 총수
      let caps = calcCaps(cols, rows, mpc, mines,wmpc);
      if (mines > caps.capBlackTotal) mines = caps.capBlackTotal;

      // 보정 2: 흰 총수(검은 확정치 반영)
      caps = calcCaps(cols, rows, mpc, mines,wmpc);
      if (wmines > caps.capWhiteTotal) wmines = caps.capWhiteTotal;

      // 폼에도 반영(시각적 피드백)
      x.value=cols; y.value=rows; m.value=mpc; t.value=mines;
      wm.value=wmpc; wt.value=wmines;
      t.max  = String(caps.capBlackTotal);
      wt.max = String(caps.capWhiteTotal);

      const u = new URL(window.location.href);
      u.searchParams.set('cols', cols);
      u.searchParams.set('rows', rows);
      u.searchParams.set('minespercell', mpc);
      u.searchParams.set('mines', mines);
      u.searchParams.set('whiteminespercell', wmpc);
      u.searchParams.set('whitemines', wmines);
      // 지능형 생성 수준 포함(기본 0)
      let logic = toInt(document.getElementById('ai')?.value, 0);
      u.searchParams.set('logic', logic);
      // 숨김 플래그 & 캐시 방지용 타임스탬프
      u.searchParams.set('hide', '1');
      u.searchParams.set('ts', String(Date.now()));

      // 뒤로가기 히스토리를 남기지 않고, 강제 새로고침 효과
      window.location.replace(u.pathname + '?' + u.searchParams.toString());
    }

    /* 유틸: digit DOM 수 맞추기 */
    function ensure_digits(counter, count) {
      const cur = counter.children().length;
      if (cur < count) {
        for (let i = 0; i < count - cur; i++) counter.append('<div class="digit digit-0"></div>');
      } else if (cur > count) {
        for (let i = 0; i < cur - count; i++) $(counter.children()[0]).remove();
      }
    }
    /* 타이머(3자리 고정) */
    function update_counter_timer(val, counter) {
      if (val > 999) val = 999; if (val < 0) val = 0;
      ensure_digits(counter, 3);
      const digits = [ Math.floor(val/100), Math.floor(val/10)%10, val%10 ];
      for (let i=0;i<3;i++){
        const d = digits[i];
        const child = $(counter.children()[i]);
        child.removeClass(); child.addClass("digit digit-" + d);
      }
    }
    /* 숫자 카운터(자릿수 고정 지원) */
    function update_counter_generic(val, counter, totalForWidth, fixedDigits) {
      let N = fixedDigits || Math.max(3, String(Math.abs(totalForWidth || val || 0)).length);
      ensure_digits(counter, N);
      const isNeg = val < 0;
      if (isNeg) {
        const slots = N - 1;
        const maxAbs = Math.pow(10, slots) - 1;
        let absVal = Math.abs(val);
        if (absVal > maxAbs) absVal = maxAbs;
        let child = $(counter.children()[0]);
        child.removeClass().addClass("digit digit-10");
        const padded = String(absVal).padStart(slots, "0");
        for (let i = 0; i < slots; i++) {
          const d = padded.charCodeAt(i) - 48;
          child = $(counter.children()[i + 1]);
          child.removeClass().addClass("digit digit-" + d);
        }
      } else {
        const padded = String(val).padStart(N, "0");
        for (let i = 0; i < N; i++) {
          const d = padded.charCodeAt(i) - 48;
          const child = $(counter.children()[i]);
          child.removeClass().addClass("digit digit-" + d);
        }
      }
      counter.css({ width: (N * 13) + "px", display: "flex", whiteSpace: "nowrap", height: "23px" });
    }

    /* 모듈 전환 */
    function renderCounters(hasWhite) {
      const single = document.getElementById('counters-single');
      const dual   = document.getElementById('counters-dual');
      if (!single || !dual) return;
      if (hasWhite) { single.style.display = 'none'; dual.style.display = ''; }
      else          { single.style.display = '';    dual.style.display   = 'none'; }
    }

    /* 모든 카운터 갱신 */
    function update_all_mine_counters() {
      const hasWhite = (minefield.white_total || minefield.num_mines_white || 0) > 0;
      if (hasWhite) {
        const bTotal = (minefield.num_mines || 0);
        const wTotal = (minefield.white_total || minefield.num_mines_white || 0);
        const maxTotalAbs = Math.max(Math.abs(bTotal), Math.abs(wTotal));
        const N = Math.max(3, String(maxTotalAbs).length);
        const blackRemain = bTotal - (minefield.num_flags || 0);
        const whiteRemain = wTotal - (minefield.num_flags_white || 0);
        update_counter_generic(blackRemain, $("#mine-counter-black"), bTotal, N);
        update_counter_generic(whiteRemain, $("#mine-counter-white"), wTotal, N);
      } else {
        const remain = (minefield.num_mines || 0) - (minefield.num_flags || 0);
        update_counter_generic(remain, $("#mine-counter-single"), minefield.num_mines || 0);
      }
    }

    /* 윈도우/메뉴 초기화 — 요소가 있을 때만 안전하게 실행 */
    if ($('.window').length) $('.window').window();
    if ($('.listview').length) $('.listview').listview();
    if ($('.desktop-listview').length) $('.desktop-listview').listview();
    if ($('.menu-bar').length) $('.menu-bar').menubar();
    if ($('.taskbar ul.start').length) {
      $('.taskbar ul.start').menubar({ position_toplevel: { my: "left bottom", at: "left top" } });
    }

    /* 타이머 */
    var timer_val = 0, timer_id = null;
    var update_timer = function(){ timer_val += 1; update_counter_timer(timer_val, $(".mine-timer")); };

    /* Minefield 인스턴스 */
    var mine_area = document.getElementById("mine-area");
    var minefield = new window.Minefield(
      mine_area,
      function(status) {
        var smile = $(".mine-reset-button .mine-reset-button-inner");
        var bg = "0 0"; if (status === -1) bg = "-17px 0"; if (status === -2) bg = "-51px 0"; if (status === 2) bg = "-34px 0";
        smile.css({"background-position": bg});

        if (status === 0) timer_id = window.setInterval(update_timer, 1000);
        if (status < 0 || status === 1) {
          window.clearInterval(timer_id);
          if (status === 1) {
            const hasWhite = (minefield.white_total || minefield.num_mines_white || 0) > 0;
            renderCounters(hasWhite);
            const head = document.querySelector('.window-content .mine-head-area');
            if (head) head.style.height = hasWhite ? '58px' : '38px';
            update_all_mine_counters();
            timer_val = 0; timer_id = null; update_counter_timer(0, $(".mine-timer"));
          }
          if (status === -2) update_all_mine_counters();
        }
      },
      function(status) {
  // ★ 게임이 끝난 상태(-1: 패배, -2: 클리어)에서는 덮어쓰지 않음
  if (minefield.game_status < 0) return;

  var smile = $(".mine-reset-button .mine-reset-button-inner");

        smile.css({"background-position": (status === 1) ? "-34px 0" : "0 0"});
      }
    );

    /* 깃발 우클릭 시 카운터 갱신 */
    minefield.on_rclick_func = function(){ update_all_mine_counters(); };

    /* 초기 시작: 기본(흰 지뢰 없음) + 폼 상한 초기화 */
    minefield.init_board(30, 16, 99, 1,0,0,true);
    renderCounters(false);
    applyFormCaps();
    updateHScrollGuard();
    update_all_mine_counters();

    /* GET 인자 자동 적용 (로드 시에도 상한 보정 강제) */
    document.addEventListener('DOMContentLoaded', function() {
      const q = getQueryParams();
      if (hasCoreParams(q)) {
        let cols = Math.max(3, toInt(q.cols, 30));
        let rows = toInt(q.rows, 16);
        let mpc  = clamp(toInt(q.minespercell, 1), 1, 6);
        let mines= Math.max(1, toInt(q.mines, 99));
        let wmpc = clamp(getQueryDefault0(q.whiteminespercell), 0, 6);
        let wmines = Math.max(0, getQueryDefault0(q.whitemines));
        let logic = (q.logic !== null) ? clamp(toInt(q.logic, 0), 0, 2) : 0;
        // 보정 1: 검은 총수
        let caps = calcCaps(cols, rows, mpc, mines,wmpc);
        if (mines > caps.capBlackTotal) mines = caps.capBlackTotal;

        // 보정 2: 흰 총수
        caps = calcCaps(cols, rows, mpc, mines,wmpc);
        if (wmines > caps.capWhiteTotal) wmines = caps.capWhiteTotal;

        execute(cols, rows, mines, mpc, wmines, wmpc, logic);

        // 폼과 max 힌트도 동기화
        x.value=cols; y.value=rows; m.value=mpc; t.value=mines;
        wm.value=wmpc; wt.value=wmines;
        t.max  = String(caps.capBlackTotal);
        wt.max = String(caps.capWhiteTotal);
        const aiSel = document.getElementById('ai');
        if (aiSel) aiSel.value = String(logic);
        hideUserInputs();
      }
      else if (q.hide === '1') {
        // 핵심 파라미터가 없더라도, hide=1이면 설명/폼을 무조건 숨김
        hideUserInputs();
      }

    });
/* ===== Console Mirror ===== */
(function setupConsoleMirror(){
  const bodyEl   = document.getElementById('console-body');
  const btnPause = document.getElementById('console-pause');
  const btnClear = document.getElementById('console-clear');
  const btnCopy  = document.getElementById('console-copy');
  const cbAuto   = document.getElementById('console-autoscroll');

  if (!bodyEl) return; // 안전가드

  let paused = false;
  function ts() {
    const d = new Date();
    const pad = (n)=> String(n).padStart(2,'0');
    return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}.${String(d.getMilliseconds()).padStart(3,'0')}`;
  }
  function print(level, args) {
    if (paused) return;
    const line = document.createElement('div');
    line.className = `console-line console-lvl-${level}`;
    const t = document.createElement('span');
    t.className = 'console-time';
    t.textContent = `[${ts()}] `;
    line.appendChild(t);

    const content = Array.from(args).map(v => {
      try {
        if (typeof v === 'string') return v;
        return JSON.stringify(v);
      } catch(_) {
        return String(v);
      }
    }).join(' ');
    line.appendChild(document.createTextNode(content));
    bodyEl.appendChild(line);

    if (cbAuto && cbAuto.checked) {
      bodyEl.scrollTop = bodyEl.scrollHeight;
    }
  }

  // 원본 보존
  const orig = {
    log:   console.log.bind(console),
    info:  console.info?.bind(console)  || function(){},
    warn:  console.warn?.bind(console)  || function(){},
    error: console.error?.bind(console) || function(){},
  };

  // 후킹
  console.log  = function(){ print('log', arguments);  orig.log.apply(console, arguments); };
  console.info = function(){ print('info', arguments); orig.info.apply(console, arguments); };
  console.warn = function(){ print('warn', arguments); orig.warn.apply(console, arguments); };
  console.error= function(){ print('error', arguments);orig.error.apply(console, arguments); };

  // 컨트롤
  if (btnPause) {
    btnPause.addEventListener('click', function(){
      paused = !paused;
      btnPause.textContent = paused ? '재개' : '일시정지';
    });
  }
  if (btnClear) {
    btnClear.addEventListener('click', function(){
      bodyEl.textContent = '';
    });
  }
  if (btnCopy) {
    btnCopy.addEventListener('click', async function(){
      const text = Array.from(bodyEl.querySelectorAll('.console-line'))
        .map(el => el.textContent).join('\n');
      try { await navigator.clipboard.writeText(text); } catch(_) {}
    });
  }

  // 시작 메시지
  console.info('[Console mirror started]');
})();

/* ===== Runtime i18n: if not Korean, switch UI texts to English ===== */
(function () {
  function isKorean() {
    var lang = (navigator.language || navigator.userLanguage || "").toLowerCase();
    return lang.startsWith("ko");
  }

  function localizeToEnglish() {
    // Document language
    document.documentElement.setAttribute("lang", "en");

    // 1) Menu labels
    var menuText = {
      ".menu1":  "Beginner",
      ".menu2":  "Intermediate",
      ".menu3":  "Expert",
      ".menu4":  "Ultra",
      ".menu5":  "😱",
      ".menu6":  "💀",
      ".menu7":  "☠️",
      ".menu8":  "☠️☠️",
      ".menu9":  "3☠️",
      ".menu10": "AntiMine",
      ".menu11": "Large",
      ".menu12": "XLarge",
      ".menu13": "XXLarge"
    };
    Object.keys(menuText).forEach(function (sel) {
      var el = document.querySelector(sel);
      if (el) el.textContent = menuText[sel];
    });

    // 2) Counter icon tooltips
    var blackIcon = document.querySelector(".icon-flag-black");
    if (blackIcon) blackIcon.setAttribute("title", "Black mine");
    var whiteIcon = document.querySelector(".icon-flag-white");
    if (whiteIcon) whiteIcon.setAttribute("title", "Anti-mine");

    // 3) Form labels / buttons (safe innerHTML replacements on static markup)
    var form = document.querySelector("#userctrl form");
    if (form) {
      var html = form.innerHTML;
      html = html.replace("주문제작:가로", "Custom: cols")
                 .replace("세로", "rows")
                 .replace("1칸당 최대 지뢰 수", "Max mines / cell")
                 .replace("전체 지뢰 수", "Total mines")
                 .replace("1칸당 최대 음수지뢰 수", "Max anti-mines / cell")
                 .replace("전체 음수지뢰 수", "Total anti-mines")
                 .replace("생성", "Create")
                 .replace("문구 숨기기", "Hide controls");
      form.innerHTML = html;
    }

    // 4) Heavy notice (+ console panel labels)
var notice = document.getElementById("heavy-notice");
if (notice) {
  notice.innerHTML =
    '<h3>Notice / Performance Tips</h3>' +
    '<ul>' +
      '<li>Right after the first click, <span class="warn">board generation</span> may take a while. (More mines & larger boards take longer.)</li>' +
      '<ul>' +
        '<li>XLarge and XXLarge boards take about 5~10 seconds to initialize.</li>' +
      '</ul>' +
      '<li><strong>About the mine relocation feature that rescues from guess situations</strong>:' +
        '<ul>' +
          '<li>If multiple solutions exist and a guess situation occurs, and the user clicks the mine cell but does not contradict already revealed information, the board will be modified so that there is no mine in that cell.</li>' +
          '<li>However, unlimited rescues significantly reduce the difficulty.</li>' +
        '</ul>' +
      '</li>' +
      '<li><strong>Strict no-guess</strong> mode performance caveats:' +
        '<ul>' +
          '<li>Very slow when anti-mines are used (not recommended for ≥ Intermediate).</li>' +
          '<li>Very slow if max mines per cell ≥ 3.</li>' +
          '<li>Very slow on large boards (≥ Large).</li>' +
          '<li>This mode <strong>guarantees a guess-free solution order</strong>.' +
          ' You can inspect it in the developer console or in the <em>Live Log</em> panel below.</li>' +
        '</ul>' +
      '</li>' +
      
    '</ul>';
}
var cp = document.getElementById("console-panel");
if (cp) {
  // 헤더의 버튼/라벨 텍스트 교체
  var titleEl = cp.querySelector('.console-head .title');
  var pauseEl = document.getElementById('console-pause');
  var clearEl = document.getElementById('console-clear');
  var copyEl  = document.getElementById('console-copy');
  var autoLbl = cp.querySelector('label[for="console-autoscroll"]') || cp.querySelector('.console-head label');

  if (titleEl) titleEl.textContent = 'Live Log (Console mirror)';
  if (autoLbl)  autoLbl.innerHTML  = '<input type="checkbox" id="console-autoscroll" checked> Auto scroll';
  if (pauseEl)  pauseEl.textContent= 'Pause';
  if (clearEl)  clearEl.textContent= 'Clear';
  if (copyEl)   copyEl.textContent = 'Copy';
}
  }

  // Run after DOM is ready
  if (!isKorean()) {
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", localizeToEnglish);
    } else {
      localizeToEnglish();
    }
  }
})();

</script>

</body>
</html>
