// Generated by CoffeeScript 1.6.2
(function() {
  var Minefield;

  Minefield = (function() {
    function Minefield(window, game_status_changed_func,game_status_changed_func2) {
      this.window = window;
      this.game_status_changed_func = game_status_changed_func != null ? game_status_changed_func : null;
      this.game_status_changed_func2 = game_status_changed_func2 != null ? game_status_changed_func2 : null;
      this.game_status = -1;this.game_status2 = 0;
      this.table = null;
      this.on_click_func = null;
      this.on_rclick_func = null;
    }
	Minefield.prototype.theoretical_max_zero_cells = function() {
		var C = this.columns, R = this.rows;
		var total = C * R;
		if (this.num_mines <= 0) return total;
		
		var M = Math.max(1, this.max_mines || 1);
		var needed = Math.ceil(this.num_mines / M);
		
		// 영향권 면적 계산 (모서리 기준, 보드 경계로 캡)
		function influenceArea(w, h) {
			var areaW = Math.min(C, w + 1);
			var areaH = Math.min(R, h + 1);
			return areaW * areaH;
		}
	
		// --- 전략 A: 정방형에 가까운 직사각형(엄밀 탐색) ---
		var bestA = Infinity;
		var hMax = Math.min(R, needed);
		for (var h = 1; h <= hMax; h++) {
			var w = Math.ceil(needed / h);
			if (w > C) continue;
			var area = influenceArea(w, h);
			if (area < bestA) bestA = area;
		}
		
		// --- 전략 B: 짧은 변을 꽉 채우며 모서리에 쌓기 ---
		var bestB = Infinity;
		if (C <= R) {
			// 가로가 짧음: 가로를 먼저 꽉 채우고 세로로 늘림
			var wB = Math.min(C, needed);
			var hB = Math.ceil(needed / wB);
			if (hB <= R) bestB = influenceArea(wB, hB);
		} else {
		// 세로가 짧음: 세로를 먼저 꽉 채우고 가로로 늘림
			var hB2 = Math.min(R, needed);
			var wB2 = Math.ceil(needed / hB2);
			if (wB2 <= C) bestB = influenceArea(wB2, hB2);
		}
		
		var best = Math.min(bestA, bestB);
		if (!isFinite(best)) {
			// (드물지만) 제약으로 어떤 조합도 못 찾은 경우: 보드 꽉 채운 근사
			best = influenceArea(Math.min(C, needed), Math.ceil(needed / Math.min(C, needed)));
		}
		
		var zeroMax = total - best;
		return zeroMax < 0 ? 0 : zeroMax;
	};
	
	// 현재 판에서 "주변 지뢰 0칸" 개수(자기 칸에 지뢰 없어야 함)
	Minefield.prototype.count_zero_no_neighbor = function() {
		var cnt = 0;
		for (var x = 0; x < this.columns; x++) {
			for (var y = 0; y < this.rows; y++) {
				if (this.mines[x][y] === 0 && this.near_mines[x][y] === 0) cnt++;
			}
		}
		return cnt;
		};
	Minefield.prototype.has_neighbor_mine = function(x, y) {
		var adj = this.near_positions(x, y);
		for (var i = 0; i < adj.length; i++) {
			var nx = adj[i][0], ny = adj[i][1];
			if (this.mines[nx][ny] > 0) return true;
		}
		return false;
	};

    Minefield.prototype.new_table = function() {
      var x, y, _i, _ref, _results;

      _results = [];
      for (x = _i = 1, _ref = this.columns; 1 <= _ref ? _i <= _ref : _i >= _ref; x = 1 <= _ref ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref1, _results1;

          _results1 = [];
          for (y = _j = 1, _ref1 = this.rows; 1 <= _ref1 ? _j <= _ref1 : _j >= _ref1; y = 1 <= _ref1 ? ++_j : --_j) {
            _results1.push(0);
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Minefield.prototype.init_board = function(columns, rows, num_mines, max_mines) {
	
      this.columns = columns;
      this.rows = rows;
      this.num_mines = num_mines;
      this.max_mines = max_mines != null ? max_mines : 1;
      return this.reset_board();
    };

    Minefield.prototype.reset_board = function() {
		var on_click_to, on_rclick_to, mousedown,mouseup,td, tr, x, y, _i, _j, _ref, _ref1;
		this.opened_cells = 0;     // 지금까지 실제로 연 칸 수 (안전칸 오픈할 때 증가)
		this.reloc_used   = 0;     // 구제(지뢰 옮기기) 사용 횟수
		this.opened_safe  = 0;     // 연 칸 중 지뢰 없는 칸 수
		this.total_safe   = 0;     // 지뢰 없는 전체 칸 수 (init_mines 후 계산)
		this.bonus_reloc_count = 0;    // 보너스 누적 개수
		this.bonus_thresholds  = this.compute_bonus_thresholds(); // 임계치 목록
		if (this.table) {
			this.window.removeChild(this.table);
			this.game_status = -1;
			this.table = null;
		}
		
		this.table = document.createElement('table');
		this.table.setAttribute("class", "minetable");
		this.num_flags = 0;
		this.flags = this.new_table();
		this.near_flags = this.new_table();
		this.tds = this.new_table();
		for (y = _i = 0, _ref = this.rows - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; y = 0 <= _ref ? ++_i : --_i) {
		tr = document.createElement('tr');
		for (x = _j = 0, _ref1 = this.columns - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
		  td = document.createElement('td');
		  td.setAttribute("id", "x" + x + "y" + y);
		  on_click_to = function(x_, y_, self) {
			return function() {
			  self.on_click(x_, y_);
			  return false;
			};
		  };
		  td.onclick = on_click_to(x, y, this);
		  on_rclick_to = function(x_, y_, self) {
			return function() {
			  self.on_rclick(x_, y_);
			  return false;
			};
		  };
		  td.oncontextmenu = on_rclick_to(x, y, this);
		  mousedown= function(x_, y_, self) {
			return function() {
			  self.on_down(x_, y_);
			  return false;
			};
		  };
		  td.onmousedown= mousedown(x,y,this);
		  mouseup= function(x_, y_, self) {
			return function() {
			  self.on_up(x_, y_);
			  return false;
			};
		  };
		  td.onmouseup= mouseup(x,y,this);
		  this.tds[x][y] = td;
		  tr.appendChild(td);
		}
		this.table.appendChild(tr);
		}
		this.window.appendChild(this.table);
		// 후보 5판 생성 후, 주변 지뢰 0칸 최대인 판을 채택
		var bestZero = -1;
		var bestMines = null;
		var bestNear = null;
		var bestRemaining = 0;
		var retryMap = {1:1, 2:2, 3:4, 4:8, 5:12};
		var retries = retryMap[this.max_mines] || 1;
		for (var attempt = 0; attempt < retries; attempt++) {
		  this.init_mines(); // mines/near_mines/remaining/game_status 갱신
		  var curZero = this.count_zero_no_neighbor();
		
		  if (curZero > bestZero) {
		    bestZero = curZero;
		    // 깊은 복사
		    bestMines = JSON.parse(JSON.stringify(this.mines));
		    bestNear = JSON.parse(JSON.stringify(this.near_mines));
		    bestRemaining = this.remaining;
		  }
		}
		
		// 베스트 스냅샷을 복원
		if (bestMines) {
		  this.mines = bestMines;
		  this.near_mines = bestNear;
		  this.remaining = bestRemaining;
		  this.game_status = 1; // 준비 상태 유지
		}
		
		return this.on_game_status_changed();

	};
	// 지금 칸이 "열린" 상태인지 확인 (empty 또는 near-*)
	Minefield.prototype.is_opened = function(x, y) {
	  var c = this.get_class(x, y);
	  if (c === null) return false;
	  if (/^flag/.test(c)) return false;         // flag-*, flag-0 는 '안 연' 상태로 취급
	  if (c === "empty") return true;
	  if (/^near-/.test(c)) return true;
	  return false;
	};
	
	// 이웃 중 하나라도 '열린' 칸이 있으면 true
	Minefield.prototype.has_opened_neighbor = function(x, y) {
	  var adj = this.near_positions(x, y);
	  for (var i = 0; i < adj.length; i++) {
	    var nx = adj[i][0], ny = adj[i][1];
	    if (this.is_opened(nx, ny)) return true;
	  }
	  return false;
	};
	// candidates 배열에서 m개 뽑는 조합들을 순차 생성(최대 C(10,m))
Minefield.prototype._combinations_pick = function(candidates, m) {
  var res = [];
  function dfs(start, path) {
    if (path.length === m) { res.push(path.slice()); return; }
    for (var i = start; i <= candidates.length - (m - path.length); i++) {
      path.push(candidates[i]);
      dfs(i + 1, path);
      path.pop();
    }
  }
  if (m <= candidates.length && m > 0) dfs(0, []);
  return res;
};
// 규칙에 맞게 최대 10칸 후보 선정
Minefield.prototype._pick_reloc_candidates = function(excludeX, excludeY) {
  var pref = [], rest = [];
  for (var cx = 0; cx < this.columns; cx++) {
    for (var cy = 0; cy < this.rows; cy++) {
      if (cx === excludeX && cy === excludeY) continue;

      // 이미 최대 지뢰인 칸 제외
      if (this.mines[cx][cy] >= this.max_mines) continue;

      // 안 열린 칸만
      var cls = this.get_class(cx, cy);
      var unopened = (cls === null) || /^flag/.test(cls) || (cls === "flag-0");
      if (!unopened) continue;

      // 열린 칸 인접 여부
      var nearOpened = this.has_opened_neighbor(cx, cy);

      if (!nearOpened) pref.push([cx, cy]);
      else rest.push([cx, cy]);
    }
  }

  // 무작위 섞기
  function shuffle(a){
    for (var i=a.length-1;i>0;i--){var j=Math.floor(Math.random()*(i+1));var t=a[i];a[i]=a[j];a[j]=t;}
  }
  shuffle(pref); shuffle(rest);

  var out = [];
  for (var i=0; i<pref.length && out.length<10; i++) out.push(pref[i]);
  for (var j=0; j<rest.length && out.length<10; j++) out.push(rest[j]);
  return out; // 길이 <=10
};

	// 구제(지뢰 옮기기) 가능 횟수(허용량) 계산
	Minefield.prototype.get_reloc_allowed = function() {
		var mm = Math.max(1, this.max_mines || 1);
		if(mm==1) mm=10000;
		else if(mm==2) mm=2000;
		else if(mm==3) mm=400;
		else if(mm==4) mm=300;
		else mm=225;
		var base = Math.floor( this.opened_cells / mm);   // 기본 규칙
		var bonus = this.bonus_reloc_count || 0;                      // 보너스 누적
		return base + bonus;
	};
	Minefield.prototype.compute_bonus_thresholds = function() {
		var mm = Math.max(1, this.max_mines || 1);
		if (mm <= 2) return [0.997];            // 99.7%
		if (mm <= 4) return [0.99, 0.997];      // 99%, 99.7%
		if (mm >= 5) return [0.95, 0.99, 0.999];// 95%, 99%, 99.9%
		return [];
	};
// (x,y) 칸의 지뢰를 다른 '안 열린' 칸들로 옮겨서
// 이미 '열린' 칸들의 숫자를 바꾸지 않고 전부 재배치할 수 있으면 true(성공)
	// (x,y) 지뢰칸의 m개 지뢰를 후보 10칸에 1개씩 분배해,
// '열린 칸' 숫자 불변 조건을 만족하는 조합을 찾으면 적용
Minefield.prototype.try_relocate_from = function(x, y) {
  var m = this.mines[x][y];
  if (m <= 0) return false;

  // 후보 10칸 선정 (규칙 적용)
  var cand = this._pick_reloc_candidates(x, y);
  if (cand.length < m) return false; // 담을 자리가 모자람

  // 영향을 받는 '열린 칸'만 검사: (x,y)의 8이웃 + 각 후보의 8이웃
  // set으로 수집
  var affected = {};
  var self = this;

  function addNeighbors(px, py) {
    var adj = self.near_positions(px, py);
    for (var i=0;i<adj.length;i++){
      var nx=adj[i][0], ny=adj[i][1];
      if (self.is_opened(nx, ny)) affected[nx + "," + ny] = [nx, ny];
    }
  }
  addNeighbors(x, y);
  for (var c=0;c<cand.length;c++) addNeighbors(cand[c][0], cand[c][1]);

  // 조합을 생성: cand 중 m칸 선택
  var combos = this._combinations_pick(cand, m);

  // 유효 조합 찾기
  for (var ci=0; ci<combos.length; ci++) {
    var picks = combos[ci]; // [[cx,cy], ...] 길이 m

    // (1) 각 pick 칸이 max_mines-1 이하인지 확인 (1개 추가 가능해야 함)
    var okSlots = true;
    for (var p=0; p<picks.length; p++) {
      var px = picks[p][0], py = picks[p][1];
      if (this.mines[px][py] + 1 > this.max_mines) { okSlots = false; break; }
    }
    if (!okSlots) continue;

    // (2) 숫자 변화 로컬 검증: affected 열린 칸만 확인
    // 각 열린 칸에 대해 delta = (+1 * #picks that are neighbor) + (-m if neighbor of (x,y))
    var allSame = true;
    // 미리 (x,y)와의 이웃성 캐시
    var decNeighbors = {};
    var adjXY = this.near_positions(x, y);
    for (var i2=0;i2<adjXY.length;i2++){
      decNeighbors[adjXY[i2][0] + "," + adjXY[i2][1]] = true;
    }

    // 각 pick의 이웃 집합(증가 대상)을 미리 카운트
    var incCount = {}; // key -> times
    for (var q=0; q<picks.length; q++) {
      var ax = picks[q][0], ay = picks[q][1];
      var adjA = this.near_positions(ax, ay);
      for (var r=0; r<adjA.length; r++) {
        var key = adjA[r][0] + "," + adjA[r][1];
        incCount[key] = (incCount[key] || 0) + 1; // 한 pick당 +1
      }
    }

    // 열린 칸만 확인
    for (var key in affected) {
      var pos = affected[key];
      var ox = pos[0], oy = pos[1];
      var orig = this.near_mines[ox][oy];

      var delta = 0;
      if (decNeighbors[key]) delta -= m;
      if (incCount[key])     delta += incCount[key];

      if (orig + delta !== orig) { allSame = false; break; }
    }
    if (!allSame) continue;

    // 통과: 커밋
    var temp = JSON.parse(JSON.stringify(this.mines));
    // 원래 칸 비우기
    temp[x][y] = 0;

    // unique: 0 -> 1로 바뀌는 칸 개수 세기
    var newly = {};
    for (var s=0; s<picks.length; s++) {
      var tx = picks[s][0], ty = picks[s][1];
      if (temp[tx][ty] === 0) newly[tx + "," + ty] = true;
      temp[tx][ty] += 1; // 한 칸당 1개씩
    }

    // 적용
    this.mines = temp;
    this.near_mines = this.generate_near_mines(this.mines);

    // remaining 보정:
    // (x,y) : >0 → 0 이므로 +1
    // newly 된 칸 수 만큼 -1
    var deltaRemaining = 1 - Object.keys(newly).length;
    this.remaining += deltaRemaining;

    return true; // 성공
  }

  // 어떤 조합도 통과 못함
  return false;
};


	Minefield.prototype.init_mines = function() {
		var n, n_max, num_mine_created, x, y,n2;
		
		this.mines = this.new_table();
		this.remaining = this.rows * this.columns;
		num_mine_created = 0;
		n2=this.columns*this.rows*220/480;
		while (num_mine_created < this.num_mines) {
		x = Math.floor(Math.random() * this.columns);
		y = Math.floor(Math.random() * this.rows);
		if (this.mines[x][y] < this.max_mines) {
			n_max = this.max_mines - this.mines[x][y];
			n_max = Math.min(n_max, this.num_mines - num_mine_created);
			if(this.num_mines - num_mine_created>n2) {
				n = n_max; n2-=0.5;
			}
			else n = Math.floor(Math.random() * n_max) + 1;
			// n은 이번에 이 칸(x,y)에 넣을 지뢰 '칸수'(1~max_mines)
			if (n >= 2) {
			// 두칸~다섯칸짜리 확률표
				var p = (n === 2 ? 0.2 :
				n === 3 ? 0.5 :
				n === 4 ? 0.5 :
				n === 5 ? 0.5 : 0);
				
				if (Math.random() < p) {
				// 이웃에 지뢰가 없으면 이 배치는 취소하고 다시 뿌리러 감(continue)
					if (!this.has_neighbor_mine(x, y)) {
						continue; // while 루프 처음으로 돌아가서 다른 위치/수량 시도
					}
				}
			}
		
			if (this.mines[x][y] === 0) {
				this.remaining -= 1;
			}
			this.mines[x][y] += n;
			num_mine_created += n;
			}
		}
		this.near_mines = this.generate_near_mines(this.mines);
		this.total_safe = 0;
		for (var x = 0; x < this.columns; x++) {
			for (var y = 0; y < this.rows; y++) {
				if (this.mines[x][y] === 0) this.total_safe++;
			}
		}
		return this.game_status = 1;
	};

    Minefield.prototype.generate_near_mines = function(mines) {
      var near_mines, nx, ny, x, y, _i, _j, _k, _len, _ref, _ref1, _ref2, _ref3;

      near_mines = this.new_table();
      for (x = _i = 0, _ref = this.columns - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; x = 0 <= _ref ? ++_i : --_i) {
        for (y = _j = 0, _ref1 = this.rows - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
          _ref2 = this.near_positions(x, y);
          for (_k = 0, _len = _ref2.length; _k < _len; _k++) {
            _ref3 = _ref2[_k], nx = _ref3[0], ny = _ref3[1];
            near_mines[nx][ny] += mines[x][y];
          }
        }
      }
      return near_mines;
    };

    Minefield.prototype.shift_table = function(table, dx, dy) {
      var new_table, new_x, new_y, nx, ny, _i, _j, _ref, _ref1;

      new_table = this.new_table();
      for (ny = _i = 0, _ref = this.rows - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; ny = 0 <= _ref ? ++_i : --_i) {
        for (nx = _j = 0, _ref1 = this.columns - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; nx = 0 <= _ref1 ? ++_j : --_j) {
          new_x = (nx + dx + 2 * this.columns) % this.columns;
          new_y = (ny + dy + 2 * this.rows) % this.rows;
          new_table[new_x][new_y] = table[nx][ny];
        }
      }
      return new_table;
    };

    Minefield.prototype.get_class = function(x, y) {
      var td_class;

      td_class = this.tds[x][y].getAttribute("class");
      if (td_class === null || td_class === "") {
        null;
      }
      return td_class;
    };

    Minefield.prototype.set_class = function(x, y, val) {
      if (val === null) {
        return this.tds[x][y].removeAttribute("class");
      } else {
        return this.tds[x][y].setAttribute("class", val);
      }
    };

    Minefield.prototype.near_positions = function(x, y) {
      var nx, ny, ret, _i, _j, _ref, _ref1, _ref2, _ref3;

      ret = [];
      for (nx = _i = _ref = x - 1, _ref1 = x + 1; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; nx = _ref <= _ref1 ? ++_i : --_i) {
        for (ny = _j = _ref2 = y - 1, _ref3 = y + 1; _ref2 <= _ref3 ? _j <= _ref3 : _j >= _ref3; ny = _ref2 <= _ref3 ? ++_j : --_j) {
          if (nx === x && ny === y) {
            continue;
          }
          if (nx >= this.columns || nx < 0 || ny >= this.rows || ny < 0) {
            continue;
          }
          ret.push([nx, ny]);
        }
      }
      return ret;
    };

    Minefield.prototype.on_click = function(x, y) {
      var old_game_status;
 
      old_game_status = this.game_status;
      if (this.game_status < 0) {
        return;
      }
			 // ★ 추가: 현재 칸이 '깃발 n개'(flag-1..flag-max)이면
		//        열지 않고 좌클릭 순환만 수행
		var td_class = this.get_class(x, y);
		if (td_class !== null && td_class !== "flag-0" && /^flag-/.test(td_class)) {
		this.cycle_flag_leftclick(x, y);
		// 외부 카운터 갱신 콜백을 재사용(우클릭과 동일한 효과)
		if (this.on_rclick_func) {
		  this.on_rclick_func(x, y);
		}
		// 게임 상태 변화 없음
		return;
		}
      if (this.game_status === 1) {
        this.start(x, y);
      }
      if (this.expand(x, y) < 0) {
        this.gameover(x, y);
      }
      if (this.remaining === 0) {
        this.gameclear();
      }
      if (this.on_click_func) {
        this.on_click_func(x, y);
      }
      if (old_game_status !== this.game_status) {
        return this.on_game_status_changed();
      }
    };

    Minefield.prototype.on_rclick = function(x, y) {
      var old_game_status;

      old_game_status = this.game_status;
      if (this.game_status < 0) {
        return;
      }
      if (this.game_status === 1) {
        this.game_status = 0;
      }
      this.flag(x, y);
      if (this.on_rclick_func) {
        this.on_rclick_func(x, y);
      }
      if (old_game_status !== this.game_status) {
        return this.on_game_status_changed();
      }
    };
// 좌클릭일 때: 깃발 상태 유지하며 개수만 순환 (1..max → 1)
Minefield.prototype.cycle_flag_leftclick = function(x, y) {
  var cur = this.flags[x][y] || 0;        // 현재 깃발 수
  if (cur <= 0) return;                   // 깃발 아님(없음/ ? )이면 무시

  var next = cur + 1;
  var delta;
  if (next > this.max_mines) {
    next = 1;                             // max → 1 로 래핑
    delta = 1 - cur;                      // num_flags 보정 (예: max=5이면 -4)
  } else {
    delta = 1;                            // 한 개 증가
  }

  // 카운터/인접 플래그 합 반영
  this.flags[x][y] = next;
  this.num_flags += delta;

  var adj = this.near_positions(x, y);
  for (var i = 0; i < adj.length; i++) {
    var nx = adj[i][0], ny = adj[i][1];
    this.near_flags[nx][ny] += delta;
  }

  // UI 반영: 깃발 상태 유지
  this.set_class(x, y, "flag-" + next);
};

    Minefield.prototype.on_game_status_changed = function() {
      if (this.game_status_changed_func) {
        return this.game_status_changed_func(this.game_status);
      }
    };
Minefield.prototype.on_game_status_changed2 = function() {
      if (this.game_status_changed_func2) {
        return this.game_status_changed_func2(this.game_status2);
      }
    };
    Minefield.prototype.start = function(x, y) {
      var nx, ny, _i, _ref, _results;

      this.game_status = 0;
      if (this.mines[x][y] === 0) {
        return;
      }
      _results = [];
      for (nx = _i = 0, _ref = this.columns - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; nx = 0 <= _ref ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref1, _results1;

          _results1 = [];
          for (ny = _j = 0, _ref1 = this.rows - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; ny = 0 <= _ref1 ? ++_j : --_j) {
            if (this.mines[nx][ny] === 0) {
              this.mines = this.shift_table(this.mines, x - nx, y - ny);
              _results1.push(this.near_mines = this.generate_near_mines(this.mines));
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Minefield.prototype.flag = function(x, y) {
      var n, nx, ny, td_class, _i, _len, _ref, _ref1;
      td_class = this.get_class(x, y);
      if (td_class !== null && !/^flag/.exec(td_class)) {
        return;
      }
      if(td_class==="flag-0"){
       return this.set_class(x, y, null);
      }
      n = 1;
      if (this.flags[x][y] === this.max_mines) {
        n = -this.flags[x][y];
      }
	
      this.num_flags += n;
      this.flags[x][y] += n;
      _ref = this.near_positions(x, y);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], nx = _ref1[0], ny = _ref1[1];
        this.near_flags[nx][ny] += n;
      }
      if (n > 0) {
        return this.set_class(x, y, "flag-" + this.flags[x][y]);
      } else{
        return this.set_class(x, y, "flag-0");
      }
    };
	Minefield.prototype.press = function(x, y) {
		if (this.mines[x][y] > 0) {
			return -1;
		} else if (this.get_class(x, y) !== null && this.get_class(x, y) !== "flag-0") {
			return 1;
		}
		this.remaining -= 1;
		// 열림 카운트
		this.opened_cells = (this.opened_cells || 0) + 1;
		
		// 이 함수는 지뢰가 있는 칸이면 이미 위에서 return -1 했으므로,
		// 여기 도달한 경우는 "지뢰 없는 칸"을 연 것 = opened_safe 증가
		this.opened_safe = (this.opened_safe || 0) + 1;
		  // ★ 보너스 지급: 누적 오픈 비율이 임계치들을 통과할 때마다 +1
		  var ratio = this.opened_safe / this.total_safe;
  if (!this.bonus_thresholds) this.bonus_thresholds = this.compute_bonus_thresholds();
  while ((this.bonus_reloc_count || 0) < this.bonus_thresholds.length &&
         ratio >= this.bonus_thresholds[this.bonus_reloc_count]) {
    this.bonus_reloc_count += 1;  // 보너스 1회 추가
  }
		
		if (this.near_mines[x][y] === 0) {
			this.set_class(x, y, "empty");
		} else {
			this.set_class(x, y, "near-" + this.near_mines[x][y]);
		}
		return 0;
	};

    

    Minefield.prototype.expand = function(start_x, start_y) {
      var list, nx, ny, start_flags, start_mines, td_class, x, y, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3, _ref4;

      td_class = this.get_class(start_x, start_y);
      if (td_class !== null && (td_class!=="flag-0" && /^flag/.exec(td_class))) {
        return 1;
      }
		if (this.press(start_x, start_y) < 0){
		var pr = this.press(start_x, start_y);
if (pr < 0) {
  // 구제 기회 확인
  var allowed = this.get_reloc_allowed();
  if ((this.reloc_used || 0) < allowed) {
    // 옮기기 시도
    if (this.try_relocate_from(start_x, start_y)) {
      // 기회 1회 소모
      this.reloc_used = (this.reloc_used || 0) + 1;

      // 이제 이 칸은 지뢰가 아니므로 다시 열기 시도
      pr = this.press(start_x, start_y);
      if (pr < 0) {
        // 논리상 여기 오면 안 되지만 안전망으로 사망 처리
        return -1;
      }
    } else {
      // 옮기기 실패 → 사망
      return -1;
    }
  } else {
    // 기회 없음 → 사망
    return -1;
  }
}
		}
      list = [[start_x, start_y]];
      start_mines = this.near_mines[start_x][start_y];
      start_flags = this.near_flags[start_x][start_y];
      if (start_mines === start_flags) {
        _ref = this.near_positions(start_x, start_y);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          _ref1 = _ref[_i], nx = _ref1[0], ny = _ref1[1];
          td_class = this.get_class(nx, ny);
          if (td_class === null|| td_class==="flag-0") {
            list.push([nx, ny]);
            if (this.press(nx, ny) < 0) {
              return -1;
            }
          }
        }
      }
      while (list.length > 0) {
        _ref2 = list.pop(), x = _ref2[0], y = _ref2[1];
        if (this.near_mines[x][y] === 0) {
          _ref3 = this.near_positions(x, y);
          for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
            _ref4 = _ref3[_j], nx = _ref4[0], ny = _ref4[1];
            td_class = this.get_class(nx, ny);
            if (td_class === null || td_class==="flag-0") {
              list.push([nx, ny]);
              if (this.press(nx, ny) < 0) {
                return -1;
              }
            }
          }
        }
      }
      return 0;
    };

    Minefield.prototype.gameover = function(fail_x, fail_y) {
      var mine, x, y, _i, _ref, _results;
      var tmp,td;
      tmp = (document.getElementsByClassName("minetable")[0]).getElementsByTagName("td");;
      
      for(y=0;y<tmp.length;y++){
	td=tmp[y];
      td.onclick=null;
      td.onmouseup=null;
      td.onmousedown=null;
      td.oncontextmenu=null;
      }
      
      this.game_status = -1;
      _results = [];
      for (y = _i = 0, _ref = this.rows - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; y = 0 <= _ref ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref1, _results1;

          _results1 = [];
          for (x = _j = 0, _ref1 = this.columns - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
            mine = this.mines[x][y];
            flag=this.flags[x][y];
            if (mine > 0) {
              if (this.get_class(x, y)!=="flag-0"&&/^flag/.exec(this.get_class(x, y))) {
                continue;
              }
              this.set_class(x, y, "mine-" + mine);
              if (fail_x === x && fail_y === y) {
                _results1.push(this.set_class(x, y, "mine-exploded"+mine));
              } else {
                _results1.push(void 0);
              }
            } else {
              if (this.flags[x][y] > 0) {
                _results1.push(this.set_class(x, y, "mine-wrong"+flag));
              } else if (this.near_mines[x][y] === 0) {
                _results1.push(this.set_class(x, y, "empty"));
              } else {
                _results1.push(this.set_class(x, y, "near-" + this.near_mines[x][y]));
              }
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Minefield.prototype.gameclear = function() {
	var tmp,td;
      tmp = (document.getElementsByClassName("minetable")[0]).getElementsByTagName("td");;
      
      for(y=0;y<tmp.length;y++){
	td=tmp[y];
      td.onclick=null;
      td.onmouseup=null;
      td.onmousedown=null;
      td.oncontextmenu=null;
      }
      var mine, x, y, _i, _ref, _results;
      _results = [];
      for (y = _i = 0, _ref = this.rows - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; y = 0 <= _ref ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref1, _results1;

          _results1 = [];
          for (x = _j = 0, _ref1 = this.columns - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
            mine = this.mines[x][y];
            if (mine > 0) {
              this.set_class(x, y, "flag-" + mine);
              
               _results1.push(void 0);
              
            }
          }
          return _results1;
        }).call(this));
      }
      this.num_flags=this.num_mines;
      return this.game_status = -2;
    };
    Minefield.prototype.on_down = function() {
	this.game_status2 = 1;
	this.on_game_status_changed2();
      return 1;
      
    };
    Minefield.prototype.on_up = function() {
	this.game_status2 = 0;
	this.on_game_status_changed2();
      return 0;
    };

    Minefield.prototype.stringify = function() {
      return JSON.stringify(this.mines);
    };

    return Minefield;

  })();

  window.Minefield = Minefield;

}).call(this);
