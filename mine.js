// Generated by CoffeeScript 1.6.2 (rewritten + optimized)
// Drop-in replacement for mine.js

(function () {
  var Minefield;

  Minefield = (function () {
    function Minefield(window, game_status_changed_func, game_status_changed_func2) {
      this.window = window;
      this.game_status_changed_func = game_status_changed_func != null ? game_status_changed_func : null;
      this.game_status_changed_func2 = game_status_changed_func2 != null ? game_status_changed_func2 : null;
      this.game_status = -1;
      this.game_status2 = 0;
      this.table = null;
      this.on_click_func = null;
      this.on_rclick_func = null;
    }

    /* ---------- 분석/이론값 ---------- */
    Minefield.prototype.theoretical_max_zero_cells = function () {
      var C = this.columns, R = this.rows;
      var total = C * R;
      if (this.num_mines <= 0) return total;

      var M = Math.max(1, this.max_mines || 1);
      var needed = Math.ceil(this.num_mines / M);

      function influenceArea(w, h) {
        var areaW = Math.min(C, w + 1);
        var areaH = Math.min(R, h + 1);
        return areaW * areaH;
      }

      var bestA = Infinity;
      var hMax = Math.min(R, needed);
      for (var h = 1; h <= hMax; h++) {
        var w = Math.ceil(needed / h);
        if (w > C) continue;
        var area = influenceArea(w, h);
        if (area < bestA) bestA = area;
      }

      var bestB = Infinity;
      if (C <= R) {
        var wB = Math.min(C, needed);
        var hB = Math.ceil(needed / wB);
        if (hB <= R) bestB = influenceArea(wB, hB);
      } else {
        var hB2 = Math.min(R, needed);
        var wB2 = Math.ceil(needed / hB2);
        if (wB2 <= C) bestB = influenceArea(wB2, hB2);
      }

      var best = Math.min(bestA, bestB);
      if (!isFinite(best)) {
        best = influenceArea(Math.min(C, needed), Math.ceil(needed / Math.min(C, needed)));
      }

      var zeroMax = total - best;
      return zeroMax < 0 ? 0 : zeroMax;
    };
// 1) 행 우선순위 구성: centerY 주변 ±windowRows → 나머지
Minefield.prototype._buildRowOrder = function(centerY, windowRows) {
  const H = this.rows;
  const inRange = [];
  const rest = [];
  const top = Math.max(0, centerY - windowRows);
  const bottom = Math.min(H - 1, centerY + windowRows);
  for (let y = 0; y < H; y++) {
    if (y >= top && y <= bottom) inRange.push(y);
    else rest.push(y);
  }
  return inRange.concat(rest);
};

// 2) 한 행의 모든 셀 클래스를 계산해 한 번에 적용
Minefield.prototype._applyRow = function(y, cellClassAtXY) {
  for (let x = 0; x < this.columns; x++) {
    const cls = cellClassAtXY(x, y);
    if (cls === null) {
      this.tds[x][y].removeAttribute("class");
    } else {
      // 같은 값이면 touch 안 함(불필요한 레이아웃/페인트 방지)
      if (this.tds[x][y].getAttribute("class") !== cls) {
        this.tds[x][y].setAttribute("class", cls);
      }
    }
  }
};

// 3) 대량 업데이트를 1행씩 rAF로 분절 처리 (프리징 방지)
Minefield.prototype._renderRowsIncrementally = function(rowOrder, cellClassAtXY, done) {
  let idx = 0;
  const step = () => {
    const start = idx;
    // 한 프레임에 1~2행 정도가 무난. 필요하면 튜닝 가능.
    const budget = Math.min(rowOrder.length - idx, 2);
    for (let k = 0; k < budget; k++) {
      const y = rowOrder[idx++];
      this._applyRow(y, cellClassAtXY);
    }
    if (idx < rowOrder.length) {
      requestAnimationFrame(step);
    } else if (done) {
      done();
    }
  };
  requestAnimationFrame(step);
};

    // 현재 판에서 "주변 지뢰 0칸" 개수(자기 칸에 지뢰 없어야 함)
    Minefield.prototype.count_zero_no_neighbor = function () {
      var cnt = 0;
      for (var x = 0; x < this.columns; x++) {
        for (var y = 0; y < this.rows; y++) {
          if (this.mines[x][y] === 0 && this.near_mines[x][y] === 0) cnt++;
        }
      }
      return cnt;
    };

    Minefield.prototype.has_neighbor_mine = function (x, y) {
      var adj = this.near_positions(x, y);
      for (var i = 0; i < adj.length; i++) {
        var nx = adj[i][0], ny = adj[i][1];
        if (this.mines[nx][ny] > 0) return true;
      }
      return false;
    };

    /* ---------- 기본 테이블 유틸 ---------- */
    Minefield.prototype.new_table = function () {
      var x, y, _i, _ref, _results;
      _results = [];
      for (x = _i = 1, _ref = this.columns; 1 <= _ref ? _i <= _ref : _i >= _ref; x = 1 <= _ref ? ++_i : --_i) {
        _results.push((function () {
          var _j, _ref1, _results1;
          _results1 = [];
          for (y = _j = 1, _ref1 = this.rows; 1 <= _ref1 ? _j <= _ref1 : _j >= _ref1; y = 1 <= _ref1 ? ++_j : --_j) {
            _results1.push(0);
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    /* ---------- 초기화 ---------- */
    Minefield.prototype.init_board = function (columns, rows, num_mines, max_mines) {
      this.columns = columns;
      this.rows = rows;
      this.num_mines = num_mines;
      this.max_mines = max_mines != null ? max_mines : 1;
      return this.reset_board();
    };

    Minefield.prototype._ensureWorkBuffers = function () {
      // 확장/BFS용 워크버퍼(대형 보드에서도 빠르게 동작)
      const size = this.columns * this.rows;
      if (!this._visit || this._visit.length !== size) {
        // 세대 카운터 방식
        this._visit = new Uint32Array(size);
        this._visitGen = 1;
        // 고정 길이 큐
        this._queueX = new Int32Array(size);
        this._queueY = new Int32Array(size);
      }
    };

    Minefield.prototype.reset_board = function () {
      var on_click_to, on_rclick_to, mousedown, mouseup, td, tr, x, y, _i, _j, _ref, _ref1;

      this.opened_cells = 0;          // 실제로 연 칸 수(지뢰 없는 칸만)
      this.reloc_used = 0;            // 구제(지뢰 옮기기) 사용 횟수
      this.opened_safe = 0;           // 연 칸 중 지뢰 없는 칸 수
      this.total_safe = 0;            // 지뢰 없는 전체 칸 수(init_mines 후 계산)
      this.bonus_reloc_count = 0;     // 보너스 누적 개수
      this.bonus_thresholds = this.compute_bonus_thresholds();

      if (this.table) {
        this.window.removeChild(this.table);
        this.game_status = -1;
        this.table = null;
      }

      this.table = document.createElement('table');
      this.table.setAttribute("class", "minetable");
      this.num_flags = 0;
      this.flags = this.new_table();
      this.near_flags = this.new_table();
      this.tds = this.new_table();

      for (y = _i = 0, _ref = this.rows - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; y = 0 <= _ref ? ++_i : --_i) {
        tr = document.createElement('tr');
        for (x = _j = 0, _ref1 = this.columns - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
          td = document.createElement('td');
          td.setAttribute("id", "x" + x + "y" + y);

          on_click_to = function (x_, y_, self) {
            return function (e) {
              // 가운데(휠) 클릭 방해 금지: 사용자가 설정한 상위 핸들로 넘김
              if (e && e.button === 1) return true;
              self.on_click(x_, y_);
              return false;
            };
          };
          td.onclick = on_click_to(x, y, this);

          on_rclick_to = function (x_, y_, self) {
            return function (e) {
              if (e && e.button === 1) return true;
              self.on_rclick(x_, y_);
              return false;
            };
          };
          td.oncontextmenu = on_rclick_to(x, y, this);

          mousedown = function (x_, y_, self) {
            return function (e) {
              if (e && e.button === 1) return true;
              self.on_down(x_, y_);
              return false;
            };
          };
          td.onmousedown = mousedown(x, y, this);

          mouseup = function (x_, y_, self) {
            return function (e) {
              if (e && e.button === 1) return true;
              self.on_up(x_, y_);
              return false;
            };
          };
          td.onmouseup = mouseup(x, y, this);

          this.tds[x][y] = td;
          tr.appendChild(td);
        }
        this.table.appendChild(tr);
      }
      this.window.appendChild(this.table);

      // 워크 버퍼 준비
      this._ensureWorkBuffers();

      // 주변 지뢰 0칸 최대인 보드를 선택(재시도 매핑)
      var bestZero = -1;
      var bestMines = null;
      var bestNear = null;
      var bestRemaining = 0;

      // 사용자가 6을 입력할 수도 있으니 확장(없으면 무시)
      var retryMap = { 1: 1, 2: 2, 3: 4, 4: 8, 5: 12, 6: 18 };
      var retries = retryMap[this.max_mines] || 1;

      for (var attempt = 0; attempt < retries; attempt++) {
        this.init_mines(); // mines/near_mines/remaining/game_status 갱신
        var curZero = this.count_zero_no_neighbor();

        if (curZero > bestZero) {
          bestZero = curZero;
          bestMines = JSON.parse(JSON.stringify(this.mines));
          bestNear = JSON.parse(JSON.stringify(this.near_mines));
          bestRemaining = this.remaining;
        }
      }

      if (bestMines) {
        this.mines = bestMines;
        this.near_mines = bestNear;
        this.remaining = bestRemaining;
        this.game_status = 1; // 준비 상태
      }

      return this.on_game_status_changed();
    };

    /* ---------- 상태 체크 ---------- */
    Minefield.prototype.is_opened = function (x, y) {
      var c = this.get_class(x, y);
      if (c === null) return false;
      if (/^flag/.test(c)) return false;
      if (c === "empty") return true;
      if (/^near-/.test(c)) return true;
      return false;
    };

    Minefield.prototype.has_opened_neighbor = function (x, y) {
      var adj = this.near_positions(x, y);
      for (var i = 0; i < adj.length; i++) {
        var nx = adj[i][0], ny = adj[i][1];
        if (this.is_opened(nx, ny)) return true;
      }
      return false;
    };

    /* ---------- 조합/후보 선택(지뢰 재배치) ---------- */
    Minefield.prototype._combinations_pick = function (candidates, m) {
      var res = [];
      function dfs(start, path) {
        if (path.length === m) { res.push(path.slice()); return; }
        for (var i = start; i <= candidates.length - (m - path.length); i++) {
          path.push(candidates[i]);
          dfs(i + 1, path);
          path.pop();
        }
      }
      if (m <= candidates.length && m > 0) dfs(0, []);
      return res;
    };

    Minefield.prototype._pick_reloc_candidates = function (excludeX, excludeY) {
      var pref = [], rest = [];
      for (var cx = 0; cx < this.columns; cx++) {
        for (var cy = 0; cy < this.rows; cy++) {
          if (cx === excludeX && cy === excludeY) continue;
          if (this.mines[cx][cy] >= this.max_mines) continue;

          var cls = this.get_class(cx, cy);
          var unopened = (cls === null) || /^flag/.test(cls) || (cls === "flag-0");
          if (!unopened) continue;

          var nearOpened = this.has_opened_neighbor(cx, cy);
          if (!nearOpened) pref.push([cx, cy]); else rest.push([cx, cy]);
        }
      }
      function shuffle(a) {
        for (var i = a.length - 1; i > 0; i--) {
          var j = Math.floor(Math.random() * (i + 1));
          var t = a[i]; a[i] = a[j]; a[j] = t;
        }
      }
      shuffle(pref); shuffle(rest);

      var out = [];
      for (var i = 0; i < pref.length && out.length < 10; i++) out.push(pref[i]);
      for (var j = 0; j < rest.length && out.length < 10; j++) out.push(rest[j]);
      return out; // 길이 <= 10
    };

    /* ---------- 구제 규칙 ---------- */
    Minefield.prototype.get_reloc_allowed = function () {
      var mm = Math.max(1, this.max_mines || 1);
      // 난이도별 완화(사용자 요청 사양)
      if (mm == 1) mm = 10000;
      else if (mm == 2) mm = 2000;
      else if (mm == 3) mm = 400;
      else if (mm == 4) mm = 300;
      else if (mm == 5) mm = 225;
      else mm = 168;

      var base = Math.floor(this.opened_cells / mm);
      var bonus = this.bonus_reloc_count || 0;
      return base + bonus;
    };

    Minefield.prototype.compute_bonus_thresholds = function () {
      var mm = Math.max(1, this.max_mines || 1);
      if (mm <= 2) return [0.997];               // 99.7%
      if (mm <= 4) return [0.99, 0.997];         // 99%, 99.7%
      if (mm >= 5) return [0.95, 0.99, 0.999];   // 95%, 99%, 99.9%
      return [];
    };

    /* ---------- 지뢰 재배치(구제) ---------- */
    Minefield.prototype.try_relocate_from = function (x, y) {
      var m = this.mines[x][y];
      if (m <= 0) return false;

      var cand = this._pick_reloc_candidates(x, y);
      if (cand.length < m) return false;

      var affected = {};
      var self = this;

      function addNeighbors(px, py) {
        var adj = self.near_positions(px, py);
        for (var i = 0; i < adj.length; i++) {
          var nx = adj[i][0], ny = adj[i][1];
          if (self.is_opened(nx, ny)) affected[nx + "," + ny] = [nx, ny];
        }
      }
      addNeighbors(x, y);
      for (var c = 0; c < cand.length; c++) addNeighbors(cand[c][0], cand[c][1]);

      var combos = this._combinations_pick(cand, m);

      for (var ci = 0; ci < combos.length; ci++) {
        var picks = combos[ci];

        var okSlots = true;
        for (var p = 0; p < picks.length; p++) {
          var px = picks[p][0], py = picks[p][1];
          if (this.mines[px][py] + 1 > this.max_mines) { okSlots = false; break; }
        }
        if (!okSlots) continue;

        var allSame = true;

        var decNeighbors = {};
        var adjXY = this.near_positions(x, y);
        for (var i2 = 0; i2 < adjXY.length; i2++) {
          decNeighbors[adjXY[i2][0] + "," + adjXY[i2][1]] = true;
        }

        var incCount = {};
        for (var q = 0; q < picks.length; q++) {
          var ax = picks[q][0], ay = picks[q][1];
          var adjA = this.near_positions(ax, ay);
          for (var r = 0; r < adjA.length; r++) {
            var key = adjA[r][0] + "," + adjA[r][1];
            incCount[key] = (incCount[key] || 0) + 1;
          }
        }

        for (var key in affected) {
          var pos = affected[key];
          var ox = pos[0], oy = pos[1];
          var orig = this.near_mines[ox][oy];

          var delta = 0;
          if (decNeighbors[key]) delta -= m;
          if (incCount[key]) delta += incCount[key];

          if (orig + delta !== orig) { allSame = false; break; }
        }
        if (!allSame) continue;

        var temp = JSON.parse(JSON.stringify(this.mines));
        temp[x][y] = 0;

        var newly = {};
        for (var s = 0; s < picks.length; s++) {
          var tx = picks[s][0], ty = picks[s][1];
          if (temp[tx][ty] === 0) newly[tx + "," + ty] = true;
          temp[tx][ty] += 1;
        }

        this.mines = temp;
        this.near_mines = this.generate_near_mines(this.mines);

        var deltaRemaining = 1 - Object.keys(newly).length;
        this.remaining += deltaRemaining;

        return true;
      }
      return false;
    };

    /* ---------- 지뢰 뿌리기 ---------- */
    Minefield.prototype.init_mines = function () {
      var n, n_max, num_mine_created, x, y, n2;

      this.mines = this.new_table();
      this.remaining = this.rows * this.columns;
      num_mine_created = 0;
      n2 = this.columns * this.rows * 220 / 480;

      while (num_mine_created < this.num_mines) {
        x = Math.floor(Math.random() * this.columns);
        y = Math.floor(Math.random() * this.rows);
        if (this.mines[x][y] < this.max_mines) {
          n_max = this.max_mines - this.mines[x][y];
          n_max = Math.min(n_max, this.num_mines - num_mine_created);

          if (this.num_mines - num_mine_created > n2) { n = n_max; n2 -= 0.5; }
          else n = Math.floor(Math.random() * n_max) + 1;

          if (n >= 2) {
            var p = (n === 2 ? 0.2 :
              n === 3 ? 0.5 :
                n === 4 ? 0.5 :
                  n === 5 ? 0.5 :
                    n === 6 ? 0.5 : 0);

            if (Math.random() < p) {
              if (!this.has_neighbor_mine(x, y)) {
                continue;
              }
            }
          }

          if (this.mines[x][y] === 0) this.remaining -= 1;
          this.mines[x][y] += n;
          num_mine_created += n;
        }
      }

      this.near_mines = this.generate_near_mines(this.mines);
      this.total_safe = 0;
      for (var xx = 0; xx < this.columns; xx++) {
        for (var yy = 0; yy < this.rows; yy++) {
          if (this.mines[xx][yy] === 0) this.total_safe++;
        }
      }
      return this.game_status = 1;
    };

    Minefield.prototype.generate_near_mines = function (mines) {
      var near_mines, nx, ny, x, y, _i, _j, _k, _len, _ref, _ref1, _ref2, _ref3;
      near_mines = this.new_table();
      for (x = _i = 0, _ref = this.columns - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; x = 0 <= _ref ? ++_i : --_i) {
        for (y = _j = 0, _ref1 = this.rows - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
          _ref2 = this.near_positions(x, y);
          for (_k = 0, _len = _ref2.length; _k < _len; _k++) {
            _ref3 = _ref2[_k], nx = _ref3[0], ny = _ref3[1];
            near_mines[nx][ny] += mines[x][y];
          }
        }
      }
      return near_mines;
    };

    Minefield.prototype.shift_table = function (table, dx, dy) {
      var new_table, new_x, new_y, nx, ny, _i, _j, _ref, _ref1;
      new_table = this.new_table();
      for (ny = _i = 0, _ref = this.rows - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; ny = 0 <= _ref ? ++_i : --_i) {
        for (nx = _j = 0, _ref1 = this.columns - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; nx = 0 <= _ref1 ? ++_j : --_j) {
          new_x = (nx + dx + 2 * this.columns) % this.columns;
          new_y = (ny + dy + 2 * this.rows) % this.rows;
          new_table[new_x][new_y] = table[nx][ny];
        }
      }
      return new_table;
    };

    /* ---------- DOM 헬퍼 ---------- */
    Minefield.prototype.get_class = function (x, y) {
      var td_class = this.tds[x][y].getAttribute("class");
      if (td_class === null || td_class === "") { null; }
      return td_class;
    };

    Minefield.prototype.set_class = function (x, y, val) {
      if (val === null) {
        return this.tds[x][y].removeAttribute("class");
      } else {
        return this.tds[x][y].setAttribute("class", val);
      }
    };

    Minefield.prototype.near_positions = function (x, y) {
      var nx, ny, ret, _i, _j, _ref, _ref1, _ref2, _ref3;
      ret = [];
      for (nx = _i = _ref = x - 1, _ref1 = x + 1; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; nx = _ref <= _ref1 ? ++_i : --_i) {
        for (ny = _j = _ref2 = y - 1, _ref3 = y + 1; _ref2 <= _ref3 ? _j <= _ref3 : _j >= _ref3; ny = _ref2 <= _ref3 ? ++_j : --_j) {
          if (nx === x && ny === y) continue;
          if (nx >= this.columns || nx < 0 || ny >= this.rows || ny < 0) continue;
          ret.push([nx, ny]);
        }
      }
      return ret;
    };

    /* ---------- 입력 ---------- */
    Minefield.prototype.on_click = function (x, y) {
      var old_game_status = this.game_status;
      if (this.game_status < 0) return;

      // ★ 깃발 상태면 좌클릭으로 개수만 순환(보드 열지 않음)
      var td_class = this.get_class(x, y);
      if (td_class !== null && td_class !== "flag-0" && /^flag-/.test(td_class)) {
        this.cycle_flag_leftclick(x, y);
        if (this.on_rclick_func) this.on_rclick_func(x, y); // 카운터 갱신 재사용
        return;
      }

      if (this.game_status === 1) this.start(x, y);

      if (this.expand(x, y) < 0) this.gameover(x, y);

      if (this.remaining === 0) this.gameclear();

      if (this.on_click_func) this.on_click_func(x, y);
      if (old_game_status !== this.game_status) return this.on_game_status_changed();
    };

    Minefield.prototype.on_rclick = function (x, y) {
      var old_game_status = this.game_status;
      if (this.game_status < 0) return;
      if (this.game_status === 1) this.game_status = 0;
      this.flag(x, y);
      if (this.on_rclick_func) this.on_rclick_func(x, y);
      if (old_game_status !== this.game_status) return this.on_game_status_changed();
    };

    // 좌클릭일 때: 깃발 상태 유지하며 개수만 순환 (1..max → 1)
    Minefield.prototype.cycle_flag_leftclick = function (x, y) {
      var cur = this.flags[x][y] || 0;
      if (cur <= 0) return;

      var next = cur + 1;
      var delta;
      if (next > this.max_mines) {
        next = 1;
        delta = 1 - cur;  // 예: 5 → 1 이면 -4
      } else {
        delta = 1;
      }

      this.flags[x][y] = next;
      this.num_flags += delta;

      var adj = this.near_positions(x, y);
      for (var i = 0; i < adj.length; i++) {
        var nx = adj[i][0], ny = adj[i][1];
        this.near_flags[nx][ny] += delta;
      }

      this.set_class(x, y, "flag-" + next);
    };

    Minefield.prototype.on_game_status_changed = function () {
      if (this.game_status_changed_func) return this.game_status_changed_func(this.game_status);
    };

    Minefield.prototype.on_game_status_changed2 = function () {
      if (this.game_status_changed_func2) return this.game_status_changed_func2(this.game_status2);
    };

    Minefield.prototype.start = function (x, y) {
      var nx, ny, _i, _ref, _results;
      this.game_status = 0;
      if (this.mines[x][y] === 0) return;

      _results = [];
      for (nx = _i = 0, _ref = this.columns - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; nx = 0 <= _ref ? ++_i : --_i) {
        _results.push((function () {
          var _j, _ref1, _results1;
          _results1 = [];
          for (ny = _j = 0, _ref1 = this.rows - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; ny = 0 <= _ref1 ? ++_j : --_j) {
            if (this.mines[nx][ny] === 0) {
              this.mines = this.shift_table(this.mines, x - nx, y - ny);
              _results1.push(this.near_mines = this.generate_near_mines(this.mines));
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Minefield.prototype.flag = function (x, y) {
      var n, nx, ny, td_class, _i, _len, _ref, _ref1;
      td_class = this.get_class(x, y);
      if (td_class !== null && !/^flag/.exec(td_class)) return;
      if (td_class === "flag-0") {
        return this.set_class(x, y, null);
      }
      n = 1;
      if (this.flags[x][y] === this.max_mines) {
        n = -this.flags[x][y];
      }

      this.num_flags += n;
      this.flags[x][y] += n;

      _ref = this.near_positions(x, y);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], nx = _ref1[0], ny = _ref1[1];
        this.near_flags[nx][ny] += n;
      }

      if (n > 0) {
        return this.set_class(x, y, "flag-" + this.flags[x][y]);
      } else {
        return this.set_class(x, y, "flag-0");
      }
    };

    Minefield.prototype.press = function (x, y) {
      if (this.mines[x][y] > 0) {
        return -1;
      } else if (this.get_class(x, y) !== null && this.get_class(x, y) !== "flag-0") {
        return 1;
      }

      this.remaining -= 1;

      // 열림 카운트
      this.opened_cells = (this.opened_cells || 0) + 1;
      // 지뢰 없는 칸을 연 것
      this.opened_safe = (this.opened_safe || 0) + 1;

      // 보너스 임계치 체크
      var ratio = this.opened_safe / this.total_safe;
      if (!this.bonus_thresholds) this.bonus_thresholds = this.compute_bonus_thresholds();
      while ((this.bonus_reloc_count || 0) < this.bonus_thresholds.length &&
        ratio >= this.bonus_thresholds[this.bonus_reloc_count]) {
        this.bonus_reloc_count += 1;  // 보너스 1회 추가
      }

      if (this.near_mines[x][y] === 0) {
        this.set_class(x, y, "empty");
      } else {
        this.set_class(x, y, "near-" + this.near_mines[x][y]);
      }
      return 0;
    };

    /* ---------- 고속 확장(BFS) - 원본과 같은 규칙 ---------- */
    Minefield.prototype.expand = function (start_x, start_y) {
      // 깃발이면 확장 금지(원본과 동일)
      var td_class = this.get_class(start_x, start_y);
      if (td_class !== null && (td_class !== "flag-0" && /^flag/.exec(td_class))) {
        return 1;
      }

      // 첫 클릭/확장: press() 결과 체크
      var pr = this.press(start_x, start_y);
      if (pr < 0) {
        // 지뢰 클릭 → 구제 기회 확인 후 재배치 시도
        var allowed = this.get_reloc_allowed();
        if ((this.reloc_used || 0) < allowed) {
          if (this.try_relocate_from(start_x, start_y)) {
            this.reloc_used = (this.reloc_used || 0) + 1;
            pr = this.press(start_x, start_y);
            if (pr < 0) return -1; // 안전망
          } else {
            return -1;
          }
        } else {
          return -1;
        }
      }

      // BFS 준비
      const W = this.columns, H = this.rows;
      const visit = this._visit;
      const qx = this._queueX;
      const qy = this._queueY;

      // 세대 카운터 방식으로 방문 표시 초기화
      const gen = (this._visitGen = (this._visitGen | 0) + 1) || (this._visitGen = 1);

      function idx(x, y) { return y * W + x; }
      function markVisited(x, y) { visit[idx(x, y)] = gen; }
      function isVisited(x, y) { return visit[idx(x, y)] === gen; }

      let head = 0, tail = 0;
      qx[tail] = start_x; qy[tail] = start_y; tail++;
      markVisited(start_x, start_y);

      // 시작점의 숫자
      var start_mines = this.near_mines[start_x][start_y];
      var start_flags = this.near_flags[start_x][start_y];

      // ★ 원본 규칙: 시작칸의 숫자와 인접 깃발 수가 같으면 인접칸들 자동 오픈
      if (start_mines === start_flags) {
        var neighbors = this.near_positions(start_x, start_y);
        for (var i = 0; i < neighbors.length; i++) {
          var nx = neighbors[i][0], ny = neighbors[i][1];
          var c = this.get_class(nx, ny);
          if (c === null || c === "flag-0") {
            if (this.press(nx, ny) < 0) return -1;
            if (!isVisited(nx, ny)) {
              qx[tail] = nx; qy[tail] = ny; tail++;
              markVisited(nx, ny);
            }
          }
        }
      }

      // BFS 확장: 0칸은 사방으로 퍼지며, 숫자칸은 열기만(원본과 동일)
      while (head < tail) {
        var x = qx[head], y = qy[head]; head++;

        if (this.near_mines[x][y] === 0) {
          var adj = this.near_positions(x, y);
          for (var j = 0; j < adj.length; j++) {
            var ax = adj[j][0], ay = adj[j][1];
            var cls = this.get_class(ax, ay);
            if (cls === null || cls === "flag-0") {
              if (this.press(ax, ay) < 0) return -1;

              if (!isVisited(ax, ay)) {
                qx[tail] = ax; qy[tail] = ay; tail++;
                markVisited(ax, ay);
              }
            }
          }
        }
      }
      return 0;
    };

    /* ---------- 게임 종료 ---------- */
Minefield.prototype.gameover = function(fail_x, fail_y) {
  // 이벤트 전부 끄기(기존 로직 유지)
  var tmp = (document.getElementsByClassName("minetable")[0]).getElementsByTagName("td");
  for (var i = 0; i < tmp.length; i++) {
    var td = tmp[i];
    td.onclick = td.onmouseup = td.onmousedown = td.oncontextmenu = null;
  }
  this.game_status = -1;

  const self = this;

  // 각 셀의 최종 class 계산 함수 (행 단위로 호출)
  function cellClassAtXY(x, y) {
    const mine = self.mines[x][y];
    const flag = self.flags[x][y];
    const cur = self.get_class(x, y);

    if (mine > 0) {
      // 이미 정답 깃발이면 그대로 두기(원본 행동 유지)
      if (cur !== "flag-0" && /^flag/.test(cur)) return cur;
      // 지뢰 표시
      if (x === fail_x && y === fail_y) return "mine-exploded" + mine;
      return "mine-" + mine;
    } else {
      if (flag > 0) return "mine-wrong" + flag;       // 오깃발
      if (self.near_mines[x][y] === 0) return "empty";
      return "near-" + self.near_mines[x][y];
    }
  }

  // 업데이트 순서: fail_y 주변 50행 → 나머지
  const order = this._buildRowOrder(fail_y, 50);

  // 프리징 없이 단계적으로 렌더
  this._renderRowsIncrementally(order, cellClassAtXY, function() {
    // 완료 시 필요하면 후처리 가능
  });

  return true;
};

    

   Minefield.prototype.gameclear = function () {
  // 입력 종료(기존 유지)
  var tmp = (document.getElementsByClassName("minetable")[0]).getElementsByTagName("td");
  for (var i = 0; i < tmp.length; i++) {
    var td = tmp[i];
    td.onclick = td.onmouseup = td.onmousedown = td.oncontextmenu = null;
  }

  // 정답 기반으로 flags/near_flags 재계산 (기존 동작)
  this.num_flags = 0;
  this.near_flags = this.new_table();
  for (var y = 0; y < this.rows; y++) {
    for (var x = 0; x < this.columns; x++) {
      var mine = this.mines[x][y];
      if (mine > 0) {
        this.flags[x][y] = mine;
        this.num_flags += mine;
        // near_flags 합산
        var adj = this.near_positions(x, y);
        for (var i2 = 0; i2 < adj.length; i2++) {
          var nx = adj[i2][0], ny = adj[i2][1];
          this.near_flags[nx][ny] += mine;
        }
      } else {
        this.flags[x][y] = 0;
      }
    }
  }

  const self = this;
  function cellClassAtXY(x, y) {
    const mine = self.mines[x][y];
    if (mine > 0) return "flag-" + mine; // 정답 깃발
    return (self.near_mines[x][y] === 0) ? "empty" : ("near-" + self.near_mines[x][y]);
  }

  // 전체 행 1행씩(대형 보드 프리징 방지)
  const order = Array.from({ length: this.rows }, (_, y) => y);
  this._renderRowsIncrementally(order, cellClassAtXY, () => {
    self.game_status = -2;
    // 바깥 카운터(남은 지뢰 = 0) 갱신은 기존 콜백 흐름으로 처리됨
  });

  return this.game_status;
};


    /* ---------- 마우스 프레스 표시 ---------- */
    Minefield.prototype.on_down = function () {
      this.game_status2 = 1;
      this.on_game_status_changed2();
      return 1;
    };

    Minefield.prototype.on_up = function () {
      this.game_status2 = 0;
      this.on_game_status_changed2();
      return 0;
    };

    /* ---------- 디버그 ---------- */
    Minefield.prototype.stringify = function () {
      return JSON.stringify(this.mines);
    };

    return Minefield;
  })();

  window.Minefield = Minefield;
}).call(this);
