// Generated by CoffeeScript 1.6.2
(function() {
  var Minefield;

  Minefield = (function() {
    function Minefield(window, game_status_changed_func,game_status_changed_func2) {
      this.window = window;
      this.game_status_changed_func = game_status_changed_func != null ? game_status_changed_func : null;
      this.game_status_changed_func2 = game_status_changed_func2 != null ? game_status_changed_func2 : null;
      this.game_status = -1;this.game_status2 = 0;
      this.table = null;
      this.on_click_func = null;
      this.on_rclick_func = null;
    }
	  Minefield.prototype.theoretical_max_zero_cells = function() {
  var C = this.columns, R = this.rows;
  var total = C * R;
  if (this.num_mines <= 0) return total;

  var M = Math.max(1, this.max_mines || 1);
  var needed = Math.ceil(this.num_mines / M);

  // 영향권 면적 계산 (모서리 기준, 보드 경계로 캡)
  function influenceArea(w, h) {
    var areaW = Math.min(C, w + 1);
    var areaH = Math.min(R, h + 1);
    return areaW * areaH;
  }

  // --- 전략 A: 정방형에 가까운 직사각형(엄밀 탐색) ---
  var bestA = Infinity;
  var hMax = Math.min(R, needed);
  for (var h = 1; h <= hMax; h++) {
    var w = Math.ceil(needed / h);
    if (w > C) continue;
    var area = influenceArea(w, h);
    if (area < bestA) bestA = area;
  }

  // --- 전략 B: 짧은 변을 꽉 채우며 모서리에 쌓기 ---
  var bestB = Infinity;
  if (C <= R) {
    // 가로가 짧음: 가로를 먼저 꽉 채우고 세로로 늘림
    var wB = Math.min(C, needed);
    var hB = Math.ceil(needed / wB);
    if (hB <= R) bestB = influenceArea(wB, hB);
  } else {
    // 세로가 짧음: 세로를 먼저 꽉 채우고 가로로 늘림
    var hB2 = Math.min(R, needed);
    var wB2 = Math.ceil(needed / hB2);
    if (wB2 <= C) bestB = influenceArea(wB2, hB2);
  }

  var best = Math.min(bestA, bestB);
  if (!isFinite(best)) {
    // (드물지만) 제약으로 어떤 조합도 못 찾은 경우: 보드 꽉 채운 근사
    best = influenceArea(Math.min(C, needed), Math.ceil(needed / Math.min(C, needed)));
  }

  var zeroMax = total - best;
  return zeroMax < 0 ? 0 : zeroMax;
};
// 현재 판에서 "주변 지뢰 0칸" 개수(자기 칸에 지뢰 없어야 함)
Minefield.prototype.count_zero_no_neighbor = function() {
  var cnt = 0;
  for (var x = 0; x < this.columns; x++) {
    for (var y = 0; y < this.rows; y++) {
      if (this.mines[x][y] === 0 && this.near_mines[x][y] === 0) cnt++;
    }
  }
  return cnt;
};
Minefield.prototype.has_neighbor_mine = function(x, y) {
  var adj = this.near_positions(x, y);
  for (var i = 0; i < adj.length; i++) {
    var nx = adj[i][0], ny = adj[i][1];
    if (this.mines[nx][ny] > 0) return true;
  }
  return false;
};

    Minefield.prototype.new_table = function() {
      var x, y, _i, _ref, _results;

      _results = [];
      for (x = _i = 1, _ref = this.columns; 1 <= _ref ? _i <= _ref : _i >= _ref; x = 1 <= _ref ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref1, _results1;

          _results1 = [];
          for (y = _j = 1, _ref1 = this.rows; 1 <= _ref1 ? _j <= _ref1 : _j >= _ref1; y = 1 <= _ref1 ? ++_j : --_j) {
            _results1.push(0);
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Minefield.prototype.init_board = function(columns, rows, num_mines, max_mines) {
	
      this.columns = columns;
      this.rows = rows;
      this.num_mines = num_mines;
      this.max_mines = max_mines != null ? max_mines : 1;
      return this.reset_board();
    };

    Minefield.prototype.reset_board = function() {
      var on_click_to, on_rclick_to, mousedown,mouseup,td, tr, x, y, _i, _j, _ref, _ref1;

      if (this.table) {
        this.window.removeChild(this.table);
        this.game_status = -1;
        this.table = null;
      }
	
      this.table = document.createElement('table');
      this.table.setAttribute("class", "minetable");
      this.num_flags = 0;
      this.flags = this.new_table();
      this.near_flags = this.new_table();
      this.tds = this.new_table();
      for (y = _i = 0, _ref = this.rows - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; y = 0 <= _ref ? ++_i : --_i) {
        tr = document.createElement('tr');
        for (x = _j = 0, _ref1 = this.columns - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
          td = document.createElement('td');
          td.setAttribute("id", "x" + x + "y" + y);
          on_click_to = function(x_, y_, self) {
            return function() {
              self.on_click(x_, y_);
              return false;
            };
          };
          td.onclick = on_click_to(x, y, this);
          on_rclick_to = function(x_, y_, self) {
            return function() {
              self.on_rclick(x_, y_);
              return false;
            };
          };
          td.oncontextmenu = on_rclick_to(x, y, this);
          mousedown= function(x_, y_, self) {
            return function() {
              self.on_down(x_, y_);
              return false;
            };
          };
          td.onmousedown= mousedown(x,y,this);
          mouseup= function(x_, y_, self) {
            return function() {
              self.on_up(x_, y_);
              return false;
            };
          };
          td.onmouseup= mouseup(x,y,this);
          this.tds[x][y] = td;
          tr.appendChild(td);
        }
        this.table.appendChild(tr);
      }
      this.window.appendChild(this.table);
      this.init_mines();
		// === 추가: 이웃 0칸 품질 검사 후, 최대 5회 재생성 ===
var attempts = 0;
while (attempts < 5) {
  // 현재 판의 zero-tiles 수 (지뢰 없고 near_mines==0)
  var curZero = this.count_zero_no_neighbor();

  // 이론적 최대 zero-tiles
  var theoMax = this.theoretical_max_zero_cells();

  // 기준: 이론 최대의 30% 미만이면 다시 생성
  if (theoMax > 0 && curZero < Math.floor(theoMax * 0.2)) {
    this.init_mines(); // 새로 생성
    attempts++;
    continue;
  }
  break; // 기준 통과
}
// === 추가 끝 ===
      return this.on_game_status_changed();
    };

    Minefield.prototype.init_mines = function() {
      var n, n_max, num_mine_created, x, y,n2;

      this.mines = this.new_table();
      this.remaining = this.rows * this.columns;
      num_mine_created = 0;
      n2=this.columns*this.rows*220/480;
      while (num_mine_created < this.num_mines) {
        x = Math.floor(Math.random() * this.columns);
        y = Math.floor(Math.random() * this.rows);
        if (this.mines[x][y] < this.max_mines) {
          n_max = this.max_mines - this.mines[x][y];
          n_max = Math.min(n_max, this.num_mines - num_mine_created);
          if(this.num_mines - num_mine_created>n2) {
		n = n_max; n2-=0.5;
          }
          else n = Math.floor(Math.random() * n_max) + 1;
			// n은 이번에 이 칸(x,y)에 넣을 지뢰 '칸수'(1~max_mines)
if (n >= 2) {
  // 두칸~다섯칸짜리 확률표
  var p = (n === 2 ? 0.5 :
           n === 3 ? 0.5 :
           n === 4 ? 0.5 :
           n === 5 ? 0.5 : 0);

  if (Math.random() < p) {
    // 이웃에 지뢰가 없으면 이 배치는 취소하고 다시 뿌리러 감(continue)
    if (!this.has_neighbor_mine(x, y)) {
      continue; // while 루프 처음으로 돌아가서 다른 위치/수량 시도
    }
  }
}

          if (this.mines[x][y] === 0) {
            this.remaining -= 1;
          }
          this.mines[x][y] += n;
          num_mine_created += n;
        }
      }
      this.near_mines = this.generate_near_mines(this.mines);
      return this.game_status = 1;
    };

    Minefield.prototype.generate_near_mines = function(mines) {
      var near_mines, nx, ny, x, y, _i, _j, _k, _len, _ref, _ref1, _ref2, _ref3;

      near_mines = this.new_table();
      for (x = _i = 0, _ref = this.columns - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; x = 0 <= _ref ? ++_i : --_i) {
        for (y = _j = 0, _ref1 = this.rows - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
          _ref2 = this.near_positions(x, y);
          for (_k = 0, _len = _ref2.length; _k < _len; _k++) {
            _ref3 = _ref2[_k], nx = _ref3[0], ny = _ref3[1];
            near_mines[nx][ny] += mines[x][y];
          }
        }
      }
      return near_mines;
    };

    Minefield.prototype.shift_table = function(table, dx, dy) {
      var new_table, new_x, new_y, nx, ny, _i, _j, _ref, _ref1;

      new_table = this.new_table();
      for (ny = _i = 0, _ref = this.rows - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; ny = 0 <= _ref ? ++_i : --_i) {
        for (nx = _j = 0, _ref1 = this.columns - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; nx = 0 <= _ref1 ? ++_j : --_j) {
          new_x = (nx + dx + 2 * this.columns) % this.columns;
          new_y = (ny + dy + 2 * this.rows) % this.rows;
          new_table[new_x][new_y] = table[nx][ny];
        }
      }
      return new_table;
    };

    Minefield.prototype.get_class = function(x, y) {
      var td_class;

      td_class = this.tds[x][y].getAttribute("class");
      if (td_class === null || td_class === "") {
        null;
      }
      return td_class;
    };

    Minefield.prototype.set_class = function(x, y, val) {
      if (val === null) {
        return this.tds[x][y].removeAttribute("class");
      } else {
        return this.tds[x][y].setAttribute("class", val);
      }
    };

    Minefield.prototype.near_positions = function(x, y) {
      var nx, ny, ret, _i, _j, _ref, _ref1, _ref2, _ref3;

      ret = [];
      for (nx = _i = _ref = x - 1, _ref1 = x + 1; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; nx = _ref <= _ref1 ? ++_i : --_i) {
        for (ny = _j = _ref2 = y - 1, _ref3 = y + 1; _ref2 <= _ref3 ? _j <= _ref3 : _j >= _ref3; ny = _ref2 <= _ref3 ? ++_j : --_j) {
          if (nx === x && ny === y) {
            continue;
          }
          if (nx >= this.columns || nx < 0 || ny >= this.rows || ny < 0) {
            continue;
          }
          ret.push([nx, ny]);
        }
      }
      return ret;
    };

    Minefield.prototype.on_click = function(x, y) {
      var old_game_status;
 
      old_game_status = this.game_status;
      if (this.game_status < 0) {
        return;
      }
      if (this.game_status === 1) {
        this.start(x, y);
      }
      if (this.expand(x, y) < 0) {
        this.gameover(x, y);
      }
      if (this.remaining === 0) {
        this.gameclear();
      }
      if (this.on_click_func) {
        this.on_click_func(x, y);
      }
      if (old_game_status !== this.game_status) {
        return this.on_game_status_changed();
      }
    };

    Minefield.prototype.on_rclick = function(x, y) {
      var old_game_status;

      old_game_status = this.game_status;
      if (this.game_status < 0) {
        return;
      }
      if (this.game_status === 1) {
        this.game_status = 0;
      }
      this.flag(x, y);
      if (this.on_rclick_func) {
        this.on_rclick_func(x, y);
      }
      if (old_game_status !== this.game_status) {
        return this.on_game_status_changed();
      }
    };

    Minefield.prototype.on_game_status_changed = function() {
      if (this.game_status_changed_func) {
        return this.game_status_changed_func(this.game_status);
      }
    };
Minefield.prototype.on_game_status_changed2 = function() {
      if (this.game_status_changed_func2) {
        return this.game_status_changed_func2(this.game_status2);
      }
    };
    Minefield.prototype.start = function(x, y) {
      var nx, ny, _i, _ref, _results;

      this.game_status = 0;
      if (this.mines[x][y] === 0) {
        return;
      }
      _results = [];
      for (nx = _i = 0, _ref = this.columns - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; nx = 0 <= _ref ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref1, _results1;

          _results1 = [];
          for (ny = _j = 0, _ref1 = this.rows - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; ny = 0 <= _ref1 ? ++_j : --_j) {
            if (this.mines[nx][ny] === 0) {
              this.mines = this.shift_table(this.mines, x - nx, y - ny);
              _results1.push(this.near_mines = this.generate_near_mines(this.mines));
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Minefield.prototype.flag = function(x, y) {
      var n, nx, ny, td_class, _i, _len, _ref, _ref1;
      td_class = this.get_class(x, y);
      if (td_class !== null && !/^flag/.exec(td_class)) {
        return;
      }
      if(td_class==="flag-0"){
       return this.set_class(x, y, null);
      }
      n = 1;
      if (this.flags[x][y] === this.max_mines) {
        n = -this.flags[x][y];
      }
	
      this.num_flags += n;
      this.flags[x][y] += n;
      _ref = this.near_positions(x, y);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], nx = _ref1[0], ny = _ref1[1];
        this.near_flags[nx][ny] += n;
      }
      if (n > 0) {
        return this.set_class(x, y, "flag-" + this.flags[x][y]);
      } else{
        return this.set_class(x, y, "flag-0");
      }
    };

    Minefield.prototype.press = function(x, y) {
      if (this.mines[x][y] > 0) {
        return -1;
      } else if (this.get_class(x, y) !== null && this.get_class(x, y)!=="flag-0") {
        return 1;
      }
      this.remaining -= 1;
      if (this.near_mines[x][y] === 0) {
        this.set_class(x, y, "empty");
      } else {
        this.set_class(x, y, "near-" + this.near_mines[x][y]);
      }
      return 0;
    };

    Minefield.prototype.expand = function(start_x, start_y) {
      var list, nx, ny, start_flags, start_mines, td_class, x, y, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3, _ref4;

      td_class = this.get_class(start_x, start_y);
      if (td_class !== null && (td_class!=="flag-0" && /^flag/.exec(td_class))) {
        return 1;
      }
      if (this.press(start_x, start_y) < 0) {
        return -1;
      }
      list = [[start_x, start_y]];
      start_mines = this.near_mines[start_x][start_y];
      start_flags = this.near_flags[start_x][start_y];
      if (start_mines === start_flags) {
        _ref = this.near_positions(start_x, start_y);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          _ref1 = _ref[_i], nx = _ref1[0], ny = _ref1[1];
          td_class = this.get_class(nx, ny);
          if (td_class === null|| td_class==="flag-0") {
            list.push([nx, ny]);
            if (this.press(nx, ny) < 0) {
              return -1;
            }
          }
        }
      }
      while (list.length > 0) {
        _ref2 = list.pop(), x = _ref2[0], y = _ref2[1];
        if (this.near_mines[x][y] === 0) {
          _ref3 = this.near_positions(x, y);
          for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
            _ref4 = _ref3[_j], nx = _ref4[0], ny = _ref4[1];
            td_class = this.get_class(nx, ny);
            if (td_class === null || td_class==="flag-0") {
              list.push([nx, ny]);
              if (this.press(nx, ny) < 0) {
                return -1;
              }
            }
          }
        }
      }
      return 0;
    };

    Minefield.prototype.gameover = function(fail_x, fail_y) {
      var mine, x, y, _i, _ref, _results;
      var tmp,td;
      tmp = (document.getElementsByClassName("minetable")[0]).getElementsByTagName("td");;
      
      for(y=0;y<tmp.length;y++){
	td=tmp[y];
      td.onclick=null;
      td.onmouseup=null;
      td.onmousedown=null;
      td.oncontextmenu=null;
      }
      
      this.game_status = -1;
      _results = [];
      for (y = _i = 0, _ref = this.rows - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; y = 0 <= _ref ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref1, _results1;

          _results1 = [];
          for (x = _j = 0, _ref1 = this.columns - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
            mine = this.mines[x][y];
            flag=this.flags[x][y];
            if (mine > 0) {
              if (this.get_class(x, y)!=="flag-0"&&/^flag/.exec(this.get_class(x, y))) {
                continue;
              }
              this.set_class(x, y, "mine-" + mine);
              if (fail_x === x && fail_y === y) {
                _results1.push(this.set_class(x, y, "mine-exploded"+mine));
              } else {
                _results1.push(void 0);
              }
            } else {
              if (this.flags[x][y] > 0) {
                _results1.push(this.set_class(x, y, "mine-wrong"+flag));
              } else if (this.near_mines[x][y] === 0) {
                _results1.push(this.set_class(x, y, "empty"));
              } else {
                _results1.push(this.set_class(x, y, "near-" + this.near_mines[x][y]));
              }
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Minefield.prototype.gameclear = function() {
	var tmp,td;
      tmp = (document.getElementsByClassName("minetable")[0]).getElementsByTagName("td");;
      
      for(y=0;y<tmp.length;y++){
	td=tmp[y];
      td.onclick=null;
      td.onmouseup=null;
      td.onmousedown=null;
      td.oncontextmenu=null;
      }
      var mine, x, y, _i, _ref, _results;
      _results = [];
      for (y = _i = 0, _ref = this.rows - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; y = 0 <= _ref ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref1, _results1;

          _results1 = [];
          for (x = _j = 0, _ref1 = this.columns - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
            mine = this.mines[x][y];
            if (mine > 0) {
              this.set_class(x, y, "flag-" + mine);
              
               _results1.push(void 0);
              
            }
          }
          return _results1;
        }).call(this));
      }
      this.num_flags=this.num_mines;
      return this.game_status = -2;
    };
    Minefield.prototype.on_down = function() {
	this.game_status2 = 1;
	this.on_game_status_changed2();
      return 1;
      
    };
    Minefield.prototype.on_up = function() {
	this.game_status2 = 0;
	this.on_game_status_changed2();
      return 0;
    };

    Minefield.prototype.stringify = function() {
      return JSON.stringify(this.mines);
    };

    return Minefield;

  })();

  window.Minefield = Minefield;

}).call(this);
