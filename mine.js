// Generated by CoffeeScript 1.6.2 (rewritten + optimized)
// Drop-in replacement for mine.js  (black mines >0, white mines <0 supported)

(function () {
  var Minefield;

  Minefield = (function () {
    function Minefield(window, game_status_changed_func, game_status_changed_func2) {
      this.window = window;

      this.game_status_changed_func = game_status_changed_func != null ? game_status_changed_func : null;
      this.game_status_changed_func2 = game_status_changed_func2 != null ? game_status_changed_func2 : null;
      this.game_status = -1;
      this.game_status2 = 0;
      this.table = null;
      this.on_click_func = null;
      this.on_rclick_func = null;

      // ★ 하얀지뢰(음수) 지원: 기본 0으로(하위호환)
      this.num_mines_white = 0;
      this.max_mines_white = 0;

      // ★ 흰/검 깃발 카운터(별도)
      this.num_flags_white = 0;
    }

    /* ---------- 분석/이론값 ---------- */
    Minefield.prototype.theoretical_max_zero_cells = function () {
      var C = this.columns, R = this.rows;
      var total = C * R;
      if (this.num_mines <= 0 && this.num_mines_white <= 0) return total;

      var black = Math.max(0, this.num_mines|0);
      var white = Math.max(0, this.num_mines_white|0);
      var M_black = Math.max(1, this.max_mines || 1);
      var M_white = Math.max(0, this.max_mines_white || 0);

      var M = Math.max(M_black, M_white || 1);
      var needed = Math.ceil((black + white) / (M||1));

      function influenceArea(w, h) {
        var areaW = Math.min(C, w + 1);
        var areaH = Math.min(R, h + 1);
        return areaW * areaH;
      }

      var bestA = Infinity;
      var hMax = Math.min(R, needed);
      for (var h = 1; h <= hMax; h++) {
        var w = Math.ceil(needed / h);
        if (w > C) continue;
        var area = influenceArea(w, h);
        if (area < bestA) bestA = area;
      }

      var bestB = Infinity;
      if (C <= R) {
        var wB = Math.min(C, needed);
        var hB = Math.ceil(needed / wB);
        if (hB <= R) bestB = influenceArea(wB, hB);
      } else {
        var hB2 = Math.min(R, needed);
        var wB2 = Math.ceil(needed / hB2);
        if (wB2 <= C) bestB = influenceArea(wB2, hB2);
      }

      var best = Math.min(bestA, bestB);
      if (!isFinite(best)) {
        best = influenceArea(Math.min(C, needed), Math.ceil(needed / Math.min(C, needed)));
      }

      var zeroMax = total - best;
      return zeroMax < 0 ? 0 : zeroMax;
    };

    Minefield.prototype._rowsPerFrame = function () {
      var cols = this.columns || 1;
      var n = Math.floor(1000 / cols);
      if (n < 1) n = 1;
      return n;
    };

    // 1) 행 우선순위 구성
    Minefield.prototype._buildRowOrder = function(centerY, windowRows) {
      const H = this.rows;
      const inRange = [];
      const rest = [];
      const top = Math.max(0, centerY - windowRows);
      const bottom = Math.min(H - 1, centerY + windowRows);
      for (let y = 0; y < H; y++) {
        if (y >= top && y <= bottom) inRange.push(y);
        else rest.push(y);
      }
      return inRange.concat(rest);
    };

    // 2) 한 행 적용
    Minefield.prototype._applyRow = function(y, cellClassAtXY) {
      for (let x = 0; x < this.columns; x++) {
        const cls = cellClassAtXY(x, y);
        if (cls === null) {
          this.tds[x][y].removeAttribute("class");
        } else {
          if (this.tds[x][y].getAttribute("class") !== cls) {
            this.tds[x][y].setAttribute("class", cls);
          }
        }
      }
    };

    // 3) 점진 렌더
    Minefield.prototype._renderRowsIncrementally = function (rowOrder, cellClassAtXY, done) {
      let idx = 0;
      const step = () => {
        const budget = Math.min(rowOrder.length - idx, this._rowsPerFrame());
        for (let k = 0; k < budget; k++) {
          const y = rowOrder[idx++];
          this._applyRow(y, cellClassAtXY);
        }
        if (idx < rowOrder.length) {
          requestAnimationFrame(step);
        } else if (done) {
          done();
        }
      };
      requestAnimationFrame(step);
    };

    // ★ 인접 near 보정(부호 포함, 내부 파트 유지)
    Minefield.prototype._adjustNearAround = function (x, y, deltaSigned) {
      var adj = this.near_positions(x, y);
      for (var i = 0; i < adj.length; i++) {
        var nx = adj[i][0], ny = adj[i][1];
        this._near_black[nx][ny] += Math.max(0,  deltaSigned); // deltaSigned>0 → 검은
        this._near_white[nx][ny] += Math.max(0, -deltaSigned); // deltaSigned<0 → 흰
      }
      this._rebuild_near_from_parts();
    };

    // ★ parts → near_mines 합성(0 vs 1000(상쇄0) 구분)
Minefield.prototype._rebuild_near_from_parts = function () {
  this.near_mines = this.new_table();
  const hasWhite = (this.num_mines_white|0) > 0;   // ← 가드 추가
  for (var x=0; x<this.columns; x++) {
    for (var y=0; y<this.rows; y++) {
      var b = this._near_black[x][y]|0;
      var w = this._near_white[x][y]|0;
      if (hasWhite && b === w && b > 0) {          // ← 흰지뢰 있을 때만 1000 사용
        this.near_mines[x][y] = 1000;
      } else {
        this.near_mines[x][y] = b - w;
      }
    }
  }
};

// 기존 함수 삭제/대체
Minefield.prototype._adjustNearAroundColors = function (x, y, dBlack, dWhite) {
  var adj = this.near_positions(x, y);
  for (var i = 0; i < adj.length; i++) {
    var nx = adj[i][0], ny = adj[i][1];
    if (dBlack) this._near_black[nx][ny] += dBlack;
    if (dWhite) this._near_white[nx][ny] += dWhite;
  }
  this._rebuild_near_from_parts();
};
Minefield.prototype._relocateFirstClick = function (x, y) {
  var m = this.mines[x][y];
  if (m === 0) return true;

  var isWhite = (m < 0);
  var count   = Math.abs(m);
  var cap     = isWhite ? this.max_mines_white : this.max_mines;

  var W = this.columns, H = this.rows, tx = -1, ty = -1;
  outer:
  for (var yy = 0; yy < H; yy++) {
    for (var xx = 0; xx < W; xx++) {
      if (xx === x && yy === y) continue;
      if (this.mines[xx][yy] !== 0) continue;
      if (count <= cap) { tx = xx; ty = yy; break outer; }
    }
  }
  if (tx < 0) return false;

  // 색상별 델타 계산
  var addB = Math.max(0,  m);  // 옮기는 ‘검은’ 개수
  var addW = Math.max(0, -m);  // 옮기는 ‘흰’   개수

  // 원래 칸: 주변에서 해당 색상 수치 감소
  this._adjustNearAroundColors(x,  y, -addB, -addW);
  // 새 칸: 주변에서 해당 색상 수치 증가
  this._adjustNearAroundColors(tx, ty, +addB, +addW);

  // 실제 지뢰 이동
  this.mines[x][y]   = 0;
  this.mines[tx][ty] = m;
  return true;
};

    // 현재 판에서 "주변 지뢰 합 0" & 자기칸 0
    Minefield.prototype.count_zero_no_neighbor = function () {
      var cnt = 0;
      for (var x = 0; x < this.columns; x++) {
        for (var y = 0; y < this.rows; y++) {
          if (this.mines[x][y] === 0 && this.near_mines[x][y] === 0) cnt++;
        }
      }
      return cnt;
    };

    // 흰/검 인접 체크
    Minefield.prototype.has_neighbor_mine = function (x, y) {
      var adj = this.near_positions(x, y);
      for (var i = 0; i < adj.length; i++) {
        var nx = adj[i][0], ny = adj[i][1];
        if (Math.abs(this.mines[nx][ny]) > 0) return true;
      }
      return false;
    };

    /* ---------- 기본 테이블 유틸 ---------- */
    Minefield.prototype.new_table = function () {
      var x, y, _i, _ref, _results;
      _results = [];
      for (x = _i = 1, _ref = this.columns; 1 <= _ref ? _i <= _ref : _i >= _ref; x = 1 <= _ref ? ++_i : --_i) {
        _results.push((function () {
          var _j, _ref1, _results1;
          _results1 = [];
          for (y = _j = 1, _ref1 = this.rows; 1 <= _ref1 ? _j <= _ref1 : _j >= _ref1; y = 1 <= _ref1 ? ++_j : --_j) {
            _results1.push(0);
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    /* ---------- 초기화 ---------- */
    // 흰지뢰 인자 추가(하위호환 OK)
    Minefield.prototype.init_board = function (columns, rows, num_mines, max_mines, num_mines_white, max_mines_white,use_nopick) {
      this.use_nopick = use_nopick;  
      this.columns = columns;
      this.rows = rows;
      this.num_mines = num_mines|0;
      this.max_mines = (max_mines != null ? max_mines : 1)|0;
      this.num_mines_white = Math.max(0, (num_mines_white|0)||0);
      this.max_mines_white = Math.max(0, (max_mines_white|0)||0);

      this._ensureWorkBuffers();
      return this.reset_board();
    };

    Minefield.prototype._ensureWorkBuffers = function () {
      const size = this.columns * this.rows;
      if (!this._visit || this._visit.length !== size) {
        this._visit = new Uint32Array(size);
        this._visitGen = 1;
        this._queueX = new Int32Array(size);
        this._queueY = new Int32Array(size);
      }
    };

    Minefield.prototype._attachDelegatedEvents = function () {
      if (!this.table) return;
      const tbl  = this.table;
      const self = this;

      if (this._delegated) this._detachDelegatedEvents();

      function getXYFrom(td) {
        const x = td && td.dataset ? parseInt(td.dataset.x, 10) : NaN;
        const y = td && td.dataset ? parseInt(td.dataset.y, 10) : NaN;
        return [x, y];
      }

      const onClick = function (e) {
        if (e.button !== 0) return;
        const td = e.target.closest('td');
        if (!td || !tbl.contains(td)) return;
        const [x, y] = getXYFrom(td);
        if (Number.isNaN(x) || Number.isNaN(y)) return;
        self.on_click(x, y);
        e.preventDefault();
      };

      const onContextMenu = function (e) {
        const td = e.target.closest('td');
        if (!td || !tbl.contains(td)) return;
        const [x, y] = getXYFrom(td);
        if (Number.isNaN(x) || Number.isNaN(y)) return;
        self.on_rclick(x, y);
        e.preventDefault();
      };

      const onMouseDown = function (e) {
        if (e.button === 1) return;
        const td = e.target.closest('td');
        if (!td || !tbl.contains(td)) return;
        const [x, y] = getXYFrom(td);
        if (Number.isNaN(x) || Number.isNaN(y)) return;
        self.on_down(x, y);
      };

      const onMouseUp = function (e) {
        if (e.button === 1) return;
        const td = e.target.closest('td');
        if (!td || !tbl.contains(td)) return;
        const [x, y] = getXYFrom(td);
        if (Number.isNaN(x) || Number.isNaN(y)) return;
        self.on_up(x, y);
      };

      tbl.addEventListener('click', onClick);
      tbl.addEventListener('contextmenu', onContextMenu);
      tbl.addEventListener('mousedown', onMouseDown);
      tbl.addEventListener('mouseup', onMouseUp);

      this._delegated = { onClick, onContextMenu, onMouseDown, onMouseUp };
    };

    Minefield.prototype._detachDelegatedEvents = function () {
      if (!this.table || !this._delegated) return;
      const { onClick, onContextMenu, onMouseDown, onMouseUp } = this._delegated;
      this.table.removeEventListener('click', onClick);
      this.table.removeEventListener('contextmenu', onContextMenu);
      this.table.removeEventListener('mousedown', onMouseDown);
      this.table.removeEventListener('mouseup', onMouseUp);
      this._delegated = null;
    };

    // 점진적 테이블 생성
    Minefield.prototype._buildTableIncrementally = function(done) {
      const batchRows = 40;
      let y = 0;
      const tbl  = this.table;
      const cols = this.columns;
      const rows = this.rows;

      const step = () => {
        const frag = document.createDocumentFragment();
        const yEnd = Math.min(rows, y + batchRows);

        for (; y < yEnd; y++) {
          const tr = document.createElement('tr');
          for (let x = 0; x < cols; x++) {
            const td = document.createElement('td');
            td.setAttribute('id', 'x' + x + 'y' + y);
            td.dataset.x = x;
            td.dataset.y = y;
            this.tds[x][y] = td;
            tr.appendChild(td);
          }
          frag.appendChild(tr);
        }

        tbl.appendChild(frag);

        if (y < rows) {
          requestAnimationFrame(step);
        } else {
          this.window.appendChild(tbl);
          if (typeof done === "function") done();
        }
      };

      requestAnimationFrame(step);
    };

    // reset_board
    Minefield.prototype.reset_board = function() {
      this.opened_cells = 0;
      this.reloc_used   = 0;
      this.opened_safe  = 0;
      this.total_safe   = 0;
      this.bonus_reloc_count = 0;
      this.bonus_thresholds  = this.compute_bonus_thresholds();

      this.num_flags  = 0;
      this.num_flags_white = 0;
      this.flags      = this.new_table();     // 부호 있는 깃발값(>0 검은, <0 흰)
      this.near_flags = this.new_table();     // 합(부호 포함)
      this.tds        = this.new_table();

      // 내부 near parts
      this._near_black = this.new_table();
      this._near_white = this.new_table();

      this._ensureWorkBuffers();

      if (this.table) {
        this.window.removeChild(this.table);
        this.game_status = -1;
        this.table = null;
      }

      this.table = document.createElement('table');
      this.table.setAttribute("class", "minetable");

      this.num_flags  = 0;
      this.num_flags_white = 0;
      this.flags      = this.new_table();
      this.near_flags = this.new_table();
      this.tds        = this.new_table();
      this._near_black = this.new_table();
      this._near_white = this.new_table();

      this._buildTableIncrementally(function() {
        // 후보 여러 판 생성 후 best 선택
        var bestZero = -1;
        var bestMines = null;
        var bestNearB = null, bestNearW = null;
        var bestNear = null;
        var bestRemaining = 0;

        var retryMap = {1:1, 2:2, 3:4, 4:8, 5:12, 6:18};
        if(this.use_nopick === true) retryMap = {1:1, 2:1, 3:1, 4:1, 5:1, 6:1};
        var retries = retryMap[Math.min(this.max_mines+this.max_mines_white,6)] || 1;

        for (var attempt = 0; attempt < retries; attempt++) {
          
          this.init_mines(); // mines/near_mines/_near_black/_near_white/remaining 갱신
          var curZero = this.count_zero_no_neighbor();
          if (curZero > bestZero) {
            bestZero = curZero;
            bestMines = JSON.parse(JSON.stringify(this.mines));
            bestNearB = JSON.parse(JSON.stringify(this._near_black));
            bestNearW = JSON.parse(JSON.stringify(this._near_white));
            bestNear  = JSON.parse(JSON.stringify(this.near_mines));
            bestRemaining = this.remaining;
          }
        }

        if (bestMines) {
          this.mines       = bestMines;
          this._near_black = bestNearB;
          this._near_white = bestNearW;
          this.near_mines  = bestNear;
          this.remaining   = bestRemaining;
          this.game_status = 1;
        }

        this.on_game_status_changed();
      }.bind(this));

      this._attachDelegatedEvents();
    };

    /* ---------- 상태 체크 ---------- */
    Minefield.prototype.is_opened = function (x, y) {
      var c = this.get_class(x, y);
      if (c === null) return false;
      if (/^flag/.test(c)) return false;
      if (c === "empty") return true;
      if (/^near-/.test(c)) return true;
      return false;
    };

    Minefield.prototype.has_opened_neighbor = function (x, y) {
      var adj = this.near_positions(x, y);
      for (var i = 0; i < adj.length; i++) {
        var nx = adj[i][0], ny = adj[i][1];
        if (this.is_opened(nx, ny)) return true;
      }
      return false;
    };

    /* ---------- 조합/후보 선택(지뢰 재배치) ---------- */
    Minefield.prototype._combinations_pick = function (candidates, m) {
      var res = [];
      function dfs(start, path) {
        if (path.length === m) { res.push(path.slice()); return; }
        for (var i = start; i <= candidates.length - (m - path.length); i++) {
          path.push(candidates[i]);
          dfs(i + 1, path);
          path.pop();
        }
      }
      if (m <= candidates.length && m > 0) dfs(0, []);
      return res;
    };

    // 색상 구분 후보 추출
    // 후보 추출: 성능 튜닝(랜덤 샘플 → 실패 많으면 선형 스캔), 총 10칸 제한
// - 소스 8방향은 예외/최우선 후보(조건 맞으면 모두 포함)
// - 그 외는 "열린 칸 인접 아님" + 색 혼합 금지 + CAP 미만
// - 총 반환 개수: 최대 10개(소스 우선)
Minefield.prototype._pick_reloc_candidates = function (srcX, srcY, isWhite) {
  var cap = isWhite ? this.max_mines_white : this.max_mines;
  var LIMIT_TOTAL = 10;

  function canAccept(self, cx, cy) {
    var v = self.mines[cx][cy];
    if ((isWhite && v > 0) || (!isWhite && v < 0)) return false; // 색 혼합 금지
    return Math.abs(v) < cap; // CAP 미만
  }
  function isUnopenedOrFlag(self, cx, cy) {
    var cls = self.get_class(cx, cy);
    return (cls === null) || /^flag/.test(cls) || (cls === "flag-0");
  }

  // 소스 8방향(예외/최우선)
  var nearSrc = this.near_positions(srcX, srcY);
  var nearSrcSet = {};
  for (var i = 0; i < nearSrc.length; i++) {
    nearSrcSet[nearSrc[i][0] + "," + nearSrc[i][1]] = true;
  }

  // 1) 소스 8방향에서 조건 충족 전부 수집
  var priority0 = [];
  for (var i0 = 0; i0 < nearSrc.length; i0++) {
    var nx = nearSrc[i0][0], ny = nearSrc[i0][1];
    if (!isUnopenedOrFlag(this, nx, ny)) continue;
    if (!canAccept(this, nx, ny)) continue;
    priority0.push([nx, ny]);
  }

  // 총 한도에서 소스 후보만큼 먼저 차감
  var remainSlots = Math.max(0, LIMIT_TOTAL - priority0.length);
  if (remainSlots === 0) {
    // 10개 꽉 찼으면 소스 8방향만 반환(랜덤 약간 섞기)
    shuffle(priority0);
    return priority0;
  }

  // 2) 그 외 후보는…
  //    - 소스 8방향 제외
  //    - 소스 셀 자체 제외
  //    - 이미 열린 칸 인접(X)
  //    - 위 조건 + 수용 가능
  function isEligibleRest(self, cx, cy) {
    if (cx === srcX && cy === srcY) return false;
    if (nearSrcSet[cx + "," + cy]) return false;
    if (!isUnopenedOrFlag(self, cx, cy)) return false;
    if (!canAccept(self, cx, cy)) return false;
    // 열린 칸에 인접하면 제외
    if (self.has_opened_neighbor(cx, cy)) return false;
    return true;
  }

  // 전체 안 열린 칸 수를 대강 파악(10개보다 작으면 그 수만큼만 뽑게)
  var unopenedCount = 0;
  // (너무 큰 판에서 전수 세기 비용이 크면 생략 가능하지만,
  //  여기서는 O(WH) 1회가 허용 가능하다고 보고 간단히 셉니다.)
  for (var by = 0; by < this.rows; by++) {
    for (var bx = 0; bx < this.columns; bx++) {
      if (bx === srcX && by === srcY) continue;
      var cls0 = this.get_class(bx, by);
      if ((cls0 === null) || /^flag/.test(cls0) || (cls0 === "flag-0")) unopenedCount++;
    }
  }
  // 남은 슬롯 상한을 전체 안 열린 칸 수로도 한 번 더 클램프
  remainSlots = Math.min(remainSlots, Math.max(0, unopenedCount));

  // 랜덤 샘플링으로 시도
  var rest = [];
  var used = {}; // 중복 방지
  var tries = 0;
  var FAIL_LIMIT = Math.max(1000, remainSlots * 200); // 실패 많이 나면 선형 스캔 전환
  while (rest.length < remainSlots && tries < FAIL_LIMIT) {
    var rx = (Math.random() * this.columns) | 0;
    var ry = (Math.random() * this.rows) | 0;
    var key = rx + "," + ry;
    if (used[key]) { tries++; continue; }
    used[key] = 1;

    if (isEligibleRest(this, rx, ry)) {
      rest.push([rx, ry]);
    } else {
      tries++;
    }
  }

  // 랜덤으로 충분히 못 채웠다면, 선형 스캔으로 보충(앞에서부터 차곡차곡)
  if (rest.length < remainSlots) {
    for (var cy = 0; cy < this.rows && rest.length < remainSlots; cy++) {
      for (var cx = 0; cx < this.columns && rest.length < remainSlots; cx++) {
        var k2 = cx + "," + cy;
        if (used[k2]) continue; // 랜덤에서 이미 시도한 좌표면 패스
        if (isEligibleRest(this, cx, cy)) {
          rest.push([cx, cy]);
        }
      }
    }
    // 만약 조건에 맞는 칸이 부족하면, 그냥 있는 만큼만 사용(규칙대로)
  }

  shuffle(priority0);
  shuffle(rest);

  // 총 10칸(또는 그보다 적은 수)으로 합치기
  // 소스 8방향(우선) + 나머지
  var out = priority0.slice(0, LIMIT_TOTAL);
  var need = LIMIT_TOTAL - out.length;
  for (var i2 = 0; i2 < rest.length && need > 0; i2++, need--) {
    out.push(rest[i2]);
  }
  return out;

  // ---- 유틸: 셔플 ----
  function shuffle(a) {
    for (var i = a.length - 1; i > 0; i--) {
      var j = (Math.random() * (i + 1)) | 0;
      var t = a[i]; a[i] = a[j]; a[j] = t;
    }
  }
};


    /* ---------- 구제 규칙 ---------- */
    Minefield.prototype.get_reloc_allowed = function () {
      var mm = Math.max(1, (this.max_mines+this.max_mines_white) || 1);
      if (mm == 1) mm = 10000;
      else if (mm == 2) mm = 2000;
      else if (mm == 3) mm = 400;
      else if (mm == 4) mm = 300;
      else if (mm == 5) mm = 225;
      else if (mm == 6) mm = 167;
      else if (mm == 7) mm = 126;
      else if (mm == 8) mm = 95;
      else if (mm == 9) mm = 71;
      else if (mm == 10) mm = 53;
      else if (mm == 11) mm = 40;
      else mm = 30;

      var base = Math.floor(this.opened_cells / mm);
      var bonus = this.bonus_reloc_count || 0;
      return base + bonus;
    };

    Minefield.prototype.compute_bonus_thresholds = function () {
      var mm = Math.max(1, (this.max_mines+this.max_mines_white) || 1);
      if (mm <= 2) return [0.997];
      else if (mm <= 4) return [0.99, 0.997];
      else if (mm <= 6) return [0.95, 0.99, 0.999];
      else if (mm <= 8) return [0.93, 0.99, 0.993, 0.999];
      else if (mm <= 10) return [0.9, 0.93, 0.99, 0.993, 0.999];
      else return [0.7, 0.9, 0.93, 0.99, 0.993, 0.999];
    };

    /* ---------- 지뢰 재배치(구제) ---------- */
    Minefield.prototype.try_relocate_from = function (x, y) {
      var mSigned = this.mines[x][y];
      var m = Math.abs(mSigned);
      if (m <= 0) return false;

      var isWhite = (mSigned < 0);
      var cap = isWhite ? this.max_mines_white : this.max_mines;

      var cand = this._pick_reloc_candidates(x, y, isWhite);
      if (cand.length < m) return false;

      var affected = {};
      var self = this;

      function addNeighbors(px, py) {
        var adj = self.near_positions(px, py);
        for (var i = 0; i < adj.length; i++) {
          var nx = adj[i][0], ny = adj[i][1];
          if (self.is_opened(nx, ny)) affected[nx + "," + ny] = [nx, ny];
        }
      }
      addNeighbors(x, y);
      for (var c = 0; c < cand.length; c++) addNeighbors(cand[c][0], cand[c][1]);

      var combos = this._combinations_pick(cand, m);

      for (var ci = 0; ci < combos.length; ci++) {
        var picks = combos[ci];

        var okSlots = true;
        for (var p = 0; p < picks.length; p++) {
          var px = picks[p][0], py = picks[p][1];
          var next = this.mines[px][py] + (isWhite ? -1 : +1);
          if (Math.sign(this.mines[px][py]) !== 0 && Math.sign(next) !== Math.sign(this.mines[px][py])) { okSlots = false; break; }
          if (Math.abs(next) > cap) { okSlots = false; break; }
        }
        if (!okSlots) continue;

        var allSame = true;

// --- (직전 코드 동일) ---
var allSame = true;

// 소스 이웃(합/절댓값에 공통으로 빠질 대상) 표시
var decNeighbors = {};
var adjXY = this.near_positions(x, y);
for (var i2 = 0; i2 < adjXY.length; i2++) {
  decNeighbors[adjXY[i2][0] + "," + adjXY[i2][1]] = true;
}

// 타깃별 이웃에 “몇 개” 들어가는지 카운트
var incCount = {};
for (var q = 0; q < picks.length; q++) {
  var ax = picks[q][0], ay = picks[q][1];
  var adjA = this.near_positions(ax, ay);
  for (var r = 0; r < adjA.length; r++) {
    var key = adjA[r][0] + "," + adjA[r][1];
    incCount[key] = (incCount[key] || 0) + 1;
  }
}

// 유틸: 현재 절댓값 합(near_abs) 계산
function currentAbsAt(self, cx, cy) {
  var adj = self.near_positions(cx, cy);
  var s = 0;
  for (var u = 0; u < adj.length; u++) {
    var vx = adj[u][0], vy = adj[u][1];
    s += Math.abs(self.mines[vx][vy]);
  }
  return s;
}

// 공개된(열린) 영향 칸들 확인
for (var key in affected) {
  var pos = affected[key];
  var ox = pos[0], oy = pos[1];

  var origSent = this.near_mines[ox][oy];        // 1000 / 0 / ±n
  var origSum  = (origSent === 1000 ? 0 : origSent);
  var curAbs   = currentAbsAt(this, ox, oy);

  // 합 변화량
  var deltaSum = 0;
  if (decNeighbors[key]) deltaSum -= mSigned; // 소스 제거(부호 포함)
  var incC = incCount[key] || 0;              // 타깃 추가 개수
  deltaSum += isWhite ? -incC : incC;

  // 절댓값 합 변화량(색 불문 동일하게 증가/감소)
  var deltaAbs = 0;
  if (decNeighbors[key]) deltaAbs -= Math.abs(mSigned);
  deltaAbs += incC;

  var finalSum = origSum + deltaSum;
  var finalAbs = curAbs  + deltaAbs;

  var ok = true;
  if (origSent === 1000) {
    // 상쇄0은 "보이는 값 0" + "실존 지뢰 존재"
    ok = (finalSum === 0 && finalAbs > 0);
  } else if (origSent === 0) {
    // 진짜0은 인접 지뢰가 아예 없어야 함
    ok = (finalSum === 0 && finalAbs === 0);
  } else {
    // 숫자칸은 숫자 보존(부호/값 동일)
    ok = (finalSum === origSum);
  }

  if (!ok) { allSame = false; break; }
}
// --- (이후 기존 코드 흐름 동일) ---

        if (!allSame) continue;

        var temp = JSON.parse(JSON.stringify(this.mines));
        var newly = {};

        temp[x][y] = 0;
        for (var s = 0; s < picks.length; s++) {
          var tx = picks[s][0], ty = picks[s][1];
          if (temp[tx][ty] === 0) newly[tx + "," + ty] = true;
          temp[tx][ty] += (isWhite ? -1 : +1);
        }

        // 커밋
        this.mines = temp;

        // parts 재계산
        this._near_black = this.new_table();
        this._near_white = this.new_table();
        for (var xx = 0; xx < this.columns; xx++) {
          for (var yy = 0; yy < this.rows; yy++) {
            var v = this.mines[xx][yy];
            if (v === 0) continue;
            var adj = this.near_positions(xx, yy);
            var addB = Math.max(0, v);
            var addW = Math.max(0, -v);
            for (var k = 0; k < adj.length; k++) {
              var nx = adj[k][0], ny = adj[k][1];
              this._near_black[nx][ny] += addB;
              this._near_white[nx][ny] += addW;
            }
          }
        }
        this._rebuild_near_from_parts();

        var deltaRemaining = 1 - Object.keys(newly).length;
        this.remaining += deltaRemaining;

        return true;
      }
      return false;
    };

    /* ---------- 지뢰 뿌리기 ---------- */
// ★ 지뢰 배치: 1) 원본 랜덤(n2/클러스터) → 2) 선형 보충 → 3) 강제 통합/비우기
// + 마지막에 "최소 1칸 비워두기" 보장
Minefield.prototype.init_mines = function () {
  var x, y;

  // 공용 상태 초기화
  this.mines = this.new_table();
  this.remaining = this.rows * this.columns;
  this._near_black = this.new_table();
  this._near_white = this.new_table();

  const W = this.columns, H = this.rows;
  const capBlack = Math.max(1, this.max_mines | 0);
  const capWhite = Math.max(0, this.max_mines_white | 0);
  const totalBlack = Math.max(0, this.num_mines | 0);
  const totalWhite = Math.max(0, this.num_mines_white | 0);

  // ----- 유틸리티 -----
  const val = (xx, yy) => this.mines[xx][yy];
  const set = (xx, yy, v) => { this.mines[xx][yy] = v; };
  function canAdd(self, xx, yy, signNeg) {
    const v = self.mines[xx][yy];
    if (signNeg) {
      if (v > 0) return false;                 // 혼합 금지
      return Math.abs(v) < capWhite;
    } else {
      if (v < 0) return false;                 // 혼합 금지
      return Math.abs(v) < capBlack;
    }
  }
  function addOne(self, xx, yy, signNeg) {
    const v = self.mines[xx][yy];
    if (v === 0) self.remaining -= 1;          // 새로 지뢰 생기는 칸
    self.mines[xx][yy] = v + (signNeg ? -1 : +1);
  }
  const hasZeroCell = () => {
    for (let yy=0; yy<H; yy++) for (let xx=0; xx<W; xx++) if (this.mines[xx][yy] === 0) return true;
    return false;
  };
  const oppSignNeg = (neg) => !neg;
  const signCap = (neg) => neg ? capWhite : capBlack;

  // 1단계에서 무한루프 방지용(“막히기 전까지”만 1단계 유지)
  const randStallLimit = Math.max(2000, Math.floor(W * H * 8));

  // ----- 3단계 포함한 증강 배치 루틴 -----
  const placeColorEnhanced = (TOTAL, CAP, signNeg) => {
    let created = 0;

    // ===== 1) 원본 랜덤 뿌리기 (요청: n2/클러스터링 로직 그대로) =====
    //  - 단, 혼합 금지/용량 체크는 색별 규칙으로 반영
    let n2 = W * H * 220 / 480;      // 전체칸수 * 220/480
    let stall = 0;
    while (created < TOTAL && stall < randStallLimit) {
      x = (Math.random() * W) | 0;
      y = (Math.random() * H) | 0;

      const cur = this.mines[x][y];
      // 색 혼합 금지
      if ((signNeg && cur > 0) || (!signNeg && cur < 0)) { stall++; continue; }
      // 용량 체크
      let curAbs = Math.abs(cur);
      if (curAbs >= CAP) { stall++; continue; }

      let n_max = Math.min(CAP - curAbs, TOTAL - created);
      let n;
      if ((TOTAL - created) > n2) { n = n_max; n2 -= 0.5; }   // 비율만큼은 최대치로 채우기
      else                        { n = Math.floor(Math.random() * n_max) + 1; }

      // 클러스터링 확률(주변에 지뢰 없으면 건너뜀)
      if (n >= 2) {
        var p = (n === 2 ? 0.2 :
                 n === 3 ? 0.5 :
                 n === 4 ? 0.5 :
                 n === 5 ? 0.5 :
                 n === 6 ? 0.5 : 0);
        if (Math.random() < p) {
          if (!this.has_neighbor_mine(x, y)) {
            stall++; continue;
          }
        }
      }

      if (this.mines[x][y] === 0) this.remaining -= 1;
      this.mines[x][y] += (signNeg ? -n : +n);
      created += n;
      stall = 0; // 성공했으니 stall 리셋
    }
    if (created >= TOTAL) return created;

    // ===== 2) 선형 스윕으로 보충 =====
    for (let yy = 0; yy < H && created < TOTAL; yy++) {
      for (let xx = 0; xx < W && created < TOTAL; xx++) {
        while (created < TOTAL && canAdd(this, xx, yy, signNeg)) {
          addOne(this, xx, yy, signNeg);
          created++;
        }
      }
    }
    if (created >= TOTAL) return created;

    // ===== 3) 강제 통합/비우기(상대색 재배치로 빈칸 만든 뒤 내 색 채워 넣기) =====
    let safety = W * H * 4; // 무한루프 방지
    while (created < TOTAL && safety-- > 0) {
      // 3-a) 비울 상대색 칸(작은 수량부터) 찾기
      let freedX = -1, freedY = -1, freedHad = 0;
      find_source:
      for (let want = 1; want <= signCap(oppSignNeg(signNeg)); want++) {
        for (let yy = 0; yy < H; yy++) {
          for (let xx = 0; xx < W; xx++) {
            const v = val(xx, yy);
            if (signNeg ? v <= 0 : v >= 0) continue; // 상대색만
            if (Math.abs(v) !== want) continue;

            // 이 칸의 상대색 지뢰를 다른 곳(CAP 범위 내)으로 전부 옮길 수 있는지 확인
            let remain = Math.abs(v);
            for (let y2=0; y2<H && remain>0; y2++) {
              for (let x2=0; x2<W && remain>0; x2++) {
                if (x2===xx && y2===yy) continue;
                const vv = val(x2, y2);
                const cap = signCap(oppSignNeg(signNeg));
                if (signNeg ? vv < 0 : vv > 0) {
                  const room = cap - Math.abs(vv);
                  if (room > 0) remain -= Math.min(room, remain);
                } else if (vv === 0) {
                  // 빈칸도 상대색으로 채워 수용 가능
                  remain -= Math.min(cap, remain);
                }
              }
            }
            if (remain <= 0) { freedX = xx; freedY = yy; freedHad = Math.abs(v); break find_source; }
          }
        }
      }
      if (freedX === -1) break; // 더는 불가

      // 3-b) 실제로 상대색을 분산해 freed 칸 비우기
      {
        const oppNeg = oppSignNeg(signNeg);
        let remain = freedHad;

        // 기존 상대색 칸부터 CAP까지 채우기
        for (let yy=0; yy<H && remain>0; yy++) {
          for (let xx=0; xx<W && remain>0; xx++) {
            if (xx===freedX && yy===freedY) continue;
            const vv = val(xx, yy);
            if (oppNeg ? vv < 0 : vv > 0) {
              const cap = signCap(oppNeg);
              const room = cap - Math.abs(vv);
              if (room > 0) {
                const mv = Math.min(room, remain);
                set(xx, yy, vv + (oppNeg ? -mv : +mv));
                remain -= mv;
              }
            }
          }
        }
        // 부족하면 빈칸을 상대색으로 신규 채우기
        for (let yy=0; yy<H && remain>0; yy++) {
          for (let xx=0; xx<W && remain>0; xx++) {
            if (xx===freedX && yy===freedY) continue;
            const vv = val(xx, yy);
            if (vv !== 0) continue;
            const cap = signCap(oppNeg);
            const mv = Math.min(cap, remain);
            set(xx, yy, (oppNeg ? -mv : +mv));
            this.remaining -= 1; // 새로 지뢰 생김
            remain -= mv;
          }
        }

        // 원본 칸 비우기
        if (val(freedX, freedY) !== 0) {
          set(freedX, freedY, 0);
          this.remaining += 1;
        }
      }

      // 3-c) 비워진 칸에 내 색으로 채우기
      while (created < TOTAL && canAdd(this, freedX, freedY, signNeg)) {
        addOne(this, freedX, freedY, signNeg);
        created++;
      }
    }

    return created;
  };

  // 배치 순서: 검은 → 흰 (검은 우선)
  placeColorEnhanced(totalBlack, capBlack, /*signNeg=*/false);
  if (totalWhite > 0 && capWhite > 0) {
    placeColorEnhanced(totalWhite, capWhite, /*signNeg=*/true);
  }

  // ===== ★ 최종 보정: "최소 1칸은 비워 두기" 보장 =====
  if (!hasZeroCell()) {
    const tryFreeOneCellBySign = (signNeg) => {
      const cells = [];
      for (let yy=0; yy<H; yy++) for (let xx=0; xx<W; xx++) {
        const v = val(xx, yy);
        if (v === 0) continue;
        if (signNeg ? (v < 0) : (v > 0)) cells.push([xx, yy, Math.abs(v)]);
      }
      cells.sort((a,b)=>a[2]-b[2]); // 적은 수부터

      for (let idx=0; idx<cells.length; idx++) {
        const [sx, sy, need] = cells[idx];
        const cap = signCap(signNeg);
        let remain = need;

        // 수용 가능성 체크
        for (let yy=0; yy<H && remain>0; yy++) {
          for (let xx=0; xx<W && remain>0; xx++) {
            if (xx===sx && yy===sy) continue;
            const vv = val(xx, yy);
            if (signNeg) {
              if (vv > 0) continue;
              const room = cap - Math.abs(vv);
              if (room > 0) remain -= Math.min(room, remain);
            } else {
              if (vv < 0) continue;
              const room = cap - Math.abs(vv);
              if (room > 0) remain -= Math.min(room, remain);
            }
          }
        }
        if (remain > 0) continue;

        // 실제 분산
        let left = need;
        for (let yy=0; yy<H && left>0; yy++) {
          for (let xx=0; xx<W && left>0; xx++) {
            if (xx===sx && yy===sy) continue;
            const vv = val(xx, yy);
            const room = cap - Math.abs(vv);
            if (room > 0 && (signNeg ? vv <= 0 : vv >= 0)) {
              const mv = Math.min(room, left);
              set(xx, yy, vv + (signNeg ? -mv : +mv));
              if (vv === 0 && mv > 0) this.remaining -= 1;
              left -= mv;
            }
          }
        }
        // 원본 비우기
        if (val(sx, sy) !== 0) {
          set(sx, sy, 0);
          this.remaining += 1;
        }
        return true;
      }
      return false;
    };

    if (!tryFreeOneCellBySign(false)) { // 검은
      if (!tryFreeOneCellBySign(true)) { // 흰
        // (매우 드묾) 상대색을 재배치해 빈칸을 만든다 — 생략 안전가드
        for (let sign of [true, false]) {
          let done = false;
          const cap = signCap(sign);
          outer:
          for (let yy=0; yy<H; yy++) for (let xx=0; xx<W; xx++) {
            const v = val(xx, yy);
            if (v === 0) { done = true; break outer; }
            if (sign ? v < 0 : v > 0) {
              let remain = Math.abs(v);
              for (let y2=0; y2<H && remain>0; y2++)
                for (let x2=0; x2<W && remain>0; x2++) {
                  if (x2===xx && y2===yy) continue;
                  const vv = val(x2, y2);
                  if (sign ? (vv > 0) : (vv < 0)) continue;
                  const room = cap - Math.abs(vv);
                  if (room > 0) remain -= Math.min(room, remain);
                }
              if (remain===0) {
                let left = Math.abs(v);
                for (let y2=0; y2<H && left>0; y2++)
                  for (let x2=0; x2<W && left>0; x2++) {
                    if (x2===xx && y2===yy) continue;
                    const vv = val(x2, y2);
                    if (sign ? (vv > 0) : (vv < 0)) continue;
                    const room = cap - Math.abs(vv);
                    if (room > 0) {
                      const mv = Math.min(room, left);
                      set(x2, y2, vv + (sign ? -mv : +mv));
                      if (vv === 0 && mv > 0) this.remaining -= 1;
                      left -= mv;
                    }
                  }
                set(xx, yy, 0);
                this.remaining += 1;
                done = true;
                break outer;
              }
            }
          }
          if (done) break;
        }
      }
    }
  }

  // --- parts(근방 수) 재계산 ---
  this._near_black = this.new_table();
  this._near_white = this.new_table();
  for (var xx = 0; xx < this.columns; xx++) {
    for (var yy = 0; yy < this.rows; yy++) {
      var v = this.mines[xx][yy];
      if (v === 0) continue;
      var adj = this.near_positions(xx, yy);
      var addB = Math.max(0, v);
      var addW = Math.max(0, -v);
      for (var k = 0; k < adj.length; k++) {
        var nx = adj[k][0], ny = adj[k][1];
        this._near_black[nx][ny] += addB;
        this._near_white[nx][ny] += addW;
      }
    }
  }
  this._rebuild_near_from_parts();

  // total_safe
  this.total_safe = 0;
  for (var i = 0; i < this.columns; i++) {
    for (var j = 0; j < this.rows; j++) {
      if (this.mines[i][j] === 0) this.total_safe++;
    }
  }

  this.game_status = 1;
  return this.game_status;
};
// ★ 붙여넣기용: "no-pick(찍기 없음) 보드" 생성기 (빠른판)
// 조건:
//  - 무작위 보드는 기존 this.init_mines()를 그대로 사용해 생성
//  - 첫 클릭 (firstX, firstY) 및 주변 8칸은 반드시 지뢰 0(=진짜 0, 상쇄0 금지)
//  - 보드가 '추론만으로' 풀리는지 빠른 검증(경량 규칙 + 존재성 DFS)
//  - fallback(폴백) 금지: solvable한 보드를 찾을 때까지 '무한히' 시도
//  - solvable 보드가 나오면, 추론 근거 트리를 console에 로그로 출력
//  - 음수지뢰 존재하면 일부규칙(delta) 사용불가(1인 칸이 2검은지뢰+1하얀지뢰 가능)
// ★ 붙여넣기용: "no-pick(찍기 없음) 보드" 생성기 (빠른판)

Minefield.prototype.init_mines_nopick = function (firstX, firstY) {
  const hasWhites = ((this.num_mines_white|0) > 0);  // 흰지뢰 존재 여부
  const W = this.columns|0, H = this.rows|0;
  const capB = Math.max(1, this.max_mines|0);        // 칸당 검은 지뢰 최대
  const capW = Math.max(0, this.max_mines_white|0);  // 칸당 흰 지뢰 최대
  const classicMode = (!hasWhites) && (capB === 1);  // 클래식 모드(칸당 0/1, 흰지뢰 없음)

  // ===== 유틸 =====
  const idx = (x,y)=> y*W + x;
  const inBounds = (x,y)=> (x>=0 && y>=0 && x<W && y<H);

  const rebuildParts = () => {
    this._near_black = this.new_table();
    this._near_white = this.new_table();
    for (let x=0;x<W;x++) for (let y=0;y<H;y++){
      const v = this.mines[x][y]|0;
      if (!v) continue;
      const addB = v>0 ? v : 0;
      const addW = v<0 ? -v : 0;
      const adj = this.near_positions(x,y);
      for (let i=0;i<adj.length;i++){
        const nx=adj[i][0], ny=adj[i][1];
        this._near_black[nx][ny] += addB;
        this._near_white[nx][ny] += addW;
      }
    }
    this._rebuild_near_from_parts();
  };

  // 첫 3x3이 전부 0(지뢰 없음)인지
  const first3x3AllZero = (X,Y) => {
    for (let dy=-1; dy<=1; dy++) for (let dx=-1; dx<=1; dx++){
      const x=X+dx, y=Y+dy;
      if (!inBounds(x,y)) continue;
      if ((this.mines[x][y]|0) !== 0) return false;
    }
    return true;
  };

  // ===== 추론 로거(결정 근거 트리) =====
  const Trace = [];
  function pushTrace(kind, payload) { Trace.push({ kind, ...payload }); }
  function dumpTraceToConsole() {
    console.groupCollapsed("[Minesweeper] 추론 근거 트리");
    for (let i=0;i<Trace.length;i++){
      const t=Trace[i];
      if (t.kind==="open") {
        console.log(`OPEN (${t.x},${t.y}) - ${t.reason}`);
      } else if (t.kind==="flood") {
        console.log(`FLOOD from (${t.x},${t.y})`);
      } else if (t.kind==="ruleA") {
        console.log(`RULE A: N==F → 안전 open ${t.cells.map(c=>`(${c[0]},${c[1]})`).join(", ")}`);
      } else if (t.kind==="ruleB") {
        console.log(`RULE B: N==F+U → 지뢰 확정(참고용) ${t.cells.map(c=>`(${c[0]},${c[1]})`).join(", ")}`);
      } else if (t.kind==="subset") {
        console.log(`SUBSET: Δ=${t.delta} → 안전 ${t.open?.map(c=>`(${c[0]},${c[1]})`).join(", ")||"없음"} / 강제값 ${t.force?.map(c=>`(${c[0]},${c[1]})`).join(", ")||"없음"}`);
      } else if (t.kind==="exist") {
        console.log(`EXISTENCE: 항상 안전 → open (${t.x},${t.y})`);
      } else if (t.kind==="markMine") {
        console.log(`FLAG (${t.x},${t.y}) - ${t.reason}`);
      } else if (t.kind==="done") {
        console.log(`DONE: 총 ${t.opens}칸 open (안전칸 모두 열림)`);
      }
    }
    console.groupEnd();
  }

  // ===== 경량 솔버(노게스) =====
  function solveNoGuessFast(firstX, firstY) {
    // 컴포 캐시(요약 결과 저장)
    const compCache = new Map();

    rebuildParts();                         // near 갱신
    if ((this.near_mines[firstX][firstY]|0) !== 0) return false; // 첫칸은 반드시 진짜 0

    // 열린(안전) 상태 및 확정 지뢰 상태
    const opened = new Uint8Array(W*H);     // 0/1
    const confirmedMine = new Int8Array(W*H); // classic: 0/1
    let openedCount = 0, totalSafe = 0;
    for (let y=0;y<H;y++) for (let x=0;x<W;x++) if ((this.mines[x][y]|0)===0) totalSafe++;

    function openCell(x,y, reason) {
      const k=idx(x,y);
      if (opened[k]) return;
      opened[k]=1; openedCount++;
      pushTrace("open", {x,y,reason});
    }
    function markMine(x,y,reason){
      const k = idx(x,y);
      if (confirmedMine[k]) return false; // 이미 확정
      confirmedMine[k] = 1;
      pushTrace("markMine", {x,y,reason});
      return true;
    }
    function floodFrom(x0,y0) {
      // 진짜 0만 퍼짐(상쇄0(1000)은 퍼지지 않음)
      const stack=[[x0,y0]];
      pushTrace("flood",{x:x0,y:y0});
      while(stack.length){
        const [x,y]=stack.pop();
        const adj=this.near_positions(x,y);
        for (let i=0;i<adj.length;i++){
          const ax=adj[i][0], ay=adj[i][1];
          const ak=idx(ax,ay);
          if (opened[ak]) continue;
          openCell(ax,ay,"flood-neighbor");
          if ((this.near_mines[ax][ay]|0)===0) stack.push([ax,ay]);
        }
      }
    }
    openCell(firstX, firstY, "seed");
    floodFrom.call(this, firstX, firstY);

    function done(){ return openedCount === totalSafe; }

    // 경계 수집(확정 지뢰를 target에서 차감)
    const collectFrontier = () => {
      const nums = [];
      for (let y=0;y<H;y++) for (let x=0;x<W;x++){
        if (!opened[idx(x,y)]) continue;
        const v = this.near_mines[x][y]|0;
        if (v!==0) nums.push([x,y,v]);
      }
      const varIdx = new Map();
      const vars=[];
      function addVar(x,y){
        const key = x+","+y;
        if (!varIdx.has(key)) { varIdx.set(key, vars.length); vars.push([x,y]); }
      }
      const cons=[];
      for (let i=0;i<nums.length;i++){
        const [x,y,v0]=nums[i];
        const adj=this.near_positions(x,y);
        const vs=[];
        let target = (v0===1000?0:(v0|0));  // 합
        for (let j=0;j<adj.length;j++){
          const ax=adj[j][0], ay=adj[j][1];
          const k=idx(ax,ay);
          if (opened[k]) continue;
          if (confirmedMine[k]) { target -= 1; continue; } // classic: 1개 차감
          addVar(ax,ay);
          vs.push(varIdx.get(ax+","+ay));
        }
        cons.push({vars:vs, target, isAbs:(v0===1000)});
      }
      return { vars, cons };
    };

    // RULE A/B
    const applyRuleAB = (vars, cons) => {
      let progressed=false, flagged=false;
      for (let ci=0; ci<cons.length; ci++){
        const {vars:vs, target, isAbs} = cons[ci];
        const U = vs.length, N = target|0;
        // RULE A: N==0 & !isAbs → 모두 안전 오픈
        if (N===0 && !isAbs && U>0){
          const cells=[];
          for (let k=0;k<vs.length;k++){
            const [x,y]=vars[vs[k]];
            if (!opened[idx(x,y)]){ openCell(x,y,"RuleA N==0"); cells.push([x,y]); }
          }
          if (cells.length){ pushTrace("ruleA",{cells}); progressed=true; }
        }
        // RULE B: N==U → 전부 지뢰 확정 (클래식 모드에서만 안전하게 사용)
        if (classicMode && U>0 && N===U){
          const cells=[];
          for (let k=0;k<vs.length;k++){
            const [x,y]=vars[vs[k]];
            if (markMine(x,y,"RuleB N==U")) { cells.push([x,y]); flagged=true; }
          }
          if (cells.length) pushTrace("ruleB",{cells});
        }
      }
      if (flagged) progressed = true;

      if (progressed){
        // flood 전개
        for (let y=0;y<H;y++) for (let x=0;x<W;x++){
          if (opened[idx(x,y)] && (this.near_mines[x][y]|0)===0){
            const adj=this.near_positions(x,y);
            for (let i=0;i<adj.length;i++){
              const ax=adj[i][0], ay=adj[i][1];
              if (!opened[idx(ax,ay)]) { floodFrom.call(this, x,y); break; }
            }
          }
        }
      }
      return progressed;
    };

    // subset(아주 제한)
    const applySmallSubset = (vars, cons) => {
      const small = cons.map((c)=>({ s:new Set(c.vars), t:c.target|0, a:c.isAbs }))
                        .filter(o=>o.s.size>0 && o.s.size<=5);
      if (small.length<2) return false;

      let progressed=false, flagged=false;
      for (let i=0;i<small.length;i++){
        const A=small[i]; if (A.a) continue;
        for (let j=0;j<small.length;j++){
          if (i===j) continue;
          const B=small[j]; if (B.a) continue;

          // A ⊆ B ?
          let subset=true; A.s.forEach(v=>{ if (!B.s.has(v)) subset=false; });
          if (!subset) continue;

          const S=[]; B.s.forEach(v=>{ if (!A.s.has(v)) S.push(v); });
          if (!S.length) continue;

          const delta = B.t - A.t;
          const len = S.length;

          if (delta===0){
            if (!hasWhites){
              const openedNow=[];
              for (const id of S){
                const [x,y]=vars[id];
                if (!opened[idx(x,y)]){ openCell(x,y,"subset Δ=0"); openedNow.push([x,y]); }
              }
              if (openedNow.length){ pushTrace("subset",{delta:0, open:openedNow}); progressed=true; }
            } else {
              pushTrace("subset",{delta:0, note:"whites-present → no-open"});
            }
          } else if (classicMode){
            if (delta===len){ // 모두 지뢰
              const forced=[];
              for (const id of S){
                const [x,y]=vars[id];
                if (markMine(x,y,"subset Δ=|S|")) { forced.push([x,y]); flagged=true; }
              }
              if (forced.length) pushTrace("subset",{delta, force:forced});
            } else if (delta===-len){ // 모두 안전
              const openedNow=[];
              for (const id of S){
                const [x,y]=vars[id];
                if (!opened[idx(x,y)]){ openCell(x,y,"subset Δ=-|S|"); openedNow.push([x,y]); }
              }
              if (openedNow.length){ pushTrace("subset",{delta, open:openedNow}); progressed=true; }
            }
          } else {
            // 일반 모드: 로그만
            pushTrace("subset",{delta, force:S.map(id=>vars[id])});
          }
        }
      }

      if (flagged) progressed = true;
      if (progressed){
        for (let y=0;y<H;y++) for (let x=0;x<W;x++){
          if (opened[idx(x,y)] && (this.near_mines[x][y]|0)===0){
            const adj=this.near_positions(x,y);
            for (let i=0;i<adj.length;i++){
              const ax=adj[i][0], ay=adj[i][1];
              if (!opened[idx(ax,ay)]) { floodFrom.call(this, x,y); break; }
            }
          }
        }
      }
      return progressed;
    };

    // 연결요소로 쪼개기(변수-제약 이분그래프)
    const splitComponents = (vars, cons) => {
      const nV=vars.length, nC=cons.length;
      const adj = Array.from({length:nV+nC}, ()=>[]);
      for (let ci=0; ci<nC; ci++){
        const vs=cons[ci].vars;
        for (let k=0;k<vs.length;k++){
          const v=vs[k];
          adj[v].push(nV+ci);
          adj[nV+ci].push(v);
        }
      }
      const comp = new Int32Array(nV+nC).fill(-1);
      const comps=[];
      let id=0;
      for (let s=0; s<comp.length; s++){
        if (comp[s]!==-1) continue;
        const q=[s]; comp[s]=id; const nodes=[s];
        while(q.length){
          const u=q.pop();
          const au=adj[u];
          for (let i=0;i<au.length;i++){
            const w=au[i];
            if (comp[w]!==-1) continue;
            comp[w]=id; q.push(w); nodes.push(w);
          }
        }
        const vIdx=[], cIdx=[];
        for (const u of nodes){
          if (u<nV) vIdx.push(u);
          else cIdx.push(u-nV);
        }
        comps.push({vIdx,cIdx});
        id++;
      }
      return comps;
    };

    // 컴포넌트 키
    function makeComponentKey(subVars, subCons){
      const order = [...subVars.keys()].sort((a,b)=>{
        const [ax,ay]=subVars[a], [bx,by]=subVars[b];
        return (ay-by) || (ax-bx);
      });
      const map = new Map(order.map((old,i)=>[old,i]));
      const varsN = order.map(i=>subVars[i]); // 정렬된 좌표 목록

      const consN = subCons.map(c=>{
        const vs = c.vars.map(v=>map.get(v)).sort((a,b)=>a-b);
        return { vars:vs, target:c.target|0, isAbs:!!c.isAbs };
      }).sort((a,b)=>{
        if (a.vars.length!==b.vars.length) return a.vars.length - b.vars.length;
        if (a.target!==b.target) return a.target - b.target;
        if (a.isAbs!==b.isAbs) return (a.isAbs?1:0)-(b.isAbs?1:0);
        for (let i=0;i<a.vars.length;i++) if (a.vars[i]!==b.vars[i]) return a.vars[i]-b.vars[i];
        return 0;
      });

      return JSON.stringify({v:varsN, c:consN});
    }

    // 조기 불능 체크
    function quickInfeasible(subVars, subCons){
      for (const c of subCons){
        const U = c.vars.length;
        const minS = -capW * U, maxS = capB * U;
        if (c.target < minS || c.target > maxS) return true;
        if (c.isAbs && c.target===0 && U===0) return true;
      }
      const fixed = new Map();
      for (const c of subCons){
        if (c.vars.length===1){
          const v = c.vars[0];
          const t = c.target|0;
          if (t< -capW || t> capB) return true;
          const prev = fixed.get(v);
          if (prev!=null && prev!==t) return true;
          fixed.set(v, t);
          if (c.isAbs && t===0) return true;
        }
      }
      return false;
    }

    // 존재성 요약(컴포의 모든 변수에 대해 -1/0/+1)
    function summarizeComponentByExistence(subVars, subCons){
      // 도메인
      const domains = new Array(subVars.length);
      for (let i=0;i<subVars.length;i++){
        const d=[0];
        for (let a=1;a<=capB;a++) d.push(a);
        for (let b=1;b<=capW;b++) d.push(-b);
        domains[i]=d;
      }
      // 가지치기
      function feasible(partial) {
        for (let ci=0; ci<subCons.length; ci++){
          const {vars:vs, target} = subCons[ci];
          let sum=0, unk=0;
          for (let k=0;k<vs.length;k++){
            const id=vs[k], v=partial[id];
            if (v==null) unk++;
            else sum+=v;
          }
          const minPossible = sum - capW*unk;
          const maxPossible = sum + capB*unk;
          if (target<minPossible || target>maxPossible) return false;
        }
        return true;
      }
      function checkAllSatisfied(partial) {
        for (let ci=0; ci<subCons.length; ci++){
          const {vars:vs, target, isAbs} = subCons[ci];
          let s=0, abs=0;
          for (let k=0;k<vs.length;k++){
            const id=vs[k], v=partial[id];
            if (v==null) return false;
            s+=v; abs+=Math.abs(v);
          }
          if (s!==target) return false;
          if (isAbs && !(abs>0)) return false;
        }
        return true;
      }
      // 탐색 순서
      const conDeg = new Array(subVars.length).fill(0);
      for (let ci=0; ci<subCons.length; ci++){
        const vs=subCons[ci].vars;
        for (let k=0;k<vs.length;k++) conDeg[vs[k]]++;
      }
      const ORDER_ALL = [...Array(subVars.length).keys()].sort((a,b)=>conDeg[b]-conDeg[a]);

      const partial = new Array(subVars.length).fill(null);
      const primaryCap   = 120000;
      const secondaryCap = 600000;
      function ExistsResult(ok, timedOut){ return { ok, timedOut }; }

      function existsWithCap(assignZero, targetId, CAP1, CAP2){
        function run(NCAP){
          let nodeVisits=0, found=false, timedOut=false;
          const order=[targetId].concat(ORDER_ALL.filter(v=>v!==targetId));
          function dfs(p){
            if (found || timedOut) return;
            if (++nodeVisits > NCAP) { timedOut=true; return; }
            if (p===order.length){
              if (checkAllSatisfied(partial)) found=true;
              return;
            }
            const vid=order[p], dom=domains[vid];

            if (vid===targetId){
              if (assignZero){
                partial[vid]=0;
                if (feasible(partial)) dfs(p+1);
                partial[vid]=null;
              } else {
                for (let i=1;i<dom.length;i++){
                  partial[vid]=dom[i];
                  if (feasible(partial)) dfs(p+1);
                  if (found||timedOut){ partial[vid]=null; return; }
                  partial[vid]=null;
                }
              }
              return;
            }

            partial[vid]=0; if (feasible(partial)) dfs(p+1);
            if (found||timedOut){ partial[vid]=null; return; }
            partial[vid]=null;

            for (let i=1;i<dom.length;i++){
              partial[vid]=dom[i];
              if (feasible(partial)) dfs(p+1);
              if (found||timedOut){ partial[vid]=null; return; }
              partial[vid]=null;
            }
          }
          dfs(0);
          return timedOut ? ExistsResult(false,true) : ExistsResult(found,false);
        }
        let r=run(CAP1);
        if (r.timedOut) r=run(CAP2);
        return r;
      }

      const verdict = new Int8Array(subVars.length); // -1(always0), 0(unknown), +1(always1; classic only)
      // 항상 0 체크
      for (let v=0; v<subVars.length; v++){
        const r = existsWithCap(false, v, primaryCap, secondaryCap);
        if (!r.timedOut && !r.ok) verdict[v] = -1;
      }
      // 클래식: 항상 1 체크
      if (classicMode){
        for (let v=0; v<subVars.length; v++){
          if (verdict[v]!==0) continue;
          const r = existsWithCap(true, v, primaryCap, secondaryCap);
        if (!r.timedOut && !r.ok) verdict[v] = +1;
        }
      }
      return verdict;
    }

    // 메인 루프
    let guard = W*H*8;
    while(!done() && guard-- > 0){
      const {vars, cons} = collectFrontier.call(this);
      if (!vars.length || !cons.length) return false;

      if (applyRuleAB.call(this, vars, cons)) continue;
      if (applySmallSubset.call(this, vars, cons)) continue;

      // 연결요소 단위 존재성 탐색
      const comps = splitComponents(vars, cons);
      let progressed = false;

      for (let i=0;i<comps.length && !progressed;i++){
        const {vIdx, cIdx} = comps[i];
        if (!vIdx.length) continue;

        const subVars = vIdx.map(id=>vars[id]);
        const idMap = new Map(vIdx.map((old,i)=>[old,i]));
        const subCons = cIdx.map(ci=>{
          const c = cons[ci];
          const vsNew = c.vars.map(v=>idMap.get(v)).filter(v=>v!=null);
          return {vars:vsNew, target:c.target, isAbs:c.isAbs};
        });

        const capSize = classicMode ? 40 : 22;
        if (subVars.length > capSize) continue;

        const cacheKey = makeComponentKey(subVars, subCons);

        // 캐시 사용
        const cached = compCache.get(cacheKey);
        if (cached && cached.kind==="varSummary"){
          let progressedLocal=false;
          for (let k=0;k<cached.verdict.length;k++){
            const [x,y]=subVars[k];
            const v = cached.verdict[k];
            if (v===-1){
              if (!opened[idx(x,y)]) { openCell(x,y,"cache(always 0)"); progressedLocal=true; }
            } else if (classicMode && v===+1){
              if (markMine(x,y,"cache(always 1)")) progressedLocal=true;
            }
          }
          if (progressedLocal){ progressed=true; continue; }
        }

        if (quickInfeasible(subVars, subCons)) continue;

        // 존재성 요약 계산
        const verdict = summarizeComponentByExistence(subVars, subCons);
        compCache.set(cacheKey, { kind:"varSummary", verdict });

        // 적용
        let progressedLocal=false;
        for (let k=0;k<verdict.length;k++){
          const [x,y] = subVars[k];
          const v = verdict[k];
          if (v===-1){
            if (!opened[idx(x,y)]) { openCell(x,y,"exist(always 0)"); progressedLocal=true; }
          } else if (classicMode && v===+1){
            if (markMine(x,y,"exist(always 1)")) progressedLocal=true;
          }
        }

        if (progressedLocal){
          // 방금 연 0칸에서 flood
          for (let k=0;k<verdict.length;k++){
            if (verdict[k]!==-1) continue;
            const [x,y]=subVars[k];
            if ((this.near_mines[x][y]|0)===0) floodFrom.call(this, x,y);
          }
          progressed = true;
        }
      }

      if (!progressed) return false; // 이번 스텝에 '열기'도 '지뢰확정'도 없으면 포기
    }

    if (done()){
      pushTrace("done",{opens:openedCount});
      return true;
    }
    return false;
  }

  // ====== 메인: 무한히 시도하여 solvable 보드가 나올 때까지 ======
  for (let attempt=1; ; attempt++) {
    // 무작위 보드 생성
    this.init_mines();

    // 첫 3x3 비우기 + 첫칸 진짜0 보장
    if (!first3x3AllZero(firstX, firstY)) continue;
    rebuildParts();
    if ((this.near_mines[firstX][firstY]|0) !== 0) continue;

    // 추론 로그 초기화
    Trace.length = 0;

    // 빠른 결정 솔버
    if (solveNoGuessFast.call(this, firstX, firstY)) {
      // 상태 보정
      this.remaining = W*H;
      for (let y=0;y<H;y++) for (let x=0;x<W;x++) if ((this.mines[x][y]|0)!==0) this.remaining--;
      this.total_safe = this.remaining;
      this.game_status = 1;

      // 추론 근거 트리 출력
      try { dumpTraceToConsole(); } catch (e) {}

      return 1; // 성공
    }
    // 실패 시 다음 보드 계속 시도(무한)
  }
};



Minefield.prototype.generate_near_mines = function (mines) {
  var near_sum = this.new_table();
  var near_abs = this.new_table();

  for (var x = 0; x < this.columns; x++) {
    for (var y = 0; y < this.rows; y++) {
      var v = mines[x][y];
      if (v === 0) continue;
      var adj = this.near_positions(x, y);
      for (var k = 0; k < adj.length; k++) {
        var nx = adj[k][0], ny = adj[k][1];
        near_sum[nx][ny] += v;
        near_abs[nx][ny] += Math.abs(v);
      }
    }
  }

  var near_mines = this.new_table();
  const hasWhite = (this.num_mines_white|0) > 0;   // ← 가드 추가
  for (var i = 0; i < this.columns; i++) {
    for (var j = 0; j < this.rows; j++) {
      if (hasWhite && near_sum[i][j] === 0 && near_abs[i][j] > 0) { // ← 가드
        near_mines[i][j] = 1000;
      } else {
        near_mines[i][j] = near_sum[i][j];
      }
    }
  }
  return near_mines;
};

    Minefield.prototype.shift_table = function (table, dx, dy) {
      var new_table, new_x, new_y, nx, ny, _i, _j, _ref, _ref1;
      new_table = this.new_table();
      for (ny = _i = 0, _ref = this.rows - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; ny = 0 <= _ref ? ++_i : --_i) {
        for (nx = _j = 0, _ref1 = this.columns - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; nx = 0 <= _ref1 ? ++_j : --_j) {
          new_x = (nx + dx + 2 * this.columns) % this.columns;
          new_y = (ny + dy + 2 * this.rows) % this.rows;
          new_table[new_x][new_y] = table[nx][ny];
        }
      }
      return new_table;
    };

    /* ---------- DOM 헬퍼 ---------- */
    Minefield.prototype.get_class = function (x, y) {
      var td_class = this.tds[x][y].getAttribute("class");
      if (td_class === null || td_class === "") { return null; }
      return td_class;
    };

    Minefield.prototype.set_class = function (x, y, val) {
      if (val === null) {
        return this.tds[x][y].removeAttribute("class");
      } else {
        return this.tds[x][y].setAttribute("class", val);
      }
    };

    Minefield.prototype.near_positions = function (x, y) {
      var nx, ny, ret, _i, _j, _ref, _ref1, _ref2, _ref3;
      ret = [];
      for (nx = _i = _ref = x - 1, _ref1 = x + 1; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; nx = _ref <= _ref1 ? ++_i : --_i) {
        for (ny = _j = _ref2 = y - 1, _ref3 = y + 1; _ref2 <= _ref3 ? _j <= _ref3 : _j >= _ref3; ny = _ref2 <= _ref3 ? ++_j : --_j) {
          if (nx === x && ny === y) continue;
          if (nx >= this.columns || nx < 0 || ny >= this.rows || ny < 0) continue;
          ret.push([nx, ny]);
        }
      }
      return ret;
    };

    /* ---------- 입력 ---------- */
    Minefield.prototype.on_click = function (x, y) {
      var old_game_status = this.game_status;
      if (this.game_status < 0) return;

      // 깃발이면 좌클릭 사이클(검/흰 지원), 보드 열지 않음
      var td_class = this.get_class(x, y);
      if (td_class !== null && td_class !== "flag-0" && /^flag-/.test(td_class)) {
        this.cycle_flag_leftclick(x, y);
        if (this.on_rclick_func) this.on_rclick_func(x, y);
        return;
      }

      if (this.game_status === 1) this.start(x, y);

      if (this.expand(x, y) < 0) this.gameover(x, y);

      if (this.remaining === 0) this.gameclear();

      if (this.on_click_func) this.on_click_func(x, y);
      if (old_game_status !== this.game_status) return this.on_game_status_changed();
    };

    Minefield.prototype.on_rclick = function (x, y) {
      var old_game_status = this.game_status;
      if (this.game_status < 0) return;
      if (this.game_status === 1) this.game_status = 0;
      this.flag(x, y);
      if (this.on_rclick_func) this.on_rclick_func(x, y);
      if (old_game_status !== this.game_status) return this.on_game_status_changed();
    };

    // 좌클릭일 때: 깃발 상태에서 검은→…→검은Max→(흰 있으면)흰1→…→흰Max→검은1
    Minefield.prototype.cycle_flag_leftclick = function (x, y) {
      var cur = this.flags[x][y] || 0;
      if (cur === 0) return;

      var wMax = this.max_mines_white|0;
      var bMax = this.max_mines|0;

      var next, deltaSigned = 0;

      if (cur > 0) { // 검은 깃발 증가
        next = cur + 1;
        if (next > bMax) {
          if (wMax > 0) { next = -1; } else { next = 1; }
        }
        deltaSigned = next - cur;
      } else { // 흰 깃발 증가
        var abs = -cur;
        var absNext = abs + 1;
        if (absNext > wMax) {
          next = 1; // 검은1로
        } else {
          next = -absNext;
        }
        deltaSigned = next - cur;
      }

      // 카운터 갱신
      if (cur > 0) this.num_flags -= cur; else if (cur < 0) this.num_flags_white -= (-cur);
      if (next > 0) this.num_flags += next; else if (next < 0) this.num_flags_white += (-next);

      // near_flags(부호합)
      var adj = this.near_positions(x, y);
      for (var i = 0; i < adj.length; i++) {
        var nx = adj[i][0], ny = adj[i][1];
        this.near_flags[nx][ny] += deltaSigned;
      }

      this.flags[x][y] = next;
      if (next > 0) this.set_class(x, y, "flag-" + next);
      else this.set_class(x, y, "flag-m" + (-next));
    };

    Minefield.prototype.on_game_status_changed = function () {
      if (this.game_status_changed_func) return this.game_status_changed_func(this.game_status);
    };
    Minefield.prototype.on_game_status_changed2 = function () {
      if (this.game_status_changed_func2) return this.game_status_changed_func2(this.game_status2);
    };

    Minefield.prototype.start = function (x, y) {
      this.game_status = 0;
      if(this.use_nopick === true) { this.init_mines_nopick(x,y); this.game_status = 0; }
      if (this.mines[x][y] === 0) return;

      // 가벼운 재배치 시도(같은 색)
      if (this._relocateFirstClick(x, y)) return;

      // 실패 시 기존 시프트 폴백(시프트 후 parts/near 전부 재구성)
      var nx, ny, _i, _ref, _results;
      _results = [];
      for (nx = _i = 0, _ref = this.columns - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; nx = 0 <= _ref ? ++_i : --_i) {
        _results.push((function () {
          var _j, _ref1, _results1;
          _results1 = [];
          for (ny = _j = 0, _ref1 = this.rows - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; ny = 0 <= _ref1 ? ++_j : --_j) {
            if (this.mines[nx][ny] === 0) {
              this.mines = this.shift_table(this.mines, x - nx, y - ny);

              // ★ 시프트 후 parts와 near를 전부 재구성
              this._near_black = this.new_table();
              this._near_white = this.new_table();
              for (var xx = 0; xx < this.columns; xx++) {
                for (var yy = 0; yy < this.rows; yy++) {
                  var v = this.mines[xx][yy];
                  if (v === 0) continue;
                  var adj = this.near_positions(xx, yy);
                  var addB = Math.max(0, v);
                  var addW = Math.max(0, -v);
                  for (var k = 0; k < adj.length; k++) {
                    var nx2 = adj[k][0], ny2 = adj[k][1];
                    this._near_black[nx2][ny2] += addB;
                    this._near_white[nx2][ny2] += addW;
                  }
                }
              }
              this._rebuild_near_from_parts();

              _results1.push(true);
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    // 우클릭 사이클
    //  흰=0: null→flag-1..bMax→flag-0(?)→null
    //  흰>0: null→flag-1..bMax→flag-m1..mW→flag-0(?)→null
    Minefield.prototype.flag = function (x, y) {
      var td_class = this.get_class(x, y);
      if (td_class !== null && !/^flag/.exec(td_class)) return;

      var wMax = this.max_mines_white|0;
      var bMax = this.max_mines|0;
      var cur = this.flags[x][y] || 0;

      function applyClass(self, xx, yy, val) {
        if (val === 0) self.set_class(xx, yy, "flag-0"); // ?
        else if (val > 0) self.set_class(xx, yy, "flag-" + val);
        else self.set_class(xx, yy, "flag-m" + (-val));
      }

      var next, deltaSigned = 0;
      if (td_class === null) { // null → black1
        next = 1;
        deltaSigned = +1;
        this.num_flags += 1;
      } else if (td_class === "flag-0") { // ? → null
        this.set_class(x, y, null);
        this.flags[x][y] = 0;
        return;
      } else {
        // 현재 깃발에서 다음 단계
        if (cur > 0) {
          if (cur < bMax) { next = cur + 1; }
          else { // cur==bMax
            if (wMax > 0) { next = -1; } else { next = 0; } // 흰 없으면 ? 로
          }
        } else if (cur < 0) {
          var abs = -cur;
          if (abs < wMax) next = -(abs + 1);
          else next = 0; // ? 로
        } else {
          next = 1;
        }

        // 카운터 갱신/near_flags 델타
        if (cur > 0) this.num_flags -= cur;
        if (cur < 0) this.num_flags_white -= (-cur);

        if (next > 0) this.num_flags += next;
        if (next < 0) this.num_flags_white += (-next);

        deltaSigned = next - cur;
      }

      // near_flags 반영( ? 는 합산 제외 → deltaSigned=0)
      var adj = this.near_positions(x, y);
      for (var i = 0; i < adj.length; i++) {
        var nx = adj[i][0], ny = adj[i][1];
        this.near_flags[nx][ny] += deltaSigned;
      }

      this.flags[x][y] = next;
      applyClass(this, x, y, next);
    };

    // 지뢰는 (양수/음수) 모두 게임오버 트리거
    Minefield.prototype.press = function (x, y) {
      if (this.mines[x][y] !== 0) {
        return -1;
      } else if (this.get_class(x, y) !== null && this.get_class(x, y) !== "flag-0") {
        return 1;
      }

      this.remaining -= 1;

      this.opened_cells = (this.opened_cells || 0) + 1;
      this.opened_safe = (this.opened_safe || 0) + 1;

      var ratio = this.opened_safe / this.total_safe;
      if (!this.bonus_thresholds) this.bonus_thresholds = this.compute_bonus_thresholds();
      while ((this.bonus_reloc_count || 0) < this.bonus_thresholds.length &&
             ratio >= this.bonus_thresholds[this.bonus_reloc_count]) {
        this.bonus_reloc_count += 1;
      }

      // 숫자 표시: 1000 → 숫자0, 0 → 빈칸, 양수 → near-#, 음수 → near-m#
      var v = this.near_mines[x][y];
      if (v === 0) {
        this.set_class(x, y, "empty");
      } else if (v === 1000) {
        this.set_class(x, y, "near-0");
      } else if (v > 0) {
        this.set_class(x, y, "near-" + v);
      } else {
        this.set_class(x, y, "near-m" + (-v));
      }
      return 0;
    };

    /* ---------- 고속 확장(BFS) ---------- */
    Minefield.prototype.expand = function (start_x, start_y) {
      if (!this._visit || this._visit.length !== this.columns * this.rows) {
        this._ensureWorkBuffers();
      }

      var td_class = this.get_class(start_x, start_y);
      if (td_class !== null && (td_class !== "flag-0" && /^flag/.exec(td_class))) {
        return 1;
      }

      // 첫 클릭 보호(검/흰 모두)
      if (this.opened_cells === 0 && this.mines[start_x][start_y] !== 0) {
        if (!this._relocateFirstClick(start_x, start_y)) {
          this.start(start_x, start_y);
        }
      }

      var pr = this.press(start_x, start_y);
      if (pr < 0) {
        var allowed = this.get_reloc_allowed();
        if ((this.reloc_used || 0) < allowed) {
          if (this.try_relocate_from(start_x, start_y)) {
            this.reloc_used = (this.reloc_used || 0) + 1;
            pr = this.press(start_x, start_y);
            if (pr < 0) return -1;
          } else {
            return -1;
          }
        } else {
          return -1;
        }
      }

      // ★ 시작 칸이 "진짜 0"일 때만 확장 허용 (상쇄0=1000은 확장 금지)
      var v0 = this.near_mines[start_x][start_y];
      if (v0 !== 0) {
        return 0; // 숫자칸(양/음수/상쇄0)은 확장하지 않음
      }

      const W = this.columns, H = this.rows;
      const visit = this._visit;
      const qx = this._queueX;
      const qy = this._queueY;

      const gen = (this._visitGen = (this._visitGen | 0) + 1) || (this._visitGen = 1);

      function idx(x, y) { return y * W + x; }
      function markVisited(x, y) { visit[idx(x, y)] = gen; }
      function isVisited(x, y) { return visit[idx(x, y)] === gen; }

      let head = 0, tail = 0;
      qx[tail] = start_x; qy[tail] = start_y; tail++;
      markVisited(start_x, start_y);

      // 시작칸 자동 오픈 규칙 (XP 유사): 0일 때만 인접한 칸들 검사 시작
      var neighbors = this.near_positions(start_x, start_y);
      for (var i = 0; i < neighbors.length; i++) {
        var nx = neighbors[i][0], ny = neighbors[i][1];
        var c = this.get_class(nx, ny);
        if (c === null || c === "flag-0") {
          if (this.press(nx, ny) < 0) return -1;
          if (!isVisited(nx, ny)) {
            qx[tail] = nx; qy[tail] = ny; tail++;
            markVisited(nx, ny);
          }
        }
      }

      // BFS 확장: "진짜 0"만 계속 퍼짐 (상쇄0은 퍼지지 않음)
      while (head < tail) {
        var x = qx[head], y = qy[head]; head++;

        var v = this.near_mines[x][y];
        if (v === 0) { // 오직 0만 확장
          var adj = this.near_positions(x, y);
          for (var j = 0; j < adj.length; j++) {
            var ax = adj[j][0], ay = adj[j][1];
            var cls = this.get_class(ax, ay);
            if (cls === null || cls === "flag-0") {
              if (this.press(ax, ay) < 0) return -1;

              if (!isVisited(ax, ay)) {
                qx[tail] = ax; qy[tail] = ay; tail++;
                markVisited(ax, ay);
              }
            }
          }
        }
      }
      return 0;
    };

    /* ---------- 게임 종료 ---------- */
    Minefield.prototype.gameover = function(fail_x, fail_y) {
      var tmp = (document.getElementsByClassName("minetable")[0]).getElementsByTagName("td");
      for (var i = 0; i < tmp.length; i++) {
        var td = tmp[i];
        td.onclick = td.onmouseup = td.onmousedown = td.oncontextmenu = null;
      }
      this.game_status = -1;
  if (typeof this.on_game_status_changed === "function") {
    this.on_game_status_changed();
  }
      const self = this;

      function cellClassAtXY(x, y) {
        const mine = self.mines[x][y];
        const flagSigned = self.flags[x][y];
        const cur = self.get_class(x, y);

        if (mine !== 0) {
          // 올바른 깃발이면 그대로 두는 기존 정책 유지
          if (cur !== "flag-0" && /^flag/.test(cur)) return cur;

          if (x === fail_x && y === fail_y) {
            if (mine > 0) return "mine-exploded" + mine;
            else return "mine-exploded-m" + (-mine);
          }
          if (mine > 0) return "mine-" + mine;
          else return "mine-m" + (-mine);
        } else {
          if (flagSigned !== 0) {
            if (flagSigned > 0) return "mine-wrong" + flagSigned;
            else return "mine-wrong-m" + (-flagSigned);
          }
          var v = self.near_mines[x][y];
          if (v === 0) return "empty";
          if (v === 1000) return "near-0";
          if (v > 0) return "near-" + v;
          return "near-m" + (-v);
        }
      }

      const order = this._buildRowOrder(fail_y, 50);
      this._renderRowsIncrementally(order, cellClassAtXY, function() {});
      return true;
    };

    Minefield.prototype.gameclear = function () {
      var tmp = (document.getElementsByClassName("minetable")[0]).getElementsByTagName("td");
      for (var i = 0; i < tmp.length; i++) {
        var td = tmp[i];
        td.onclick = td.onmouseup = td.onmousedown = td.oncontextmenu = null;
      }

      this.num_flags = 0;
      this.num_flags_white = 0;
      this.near_flags = this.new_table();

      for (var y = 0; y < this.rows; y++) {
        for (var x = 0; x < this.columns; x++) {
          var mine = this.mines[x][y];
          if (mine !== 0) {
            if (mine > 0) {
              this.flags[x][y] = mine;
              this.num_flags += mine;
              var adj = this.near_positions(x, y);
              for (var i2 = 0; i2 < adj.length; i2++) {
                var nx = adj[i2][0], ny = adj[i2][1];
                this.near_flags[nx][ny] += mine;
              }
            } else {
              var w = -mine;
              this.flags[x][y] = -w;
              this.num_flags_white += w;
              var adjw = this.near_positions(x, y);
              for (var j2 = 0; j2 < adjw.length; j2++) {
                var wx = adjw[j2][0], wy = adjw[j2][1];
                this.near_flags[wx][wy] -= w; // 부호 유의
              }
            }
          } else {
            this.flags[x][y] = 0;
          }
        }
      }

      const self = this;
      function cellClassAtXY(x, y) {
        const mine = self.mines[x][y];
        if (mine !== 0) {
          if (mine > 0) return "flag-" + mine;
          return "flag-m" + (-mine);
        }
        var v = self.near_mines[x][y];
        if (v === 0) return "empty";
        if (v === 1000) return "near-0";
        if (v > 0) return "near-" + v;
        return "near-m" + (-v);
      }

  const order = Array.from({ length: this.rows }, (_, y) => y);
  this._renderRowsIncrementally(order, cellClassAtXY, () => {
    const self = this;
    self.game_status = -2;
    // ★ 추가: 상태 변경 알림을 즉시 호출해 타이머를 멈춘다
    if (typeof self.on_game_status_changed === "function") {
      self.on_game_status_changed();
    }
  });

  return this.game_status;
    };

    /* ---------- 마우스 프레스 표시 ---------- */
    Minefield.prototype.on_down = function () {
      this.game_status2 = 1;
      this.on_game_status_changed2();
      return 1;
    };
    Minefield.prototype.on_up = function () {
      this.game_status2 = 0;
      this.on_game_status_changed2();
      return 0;
    };

    /* ---------- 디버그 ---------- */
    Minefield.prototype.stringify = function () {
      return JSON.stringify(this.mines);
    };

    return Minefield;
  })();

  window.Minefield = Minefield;
}).call(this);
