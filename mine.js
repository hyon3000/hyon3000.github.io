// Generated by CoffeeScript 1.6.2 (rewritten + optimized)
// Drop-in replacement for mine.js  (black mines >0, white mines <0 supported)

(function () {
  var Minefield;

  Minefield = (function () {
    function Minefield(window, game_status_changed_func, game_status_changed_func2) {
      this.window = window;
      this.game_status_changed_func = game_status_changed_func != null ? game_status_changed_func : null;
      this.game_status_changed_func2 = game_status_changed_func2 != null ? game_status_changed_func2 : null;
      this.game_status = -1;
      this.game_status2 = 0;
      this.table = null;
      this.on_click_func = null;
      this.on_rclick_func = null;

      // ★ 하얀지뢰(음수) 지원: 기본 0으로(하위호환)
      this.num_mines_white = 0;
      this.max_mines_white = 0;

      // ★ 흰/검 깃발 카운터(별도)
      this.num_flags_white = 0;
    }

    /* ---------- 분석/이론값 ---------- */
    Minefield.prototype.theoretical_max_zero_cells = function () {
      var C = this.columns, R = this.rows;
      var total = C * R;
      if (this.num_mines <= 0 && this.num_mines_white <= 0) return total;

      var black = Math.max(0, this.num_mines|0);
      var white = Math.max(0, this.num_mines_white|0);
      var M_black = Math.max(1, this.max_mines || 1);
      var M_white = Math.max(0, this.max_mines_white || 0);

      var M = Math.max(M_black, M_white || 1);
      var needed = Math.ceil((black + white) / (M||1));

      function influenceArea(w, h) {
        var areaW = Math.min(C, w + 1);
        var areaH = Math.min(R, h + 1);
        return areaW * areaH;
      }

      var bestA = Infinity;
      var hMax = Math.min(R, needed);
      for (var h = 1; h <= hMax; h++) {
        var w = Math.ceil(needed / h);
        if (w > C) continue;
        var area = influenceArea(w, h);
        if (area < bestA) bestA = area;
      }

      var bestB = Infinity;
      if (C <= R) {
        var wB = Math.min(C, needed);
        var hB = Math.ceil(needed / wB);
        if (hB <= R) bestB = influenceArea(wB, hB);
      } else {
        var hB2 = Math.min(R, needed);
        var wB2 = Math.ceil(needed / hB2);
        if (wB2 <= C) bestB = influenceArea(wB2, hB2);
      }

      var best = Math.min(bestA, bestB);
      if (!isFinite(best)) {
        best = influenceArea(Math.min(C, needed), Math.ceil(needed / Math.min(C, needed)));
      }

      var zeroMax = total - best;
      return zeroMax < 0 ? 0 : zeroMax;
    };

    Minefield.prototype._rowsPerFrame = function () {
      var cols = this.columns || 1;
      var n = Math.floor(1000 / cols);
      if (n < 1) n = 1;
      return n;
    };

    // 1) 행 우선순위 구성
    Minefield.prototype._buildRowOrder = function(centerY, windowRows) {
      const H = this.rows;
      const inRange = [];
      const rest = [];
      const top = Math.max(0, centerY - windowRows);
      const bottom = Math.min(H - 1, centerY + windowRows);
      for (let y = 0; y < H; y++) {
        if (y >= top && y <= bottom) inRange.push(y);
        else rest.push(y);
      }
      return inRange.concat(rest);
    };

    // 2) 한 행 적용
    Minefield.prototype._applyRow = function(y, cellClassAtXY) {
      for (let x = 0; x < this.columns; x++) {
        const cls = cellClassAtXY(x, y);
        if (cls === null) {
          this.tds[x][y].removeAttribute("class");
        } else {
          if (this.tds[x][y].getAttribute("class") !== cls) {
            this.tds[x][y].setAttribute("class", cls);
          }
        }
      }
    };

    // 3) 점진 렌더
    Minefield.prototype._renderRowsIncrementally = function (rowOrder, cellClassAtXY, done) {
      let idx = 0;
      const step = () => {
        const budget = Math.min(rowOrder.length - idx, this._rowsPerFrame());
        for (let k = 0; k < budget; k++) {
          const y = rowOrder[idx++];
          this._applyRow(y, cellClassAtXY);
        }
        if (idx < rowOrder.length) {
          requestAnimationFrame(step);
        } else if (done) {
          done();
        }
      };
      requestAnimationFrame(step);
    };

    // ★ 인접 near 보정(부호 포함, 내부 파트 유지)
    Minefield.prototype._adjustNearAround = function (x, y, deltaSigned) {
      var adj = this.near_positions(x, y);
      for (var i = 0; i < adj.length; i++) {
        var nx = adj[i][0], ny = adj[i][1];
        this._near_black[nx][ny] += Math.max(0,  deltaSigned); // deltaSigned>0 → 검은
        this._near_white[nx][ny] += Math.max(0, -deltaSigned); // deltaSigned<0 → 흰
      }
      this._rebuild_near_from_parts();
    };

    // ★ parts → near_mines 합성(0 vs 1000(상쇄0) 구분)
Minefield.prototype._rebuild_near_from_parts = function () {
  this.near_mines = this.new_table();
  const hasWhite = (this.num_mines_white|0) > 0;   // ← 가드 추가
  for (var x=0; x<this.columns; x++) {
    for (var y=0; y<this.rows; y++) {
      var b = this._near_black[x][y]|0;
      var w = this._near_white[x][y]|0;
      if (hasWhite && b === w && b > 0) {          // ← 흰지뢰 있을 때만 1000 사용
        this.near_mines[x][y] = 1000;
      } else {
        this.near_mines[x][y] = b - w;
      }
    }
  }
};


    // ★ 첫 클릭 보장(검은/흰 모두, 같은 색만 이동)
    Minefield.prototype._relocateFirstClick = function (x, y) {
      var m = this.mines[x][y];
      if (m === 0) return true; // 안전
      var isWhite = (m < 0);
      var count = Math.abs(m);
      var cap = isWhite ? this.max_mines_white : this.max_mines;

      var W = this.columns, H = this.rows;
      var tx = -1, ty = -1;

      outer:
      for (var yy = 0; yy < H; yy++) {
        for (var xx = 0; xx < W; xx++) {
          if (xx === x && yy === y) continue;
          var v = this.mines[xx][yy];
          if (v !== 0) continue; // 혼합 금지 → 빈칸만
          if (count <= cap) { tx = xx; ty = yy; break outer; }
        }
      }
      if (tx < 0) return false;

      // 소스 주변 -m, 타깃 주변 +m (부호 유지)
      this._adjustNearAround(x, y, -m);
      this._adjustNearAround(tx, ty, +m);

      this.mines[x][y] = 0;
      this.mines[tx][ty] = m;
      return true;
    };

    // 현재 판에서 "주변 지뢰 합 0" & 자기칸 0
    Minefield.prototype.count_zero_no_neighbor = function () {
      var cnt = 0;
      for (var x = 0; x < this.columns; x++) {
        for (var y = 0; y < this.rows; y++) {
          if (this.mines[x][y] === 0 && this.near_mines[x][y] === 0) cnt++;
        }
      }
      return cnt;
    };

    // 흰/검 인접 체크
    Minefield.prototype.has_neighbor_mine = function (x, y) {
      var adj = this.near_positions(x, y);
      for (var i = 0; i < adj.length; i++) {
        var nx = adj[i][0], ny = adj[i][1];
        if (Math.abs(this.mines[nx][ny]) > 0) return true;
      }
      return false;
    };

    /* ---------- 기본 테이블 유틸 ---------- */
    Minefield.prototype.new_table = function () {
      var x, y, _i, _ref, _results;
      _results = [];
      for (x = _i = 1, _ref = this.columns; 1 <= _ref ? _i <= _ref : _i >= _ref; x = 1 <= _ref ? ++_i : --_i) {
        _results.push((function () {
          var _j, _ref1, _results1;
          _results1 = [];
          for (y = _j = 1, _ref1 = this.rows; 1 <= _ref1 ? _j <= _ref1 : _j >= _ref1; y = 1 <= _ref1 ? ++_j : --_j) {
            _results1.push(0);
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    /* ---------- 초기화 ---------- */
    // 흰지뢰 인자 추가(하위호환 OK)
    Minefield.prototype.init_board = function (columns, rows, num_mines, max_mines, num_mines_white, max_mines_white) {
      this.columns = columns;
      this.rows = rows;
      this.num_mines = num_mines|0;
      this.max_mines = (max_mines != null ? max_mines : 1)|0;
      this.num_mines_white = Math.max(0, (num_mines_white|0)||0);
      this.max_mines_white = Math.max(0, (max_mines_white|0)||0);

      this._ensureWorkBuffers();
      return this.reset_board();
    };

    Minefield.prototype._ensureWorkBuffers = function () {
      const size = this.columns * this.rows;
      if (!this._visit || this._visit.length !== size) {
        this._visit = new Uint32Array(size);
        this._visitGen = 1;
        this._queueX = new Int32Array(size);
        this._queueY = new Int32Array(size);
      }
    };

    Minefield.prototype._attachDelegatedEvents = function () {
      if (!this.table) return;
      const tbl  = this.table;
      const self = this;

      if (this._delegated) this._detachDelegatedEvents();

      function getXYFrom(td) {
        const x = td && td.dataset ? parseInt(td.dataset.x, 10) : NaN;
        const y = td && td.dataset ? parseInt(td.dataset.y, 10) : NaN;
        return [x, y];
      }

      const onClick = function (e) {
        if (e.button !== 0) return;
        const td = e.target.closest('td');
        if (!td || !tbl.contains(td)) return;
        const [x, y] = getXYFrom(td);
        if (Number.isNaN(x) || Number.isNaN(y)) return;
        self.on_click(x, y);
        e.preventDefault();
      };

      const onContextMenu = function (e) {
        const td = e.target.closest('td');
        if (!td || !tbl.contains(td)) return;
        const [x, y] = getXYFrom(td);
        if (Number.isNaN(x) || Number.isNaN(y)) return;
        self.on_rclick(x, y);
        e.preventDefault();
      };

      const onMouseDown = function (e) {
        if (e.button === 1) return;
        const td = e.target.closest('td');
        if (!td || !tbl.contains(td)) return;
        const [x, y] = getXYFrom(td);
        if (Number.isNaN(x) || Number.isNaN(y)) return;
        self.on_down(x, y);
      };

      const onMouseUp = function (e) {
        if (e.button === 1) return;
        const td = e.target.closest('td');
        if (!td || !tbl.contains(td)) return;
        const [x, y] = getXYFrom(td);
        if (Number.isNaN(x) || Number.isNaN(y)) return;
        self.on_up(x, y);
      };

      tbl.addEventListener('click', onClick);
      tbl.addEventListener('contextmenu', onContextMenu);
      tbl.addEventListener('mousedown', onMouseDown);
      tbl.addEventListener('mouseup', onMouseUp);

      this._delegated = { onClick, onContextMenu, onMouseDown, onMouseUp };
    };

    Minefield.prototype._detachDelegatedEvents = function () {
      if (!this.table || !this._delegated) return;
      const { onClick, onContextMenu, onMouseDown, onMouseUp } = this._delegated;
      this.table.removeEventListener('click', onClick);
      this.table.removeEventListener('contextmenu', onContextMenu);
      this.table.removeEventListener('mousedown', onMouseDown);
      this.table.removeEventListener('mouseup', onMouseUp);
      this._delegated = null;
    };

    // 점진적 테이블 생성
    Minefield.prototype._buildTableIncrementally = function(done) {
      const batchRows = 40;
      let y = 0;
      const tbl  = this.table;
      const cols = this.columns;
      const rows = this.rows;

      const step = () => {
        const frag = document.createDocumentFragment();
        const yEnd = Math.min(rows, y + batchRows);

        for (; y < yEnd; y++) {
          const tr = document.createElement('tr');
          for (let x = 0; x < cols; x++) {
            const td = document.createElement('td');
            td.setAttribute('id', 'x' + x + 'y' + y);
            td.dataset.x = x;
            td.dataset.y = y;
            this.tds[x][y] = td;
            tr.appendChild(td);
          }
          frag.appendChild(tr);
        }

        tbl.appendChild(frag);

        if (y < rows) {
          requestAnimationFrame(step);
        } else {
          this.window.appendChild(tbl);
          if (typeof done === "function") done();
        }
      };

      requestAnimationFrame(step);
    };

    // reset_board
    Minefield.prototype.reset_board = function() {
      this.opened_cells = 0;
      this.reloc_used   = 0;
      this.opened_safe  = 0;
      this.total_safe   = 0;
      this.bonus_reloc_count = 0;
      this.bonus_thresholds  = this.compute_bonus_thresholds();

      this.num_flags  = 0;
      this.num_flags_white = 0;
      this.flags      = this.new_table();     // 부호 있는 깃발값(>0 검은, <0 흰)
      this.near_flags = this.new_table();     // 합(부호 포함)
      this.tds        = this.new_table();

      // 내부 near parts
      this._near_black = this.new_table();
      this._near_white = this.new_table();

      this._ensureWorkBuffers();

      if (this.table) {
        this.window.removeChild(this.table);
        this.game_status = -1;
        this.table = null;
      }

      this.table = document.createElement('table');
      this.table.setAttribute("class", "minetable");

      this.num_flags  = 0;
      this.num_flags_white = 0;
      this.flags      = this.new_table();
      this.near_flags = this.new_table();
      this.tds        = this.new_table();
      this._near_black = this.new_table();
      this._near_white = this.new_table();

      this._buildTableIncrementally(function() {
        // 후보 여러 판 생성 후 best 선택
        var bestZero = -1;
        var bestMines = null;
        var bestNearB = null, bestNearW = null;
        var bestNear = null;
        var bestRemaining = 0;

        var retryMap = {1:1, 2:2, 3:4, 4:8, 5:12, 6:18};
        var retries = retryMap[this.max_mines] || 1;

        for (var attempt = 0; attempt < retries; attempt++) {
          this.init_mines(); // mines/near_mines/_near_black/_near_white/remaining 갱신
          var curZero = this.count_zero_no_neighbor();
          if (curZero > bestZero) {
            bestZero = curZero;
            bestMines = JSON.parse(JSON.stringify(this.mines));
            bestNearB = JSON.parse(JSON.stringify(this._near_black));
            bestNearW = JSON.parse(JSON.stringify(this._near_white));
            bestNear  = JSON.parse(JSON.stringify(this.near_mines));
            bestRemaining = this.remaining;
          }
        }

        if (bestMines) {
          this.mines       = bestMines;
          this._near_black = bestNearB;
          this._near_white = bestNearW;
          this.near_mines  = bestNear;
          this.remaining   = bestRemaining;
          this.game_status = 1;
        }

        this.on_game_status_changed();
      }.bind(this));

      this._attachDelegatedEvents();
    };

    /* ---------- 상태 체크 ---------- */
    Minefield.prototype.is_opened = function (x, y) {
      var c = this.get_class(x, y);
      if (c === null) return false;
      if (/^flag/.test(c)) return false;
      if (c === "empty") return true;
      if (/^near-/.test(c)) return true;
      return false;
    };

    Minefield.prototype.has_opened_neighbor = function (x, y) {
      var adj = this.near_positions(x, y);
      for (var i = 0; i < adj.length; i++) {
        var nx = adj[i][0], ny = adj[i][1];
        if (this.is_opened(nx, ny)) return true;
      }
      return false;
    };

    /* ---------- 조합/후보 선택(지뢰 재배치) ---------- */
    Minefield.prototype._combinations_pick = function (candidates, m) {
      var res = [];
      function dfs(start, path) {
        if (path.length === m) { res.push(path.slice()); return; }
        for (var i = start; i <= candidates.length - (m - path.length); i++) {
          path.push(candidates[i]);
          dfs(i + 1, path);
          path.pop();
        }
      }
      if (m <= candidates.length && m > 0) dfs(0, []);
      return res;
    };

    // 색상 구분 후보 추출
    Minefield.prototype._pick_reloc_candidates = function (excludeX, excludeY, isWhite) {
      var pref = [], rest = [];
      var cap = isWhite ? this.max_mines_white : this.max_mines;

      for (var cx = 0; cx < this.columns; cx++) {
        for (var cy = 0; cy < this.rows; cy++) {
          if (cx === excludeX && cy === excludeY) continue;

          var cellMine = this.mines[cx][cy];
          // 다른 색과 혼합 금지
          if ((isWhite && cellMine > 0) || (!isWhite && cellMine < 0)) continue;

          // 수용 가능성(한 개 추가 가정)
          var next = cellMine + (isWhite ? -1 : +1);
          if (cellMine !== 0 && Math.sign(cellMine) !== Math.sign(next)) continue; // 부호 뒤틀림 방지
          if (Math.abs(next) > cap) continue;

          var cls = this.get_class(cx, cy);
          var unopened = (cls === null) || /^flag/.test(cls) || (cls === "flag-0");
          if (!unopened) continue;

          var nearOpened = this.has_opened_neighbor(cx, cy);
          if (!nearOpened) pref.push([cx, cy]); else rest.push([cx, cy]);
        }
      }
      function shuffle(a) {
        for (var i = a.length - 1; i > 0; i--) {
          var j = Math.floor(Math.random() * (i + 1));
          var t = a[i]; a[i] = a[j]; a[j] = t;
        }
      }
      shuffle(pref); shuffle(rest);

      var out = [];
      for (var i = 0; i < pref.length && out.length < 10; i++) out.push(pref[i]);
      for (var j = 0; j < rest.length && out.length < 10; j++) out.push(rest[j]);
      return out;
    };

    /* ---------- 구제 규칙 ---------- */
    Minefield.prototype.get_reloc_allowed = function () {
      var mm = Math.max(1, this.max_mines || 1);
      if (mm == 1) mm = 10000;
      else if (mm == 2) mm = 2000;
      else if (mm == 3) mm = 400;
      else if (mm == 4) mm = 300;
      else if (mm == 5) mm = 225;
      else mm = 168;

      var base = Math.floor(this.opened_cells / mm);
      var bonus = this.bonus_reloc_count || 0;
      return base + bonus;
    };

    Minefield.prototype.compute_bonus_thresholds = function () {
      var mm = Math.max(1, this.max_mines || 1);
      if (mm <= 2) return [0.997];
      if (mm <= 4) return [0.99, 0.997];
      if (mm >= 5) return [0.95, 0.99, 0.999];
      return [];
    };

    /* ---------- 지뢰 재배치(구제) ---------- */
    Minefield.prototype.try_relocate_from = function (x, y) {
      var mSigned = this.mines[x][y];
      var m = Math.abs(mSigned);
      if (m <= 0) return false;

      var isWhite = (mSigned < 0);
      var cap = isWhite ? this.max_mines_white : this.max_mines;

      var cand = this._pick_reloc_candidates(x, y, isWhite);
      if (cand.length < m) return false;

      var affected = {};
      var self = this;

      function addNeighbors(px, py) {
        var adj = self.near_positions(px, py);
        for (var i = 0; i < adj.length; i++) {
          var nx = adj[i][0], ny = adj[i][1];
          if (self.is_opened(nx, ny)) affected[nx + "," + ny] = [nx, ny];
        }
      }
      addNeighbors(x, y);
      for (var c = 0; c < cand.length; c++) addNeighbors(cand[c][0], cand[c][1]);

      var combos = this._combinations_pick(cand, m);

      for (var ci = 0; ci < combos.length; ci++) {
        var picks = combos[ci];

        var okSlots = true;
        for (var p = 0; p < picks.length; p++) {
          var px = picks[p][0], py = picks[p][1];
          var next = this.mines[px][py] + (isWhite ? -1 : +1);
          if (Math.sign(this.mines[px][py]) !== 0 && Math.sign(next) !== Math.sign(this.mines[px][py])) { okSlots = false; break; }
          if (Math.abs(next) > cap) { okSlots = false; break; }
        }
        if (!okSlots) continue;

        var allSame = true;

        var decNeighbors = {};
        var adjXY = this.near_positions(x, y);
        for (var i2 = 0; i2 < adjXY.length; i2++) {
          decNeighbors[adjXY[i2][0] + "," + adjXY[i2][1]] = true;
        }

        var incCount = {};
        for (var q = 0; q < picks.length; q++) {
          var ax = picks[q][0], ay = picks[q][1];
          var adjA = this.near_positions(ax, ay);
          for (var r = 0; r < adjA.length; r++) {
            var key = adjA[r][0] + "," + adjA[r][1];
            incCount[key] = (incCount[key] || 0) + 1;
          }
        }

        for (var key in affected) {
          var pos = affected[key];
          var ox = pos[0], oy = pos[1];
          var orig = this.near_mines[ox][oy];
          var origEff = (orig === 1000 ? 0 : orig);
          var delta = 0;
          delta -= mSigned; // 소스에서 mSigned 제거
          var incDelta = isWhite ? - (incCount[key] || 0) : (incCount[key] || 0);
          delta += incDelta;

          if ((origEff + delta) !== origEff) { allSame = false; break; }
        }
        if (!allSame) continue;

        var temp = JSON.parse(JSON.stringify(this.mines));
        var newly = {};

        temp[x][y] = 0;
        for (var s = 0; s < picks.length; s++) {
          var tx = picks[s][0], ty = picks[s][1];
          if (temp[tx][ty] === 0) newly[tx + "," + ty] = true;
          temp[tx][ty] += (isWhite ? -1 : +1);
        }

        // 커밋
        this.mines = temp;

        // parts 재계산
        this._near_black = this.new_table();
        this._near_white = this.new_table();
        for (var xx = 0; xx < this.columns; xx++) {
          for (var yy = 0; yy < this.rows; yy++) {
            var v = this.mines[xx][yy];
            if (v === 0) continue;
            var adj = this.near_positions(xx, yy);
            var addB = Math.max(0, v);
            var addW = Math.max(0, -v);
            for (var k = 0; k < adj.length; k++) {
              var nx = adj[k][0], ny = adj[k][1];
              this._near_black[nx][ny] += addB;
              this._near_white[nx][ny] += addW;
            }
          }
        }
        this._rebuild_near_from_parts();

        var deltaRemaining = 1 - Object.keys(newly).length;
        this.remaining += deltaRemaining;

        return true;
      }
      return false;
    };

    /* ---------- 지뢰 뿌리기 ---------- */
// ★ 지뢰 배치: 1) 원본 랜덤(n2/클러스터) → 2) 선형 보충 → 3) 강제 통합/비우기
// + 마지막에 "최소 1칸 비워두기" 보장
Minefield.prototype.init_mines = function () {
  var x, y;

  // 공용 상태 초기화
  this.mines = this.new_table();
  this.remaining = this.rows * this.columns;
  this._near_black = this.new_table();
  this._near_white = this.new_table();

  const W = this.columns, H = this.rows;
  const capBlack = Math.max(1, this.max_mines | 0);
  const capWhite = Math.max(0, this.max_mines_white | 0);
  const totalBlack = Math.max(0, this.num_mines | 0);
  const totalWhite = Math.max(0, this.num_mines_white | 0);

  // ----- 유틸리티 -----
  const val = (xx, yy) => this.mines[xx][yy];
  const set = (xx, yy, v) => { this.mines[xx][yy] = v; };
  function canAdd(self, xx, yy, signNeg) {
    const v = self.mines[xx][yy];
    if (signNeg) {
      if (v > 0) return false;                 // 혼합 금지
      return Math.abs(v) < capWhite;
    } else {
      if (v < 0) return false;                 // 혼합 금지
      return Math.abs(v) < capBlack;
    }
  }
  function addOne(self, xx, yy, signNeg) {
    const v = self.mines[xx][yy];
    if (v === 0) self.remaining -= 1;          // 새로 지뢰 생기는 칸
    self.mines[xx][yy] = v + (signNeg ? -1 : +1);
  }
  const hasZeroCell = () => {
    for (let yy=0; yy<H; yy++) for (let xx=0; xx<W; xx++) if (this.mines[xx][yy] === 0) return true;
    return false;
  };
  const oppSignNeg = (neg) => !neg;
  const signCap = (neg) => neg ? capWhite : capBlack;

  // 1단계에서 무한루프 방지용(“막히기 전까지”만 1단계 유지)
  const randStallLimit = Math.max(2000, Math.floor(W * H * 8));

  // ----- 3단계 포함한 증강 배치 루틴 -----
  const placeColorEnhanced = (TOTAL, CAP, signNeg) => {
    let created = 0;

    // ===== 1) 원본 랜덤 뿌리기 (요청: n2/클러스터링 로직 그대로) =====
    //  - 단, 혼합 금지/용량 체크는 색별 규칙으로 반영
    let n2 = W * H * 220 / 480;      // 전체칸수 * 220/480
    let stall = 0;
    while (created < TOTAL && stall < randStallLimit) {
      x = (Math.random() * W) | 0;
      y = (Math.random() * H) | 0;

      const cur = this.mines[x][y];
      // 색 혼합 금지
      if ((signNeg && cur > 0) || (!signNeg && cur < 0)) { stall++; continue; }
      // 용량 체크
      let curAbs = Math.abs(cur);
      if (curAbs >= CAP) { stall++; continue; }

      let n_max = Math.min(CAP - curAbs, TOTAL - created);
      let n;
      if ((TOTAL - created) > n2) { n = n_max; n2 -= 0.5; }   // 비율만큼은 최대치로 채우기
      else                        { n = Math.floor(Math.random() * n_max) + 1; }

      // 클러스터링 확률(주변에 지뢰 없으면 건너뜀)
      if (n >= 2) {
        var p = (n === 2 ? 0.2 :
                 n === 3 ? 0.5 :
                 n === 4 ? 0.5 :
                 n === 5 ? 0.5 :
                 n === 6 ? 0.5 : 0);
        if (Math.random() < p) {
          if (!this.has_neighbor_mine(x, y)) {
            stall++; continue;
          }
        }
      }

      if (this.mines[x][y] === 0) this.remaining -= 1;
      this.mines[x][y] += (signNeg ? -n : +n);
      created += n;
      stall = 0; // 성공했으니 stall 리셋
    }
    if (created >= TOTAL) return created;

    // ===== 2) 선형 스윕으로 보충 =====
    for (let yy = 0; yy < H && created < TOTAL; yy++) {
      for (let xx = 0; xx < W && created < TOTAL; xx++) {
        while (created < TOTAL && canAdd(this, xx, yy, signNeg)) {
          addOne(this, xx, yy, signNeg);
          created++;
        }
      }
    }
    if (created >= TOTAL) return created;

    // ===== 3) 강제 통합/비우기(상대색 재배치로 빈칸 만든 뒤 내 색 채워 넣기) =====
    let safety = W * H * 4; // 무한루프 방지
    while (created < TOTAL && safety-- > 0) {
      // 3-a) 비울 상대색 칸(작은 수량부터) 찾기
      let freedX = -1, freedY = -1, freedHad = 0;
      find_source:
      for (let want = 1; want <= signCap(oppSignNeg(signNeg)); want++) {
        for (let yy = 0; yy < H; yy++) {
          for (let xx = 0; xx < W; xx++) {
            const v = val(xx, yy);
            if (signNeg ? v <= 0 : v >= 0) continue; // 상대색만
            if (Math.abs(v) !== want) continue;

            // 이 칸의 상대색 지뢰를 다른 곳(CAP 범위 내)으로 전부 옮길 수 있는지 확인
            let remain = Math.abs(v);
            for (let y2=0; y2<H && remain>0; y2++) {
              for (let x2=0; x2<W && remain>0; x2++) {
                if (x2===xx && y2===yy) continue;
                const vv = val(x2, y2);
                const cap = signCap(oppSignNeg(signNeg));
                if (signNeg ? vv < 0 : vv > 0) {
                  const room = cap - Math.abs(vv);
                  if (room > 0) remain -= Math.min(room, remain);
                } else if (vv === 0) {
                  // 빈칸도 상대색으로 채워 수용 가능
                  remain -= Math.min(cap, remain);
                }
              }
            }
            if (remain <= 0) { freedX = xx; freedY = yy; freedHad = Math.abs(v); break find_source; }
          }
        }
      }
      if (freedX === -1) break; // 더는 불가

      // 3-b) 실제로 상대색을 분산해 freed 칸 비우기
      {
        const oppNeg = oppSignNeg(signNeg);
        let remain = freedHad;

        // 기존 상대색 칸부터 CAP까지 채우기
        for (let yy=0; yy<H && remain>0; yy++) {
          for (let xx=0; xx<W && remain>0; xx++) {
            if (xx===freedX && yy===freedY) continue;
            const vv = val(xx, yy);
            if (oppNeg ? vv < 0 : vv > 0) {
              const cap = signCap(oppNeg);
              const room = cap - Math.abs(vv);
              if (room > 0) {
                const mv = Math.min(room, remain);
                set(xx, yy, vv + (oppNeg ? -mv : +mv));
                remain -= mv;
              }
            }
          }
        }
        // 부족하면 빈칸을 상대색으로 신규 채우기
        for (let yy=0; yy<H && remain>0; yy++) {
          for (let xx=0; xx<W && remain>0; xx++) {
            if (xx===freedX && yy===freedY) continue;
            const vv = val(xx, yy);
            if (vv !== 0) continue;
            const cap = signCap(oppNeg);
            const mv = Math.min(cap, remain);
            set(xx, yy, (oppNeg ? -mv : +mv));
            this.remaining -= 1; // 새로 지뢰 생김
            remain -= mv;
          }
        }

        // 원본 칸 비우기
        if (val(freedX, freedY) !== 0) {
          set(freedX, freedY, 0);
          this.remaining += 1;
        }
      }

      // 3-c) 비워진 칸에 내 색으로 채우기
      while (created < TOTAL && canAdd(this, freedX, freedY, signNeg)) {
        addOne(this, freedX, freedY, signNeg);
        created++;
      }
    }

    return created;
  };

  // 배치 순서: 검은 → 흰 (검은 우선)
  placeColorEnhanced(totalBlack, capBlack, /*signNeg=*/false);
  if (totalWhite > 0 && capWhite > 0) {
    placeColorEnhanced(totalWhite, capWhite, /*signNeg=*/true);
  }

  // ===== ★ 최종 보정: "최소 1칸은 비워 두기" 보장 =====
  if (!hasZeroCell()) {
    const tryFreeOneCellBySign = (signNeg) => {
      const cells = [];
      for (let yy=0; yy<H; yy++) for (let xx=0; xx<W; xx++) {
        const v = val(xx, yy);
        if (v === 0) continue;
        if (signNeg ? (v < 0) : (v > 0)) cells.push([xx, yy, Math.abs(v)]);
      }
      cells.sort((a,b)=>a[2]-b[2]); // 적은 수부터

      for (let idx=0; idx<cells.length; idx++) {
        const [sx, sy, need] = cells[idx];
        const cap = signCap(signNeg);
        let remain = need;

        // 수용 가능성 체크
        for (let yy=0; yy<H && remain>0; yy++) {
          for (let xx=0; xx<W && remain>0; xx++) {
            if (xx===sx && yy===sy) continue;
            const vv = val(xx, yy);
            if (signNeg) {
              if (vv > 0) continue;
              const room = cap - Math.abs(vv);
              if (room > 0) remain -= Math.min(room, remain);
            } else {
              if (vv < 0) continue;
              const room = cap - Math.abs(vv);
              if (room > 0) remain -= Math.min(room, remain);
            }
          }
        }
        if (remain > 0) continue;

        // 실제 분산
        let left = need;
        for (let yy=0; yy<H && left>0; yy++) {
          for (let xx=0; xx<W && left>0; xx++) {
            if (xx===sx && yy===sy) continue;
            const vv = val(xx, yy);
            const room = cap - Math.abs(vv);
            if (room > 0 && (signNeg ? vv <= 0 : vv >= 0)) {
              const mv = Math.min(room, left);
              set(xx, yy, vv + (signNeg ? -mv : +mv));
              if (vv === 0 && mv > 0) this.remaining -= 1;
              left -= mv;
            }
          }
        }
        // 원본 비우기
        if (val(sx, sy) !== 0) {
          set(sx, sy, 0);
          this.remaining += 1;
        }
        return true;
      }
      return false;
    };

    if (!tryFreeOneCellBySign(false)) { // 검은
      if (!tryFreeOneCellBySign(true)) { // 흰
        // (매우 드묾) 상대색을 재배치해 빈칸을 만든다 — 생략 안전가드
        for (let sign of [true, false]) {
          let done = false;
          const cap = signCap(sign);
          outer:
          for (let yy=0; yy<H; yy++) for (let xx=0; xx<W; xx++) {
            const v = val(xx, yy);
            if (v === 0) { done = true; break outer; }
            if (sign ? v < 0 : v > 0) {
              let remain = Math.abs(v);
              for (let y2=0; y2<H && remain>0; y2++)
                for (let x2=0; x2<W && remain>0; x2++) {
                  if (x2===xx && y2===yy) continue;
                  const vv = val(x2, y2);
                  if (sign ? (vv > 0) : (vv < 0)) continue;
                  const room = cap - Math.abs(vv);
                  if (room > 0) remain -= Math.min(room, remain);
                }
              if (remain===0) {
                let left = Math.abs(v);
                for (let y2=0; y2<H && left>0; y2++)
                  for (let x2=0; x2<W && left>0; x2++) {
                    if (x2===xx && y2===yy) continue;
                    const vv = val(x2, y2);
                    if (sign ? (vv > 0) : (vv < 0)) continue;
                    const room = cap - Math.abs(vv);
                    if (room > 0) {
                      const mv = Math.min(room, left);
                      set(x2, y2, vv + (sign ? -mv : +mv));
                      if (vv === 0 && mv > 0) this.remaining -= 1;
                      left -= mv;
                    }
                  }
                set(xx, yy, 0);
                this.remaining += 1;
                done = true;
                break outer;
              }
            }
          }
          if (done) break;
        }
      }
    }
  }

  // --- parts(근방 수) 재계산 ---
  this._near_black = this.new_table();
  this._near_white = this.new_table();
  for (var xx = 0; xx < this.columns; xx++) {
    for (var yy = 0; yy < this.rows; yy++) {
      var v = this.mines[xx][yy];
      if (v === 0) continue;
      var adj = this.near_positions(xx, yy);
      var addB = Math.max(0, v);
      var addW = Math.max(0, -v);
      for (var k = 0; k < adj.length; k++) {
        var nx = adj[k][0], ny = adj[k][1];
        this._near_black[nx][ny] += addB;
        this._near_white[nx][ny] += addW;
      }
    }
  }
  this._rebuild_near_from_parts();

  // total_safe
  this.total_safe = 0;
  for (var i = 0; i < this.columns; i++) {
    for (var j = 0; j < this.rows; j++) {
      if (this.mines[i][j] === 0) this.total_safe++;
    }
  }

  this.game_status = 1;
  return this.game_status;
};

Minefield.prototype.generate_near_mines = function (mines) {
  var near_sum = this.new_table();
  var near_abs = this.new_table();

  for (var x = 0; x < this.columns; x++) {
    for (var y = 0; y < this.rows; y++) {
      var v = mines[x][y];
      if (v === 0) continue;
      var adj = this.near_positions(x, y);
      for (var k = 0; k < adj.length; k++) {
        var nx = adj[k][0], ny = adj[k][1];
        near_sum[nx][ny] += v;
        near_abs[nx][ny] += Math.abs(v);
      }
    }
  }

  var near_mines = this.new_table();
  const hasWhite = (this.num_mines_white|0) > 0;   // ← 가드 추가
  for (var i = 0; i < this.columns; i++) {
    for (var j = 0; j < this.rows; j++) {
      if (hasWhite && near_sum[i][j] === 0 && near_abs[i][j] > 0) { // ← 가드
        near_mines[i][j] = 1000;
      } else {
        near_mines[i][j] = near_sum[i][j];
      }
    }
  }
  return near_mines;
};

    Minefield.prototype.shift_table = function (table, dx, dy) {
      var new_table, new_x, new_y, nx, ny, _i, _j, _ref, _ref1;
      new_table = this.new_table();
      for (ny = _i = 0, _ref = this.rows - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; ny = 0 <= _ref ? ++_i : --_i) {
        for (nx = _j = 0, _ref1 = this.columns - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; nx = 0 <= _ref1 ? ++_j : --_j) {
          new_x = (nx + dx + 2 * this.columns) % this.columns;
          new_y = (ny + dy + 2 * this.rows) % this.rows;
          new_table[new_x][new_y] = table[nx][ny];
        }
      }
      return new_table;
    };

    /* ---------- DOM 헬퍼 ---------- */
    Minefield.prototype.get_class = function (x, y) {
      var td_class = this.tds[x][y].getAttribute("class");
      if (td_class === null || td_class === "") { return null; }
      return td_class;
    };

    Minefield.prototype.set_class = function (x, y, val) {
      if (val === null) {
        return this.tds[x][y].removeAttribute("class");
      } else {
        return this.tds[x][y].setAttribute("class", val);
      }
    };

    Minefield.prototype.near_positions = function (x, y) {
      var nx, ny, ret, _i, _j, _ref, _ref1, _ref2, _ref3;
      ret = [];
      for (nx = _i = _ref = x - 1, _ref1 = x + 1; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; nx = _ref <= _ref1 ? ++_i : --_i) {
        for (ny = _j = _ref2 = y - 1, _ref3 = y + 1; _ref2 <= _ref3 ? _j <= _ref3 : _j >= _ref3; ny = _ref2 <= _ref3 ? ++_j : --_j) {
          if (nx === x && ny === y) continue;
          if (nx >= this.columns || nx < 0 || ny >= this.rows || ny < 0) continue;
          ret.push([nx, ny]);
        }
      }
      return ret;
    };

    /* ---------- 입력 ---------- */
    Minefield.prototype.on_click = function (x, y) {
      var old_game_status = this.game_status;
      if (this.game_status < 0) return;

      // 깃발이면 좌클릭 사이클(검/흰 지원), 보드 열지 않음
      var td_class = this.get_class(x, y);
      if (td_class !== null && td_class !== "flag-0" && /^flag-/.test(td_class)) {
        this.cycle_flag_leftclick(x, y);
        if (this.on_rclick_func) this.on_rclick_func(x, y);
        return;
      }

      if (this.game_status === 1) this.start(x, y);

      if (this.expand(x, y) < 0) this.gameover(x, y);

      if (this.remaining === 0) this.gameclear();

      if (this.on_click_func) this.on_click_func(x, y);
      if (old_game_status !== this.game_status) return this.on_game_status_changed();
    };

    Minefield.prototype.on_rclick = function (x, y) {
      var old_game_status = this.game_status;
      if (this.game_status < 0) return;
      if (this.game_status === 1) this.game_status = 0;
      this.flag(x, y);
      if (this.on_rclick_func) this.on_rclick_func(x, y);
      if (old_game_status !== this.game_status) return this.on_game_status_changed();
    };

    // 좌클릭일 때: 깃발 상태에서 검은→…→검은Max→(흰 있으면)흰1→…→흰Max→검은1
    Minefield.prototype.cycle_flag_leftclick = function (x, y) {
      var cur = this.flags[x][y] || 0;
      if (cur === 0) return;

      var wMax = this.max_mines_white|0;
      var bMax = this.max_mines|0;

      var next, deltaSigned = 0;

      if (cur > 0) { // 검은 깃발 증가
        next = cur + 1;
        if (next > bMax) {
          if (wMax > 0) { next = -1; } else { next = 1; }
        }
        deltaSigned = next - cur;
      } else { // 흰 깃발 증가
        var abs = -cur;
        var absNext = abs + 1;
        if (absNext > wMax) {
          next = 1; // 검은1로
        } else {
          next = -absNext;
        }
        deltaSigned = next - cur;
      }

      // 카운터 갱신
      if (cur > 0) this.num_flags -= cur; else if (cur < 0) this.num_flags_white -= (-cur);
      if (next > 0) this.num_flags += next; else if (next < 0) this.num_flags_white += (-next);

      // near_flags(부호합)
      var adj = this.near_positions(x, y);
      for (var i = 0; i < adj.length; i++) {
        var nx = adj[i][0], ny = adj[i][1];
        this.near_flags[nx][ny] += deltaSigned;
      }

      this.flags[x][y] = next;
      if (next > 0) this.set_class(x, y, "flag-" + next);
      else this.set_class(x, y, "flag-m" + (-next));
    };

    Minefield.prototype.on_game_status_changed = function () {
      if (this.game_status_changed_func) return this.game_status_changed_func(this.game_status);
    };
    Minefield.prototype.on_game_status_changed2 = function () {
      if (this.game_status_changed_func2) return this.game_status_changed_func2(this.game_status2);
    };

    Minefield.prototype.start = function (x, y) {
      this.game_status = 0;
      if (this.mines[x][y] === 0) return;

      // 가벼운 재배치 시도(같은 색)
      if (this._relocateFirstClick(x, y)) return;

      // 실패 시 기존 시프트 폴백(시프트 후 parts/near 전부 재구성)
      var nx, ny, _i, _ref, _results;
      _results = [];
      for (nx = _i = 0, _ref = this.columns - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; nx = 0 <= _ref ? ++_i : --_i) {
        _results.push((function () {
          var _j, _ref1, _results1;
          _results1 = [];
          for (ny = _j = 0, _ref1 = this.rows - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; ny = 0 <= _ref1 ? ++_j : --_j) {
            if (this.mines[nx][ny] === 0) {
              this.mines = this.shift_table(this.mines, x - nx, y - ny);

              // ★ 시프트 후 parts와 near를 전부 재구성
              this._near_black = this.new_table();
              this._near_white = this.new_table();
              for (var xx = 0; xx < this.columns; xx++) {
                for (var yy = 0; yy < this.rows; yy++) {
                  var v = this.mines[xx][yy];
                  if (v === 0) continue;
                  var adj = this.near_positions(xx, yy);
                  var addB = Math.max(0, v);
                  var addW = Math.max(0, -v);
                  for (var k = 0; k < adj.length; k++) {
                    var nx2 = adj[k][0], ny2 = adj[k][1];
                    this._near_black[nx2][ny2] += addB;
                    this._near_white[nx2][ny2] += addW;
                  }
                }
              }
              this._rebuild_near_from_parts();

              _results1.push(true);
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    // 우클릭 사이클
    //  흰=0: null→flag-1..bMax→flag-0(?)→null
    //  흰>0: null→flag-1..bMax→flag-m1..mW→flag-0(?)→null
    Minefield.prototype.flag = function (x, y) {
      var td_class = this.get_class(x, y);
      if (td_class !== null && !/^flag/.exec(td_class)) return;

      var wMax = this.max_mines_white|0;
      var bMax = this.max_mines|0;
      var cur = this.flags[x][y] || 0;

      function applyClass(self, xx, yy, val) {
        if (val === 0) self.set_class(xx, yy, "flag-0"); // ?
        else if (val > 0) self.set_class(xx, yy, "flag-" + val);
        else self.set_class(xx, yy, "flag-m" + (-val));
      }

      var next, deltaSigned = 0;
      if (td_class === null) { // null → black1
        next = 1;
        deltaSigned = +1;
        this.num_flags += 1;
      } else if (td_class === "flag-0") { // ? → null
        this.set_class(x, y, null);
        this.flags[x][y] = 0;
        return;
      } else {
        // 현재 깃발에서 다음 단계
        if (cur > 0) {
          if (cur < bMax) { next = cur + 1; }
          else { // cur==bMax
            if (wMax > 0) { next = -1; } else { next = 0; } // 흰 없으면 ? 로
          }
        } else if (cur < 0) {
          var abs = -cur;
          if (abs < wMax) next = -(abs + 1);
          else next = 0; // ? 로
        } else {
          next = 1;
        }

        // 카운터 갱신/near_flags 델타
        if (cur > 0) this.num_flags -= cur;
        if (cur < 0) this.num_flags_white -= (-cur);

        if (next > 0) this.num_flags += next;
        if (next < 0) this.num_flags_white += (-next);

        deltaSigned = next - cur;
      }

      // near_flags 반영( ? 는 합산 제외 → deltaSigned=0)
      var adj = this.near_positions(x, y);
      for (var i = 0; i < adj.length; i++) {
        var nx = adj[i][0], ny = adj[i][1];
        this.near_flags[nx][ny] += deltaSigned;
      }

      this.flags[x][y] = next;
      applyClass(this, x, y, next);
    };

    // 지뢰는 (양수/음수) 모두 게임오버 트리거
    Minefield.prototype.press = function (x, y) {
      if (this.mines[x][y] !== 0) {
        return -1;
      } else if (this.get_class(x, y) !== null && this.get_class(x, y) !== "flag-0") {
        return 1;
      }

      this.remaining -= 1;

      this.opened_cells = (this.opened_cells || 0) + 1;
      this.opened_safe = (this.opened_safe || 0) + 1;

      var ratio = this.opened_safe / this.total_safe;
      if (!this.bonus_thresholds) this.bonus_thresholds = this.compute_bonus_thresholds();
      while ((this.bonus_reloc_count || 0) < this.bonus_thresholds.length &&
             ratio >= this.bonus_thresholds[this.bonus_reloc_count]) {
        this.bonus_reloc_count += 1;
      }

      // 숫자 표시: 1000 → 숫자0, 0 → 빈칸, 양수 → near-#, 음수 → near-m#
      var v = this.near_mines[x][y];
      if (v === 0) {
        this.set_class(x, y, "empty");
      } else if (v === 1000) {
        this.set_class(x, y, "near-0");
      } else if (v > 0) {
        this.set_class(x, y, "near-" + v);
      } else {
        this.set_class(x, y, "near-m" + (-v));
      }
      return 0;
    };

    /* ---------- 고속 확장(BFS) ---------- */
    Minefield.prototype.expand = function (start_x, start_y) {
      if (!this._visit || this._visit.length !== this.columns * this.rows) {
        this._ensureWorkBuffers();
      }

      var td_class = this.get_class(start_x, start_y);
      if (td_class !== null && (td_class !== "flag-0" && /^flag/.exec(td_class))) {
        return 1;
      }

      // 첫 클릭 보호(검/흰 모두)
      if (this.opened_cells === 0 && this.mines[start_x][start_y] !== 0) {
        if (!this._relocateFirstClick(start_x, start_y)) {
          this.start(start_x, start_y);
        }
      }

      var pr = this.press(start_x, start_y);
      if (pr < 0) {
        var allowed = this.get_reloc_allowed();
        if ((this.reloc_used || 0) < allowed) {
          if (this.try_relocate_from(start_x, start_y)) {
            this.reloc_used = (this.reloc_used || 0) + 1;
            pr = this.press(start_x, start_y);
            if (pr < 0) return -1;
          } else {
            return -1;
          }
        } else {
          return -1;
        }
      }

      // ★ 시작 칸이 "진짜 0"일 때만 확장 허용 (상쇄0=1000은 확장 금지)
      var v0 = this.near_mines[start_x][start_y];
      if (v0 !== 0) {
        return 0; // 숫자칸(양/음수/상쇄0)은 확장하지 않음
      }

      const W = this.columns, H = this.rows;
      const visit = this._visit;
      const qx = this._queueX;
      const qy = this._queueY;

      const gen = (this._visitGen = (this._visitGen | 0) + 1) || (this._visitGen = 1);

      function idx(x, y) { return y * W + x; }
      function markVisited(x, y) { visit[idx(x, y)] = gen; }
      function isVisited(x, y) { return visit[idx(x, y)] === gen; }

      let head = 0, tail = 0;
      qx[tail] = start_x; qy[tail] = start_y; tail++;
      markVisited(start_x, start_y);

      // 시작칸 자동 오픈 규칙 (XP 유사): 0일 때만 인접한 칸들 검사 시작
      var neighbors = this.near_positions(start_x, start_y);
      for (var i = 0; i < neighbors.length; i++) {
        var nx = neighbors[i][0], ny = neighbors[i][1];
        var c = this.get_class(nx, ny);
        if (c === null || c === "flag-0") {
          if (this.press(nx, ny) < 0) return -1;
          if (!isVisited(nx, ny)) {
            qx[tail] = nx; qy[tail] = ny; tail++;
            markVisited(nx, ny);
          }
        }
      }

      // BFS 확장: "진짜 0"만 계속 퍼짐 (상쇄0은 퍼지지 않음)
      while (head < tail) {
        var x = qx[head], y = qy[head]; head++;

        var v = this.near_mines[x][y];
        if (v === 0) { // 오직 0만 확장
          var adj = this.near_positions(x, y);
          for (var j = 0; j < adj.length; j++) {
            var ax = adj[j][0], ay = adj[j][1];
            var cls = this.get_class(ax, ay);
            if (cls === null || cls === "flag-0") {
              if (this.press(ax, ay) < 0) return -1;

              if (!isVisited(ax, ay)) {
                qx[tail] = ax; qy[tail] = ay; tail++;
                markVisited(ax, ay);
              }
            }
          }
        }
      }
      return 0;
    };

    /* ---------- 게임 종료 ---------- */
    Minefield.prototype.gameover = function(fail_x, fail_y) {
      var tmp = (document.getElementsByClassName("minetable")[0]).getElementsByTagName("td");
      for (var i = 0; i < tmp.length; i++) {
        var td = tmp[i];
        td.onclick = td.onmouseup = td.onmousedown = td.oncontextmenu = null;
      }
      this.game_status = -1;

      const self = this;

      function cellClassAtXY(x, y) {
        const mine = self.mines[x][y];
        const flagSigned = self.flags[x][y];
        const cur = self.get_class(x, y);

        if (mine !== 0) {
          // 올바른 깃발이면 그대로 두는 기존 정책 유지
          if (cur !== "flag-0" && /^flag/.test(cur)) return cur;

          if (x === fail_x && y === fail_y) {
            if (mine > 0) return "mine-exploded" + mine;
            else return "mine-exploded-m" + (-mine);
          }
          if (mine > 0) return "mine-" + mine;
          else return "mine-m" + (-mine);
        } else {
          if (flagSigned !== 0) {
            if (flagSigned > 0) return "mine-wrong" + flagSigned;
            else return "mine-wrong-m" + (-flagSigned);
          }
          var v = self.near_mines[x][y];
          if (v === 0) return "empty";
          if (v === 1000) return "near-0";
          if (v > 0) return "near-" + v;
          return "near-m" + (-v);
        }
      }

      const order = this._buildRowOrder(fail_y, 50);
      this._renderRowsIncrementally(order, cellClassAtXY, function() {});
      return true;
    };

    Minefield.prototype.gameclear = function () {
      var tmp = (document.getElementsByClassName("minetable")[0]).getElementsByTagName("td");
      for (var i = 0; i < tmp.length; i++) {
        var td = tmp[i];
        td.onclick = td.onmouseup = td.onmousedown = td.oncontextmenu = null;
      }

      this.num_flags = 0;
      this.num_flags_white = 0;
      this.near_flags = this.new_table();

      for (var y = 0; y < this.rows; y++) {
        for (var x = 0; x < this.columns; x++) {
          var mine = this.mines[x][y];
          if (mine !== 0) {
            if (mine > 0) {
              this.flags[x][y] = mine;
              this.num_flags += mine;
              var adj = this.near_positions(x, y);
              for (var i2 = 0; i2 < adj.length; i2++) {
                var nx = adj[i2][0], ny = adj[i2][1];
                this.near_flags[nx][ny] += mine;
              }
            } else {
              var w = -mine;
              this.flags[x][y] = -w;
              this.num_flags_white += w;
              var adjw = this.near_positions(x, y);
              for (var j2 = 0; j2 < adjw.length; j2++) {
                var wx = adjw[j2][0], wy = adjw[j2][1];
                this.near_flags[wx][wy] -= w; // 부호 유의
              }
            }
          } else {
            this.flags[x][y] = 0;
          }
        }
      }

      const self = this;
      function cellClassAtXY(x, y) {
        const mine = self.mines[x][y];
        if (mine !== 0) {
          if (mine > 0) return "flag-" + mine;
          return "flag-m" + (-mine);
        }
        var v = self.near_mines[x][y];
        if (v === 0) return "empty";
        if (v === 1000) return "near-0";
        if (v > 0) return "near-" + v;
        return "near-m" + (-v);
      }

      const order = Array.from({ length: this.rows }, (_, y) => y);
      this._renderRowsIncrementally(order, cellClassAtXY, () => {
        self.game_status = -2;
      });

      return this.game_status;
    };

    /* ---------- 마우스 프레스 표시 ---------- */
    Minefield.prototype.on_down = function () {
      this.game_status2 = 1;
      this.on_game_status_changed2();
      return 1;
    };
    Minefield.prototype.on_up = function () {
      this.game_status2 = 0;
      this.on_game_status_changed2();
      return 0;
    };

    /* ---------- 디버그 ---------- */
    Minefield.prototype.stringify = function () {
      return JSON.stringify(this.mines);
    };

    return Minefield;
  })();

  window.Minefield = Minefield;
}).call(this);
