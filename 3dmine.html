<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />

  <title>ourmine</title>
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#C0C0C0; }

    /* 무거운 첫 클릭 때 UI 확보용 */
    #loading-overlay{
      position:fixed; inset:0;
      display:none;
      background:rgba(0,0,0,0.25);
      backdrop-filter: blur(1px);
      align-items:center;
      justify-content:center;
      color:#fff;
      font:600 16px/1.2 system-ui, sans-serif;
      z-index:9999;
      opacity:0;
      transition:opacity 200ms ease;
    }
    #loading-overlay.delayed-show{ opacity:1; }
    #loading-overlay .box{
      background:rgba(0,0,0,0.55);
      border:1px solid rgba(255,255,255,0.18);
      padding:14px 16px;
      border-radius:12px;
    }
    #assist-panel{
  position:fixed;
  right:10px;
  bottom:10px;
  width:220px;
  height:160px;
  border:1px solid rgba(0,0,0,0.45);
  background:#C0C0C0;       /* ✅ 불투명(메인 배경과 동일) */
  border-radius:10px;
  z-index: 2000;            /* ✅ 캔버스보다 확실히 위 */
  pointer-events: auto;
  touch-action: none;
  overflow:hidden;
}
#assist-canvas{
  position:absolute;
  inset:0;
  width:100%;
  height:100%;
  display:block;
  touch-action:none;
}

    html, body { overscroll-behavior: none; }
canvas { touch-action: none; }

  </style>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
</head>
<body>
  <div id="loading-overlay"><div class="box">Generating…</div></div>
<div id="assist-panel">
  <canvas id="assist-canvas"></canvas>
</div>
  

<script>
  // 파일 상단 근처에 추가
let __timerId = null;
let __elapsed = 0;
let lrChordActive = false;
let lrChordCenter = null;
let rightDownNumberCell = null;
function startParentTimer(){
  stopParentTimer();
  __elapsed = 1;
  __timerId = setInterval(()=>{
    __elapsed += 1;
    postToParent({ __mine3d:1, type:'timer', elapsed: __elapsed });
  }, 1000);
}
function stopParentTimer(finalSend=true){
  if (__timerId){
    clearInterval(__timerId);
    __timerId = null;
  }
  if (finalSend){
    postToParent({ __mine3d:1, type:'timer', elapsed: __elapsed });
  }
}

  // ===== 파라미터 =====
  function getIntParam(sp, key, def) {
    const v = sp.get(key);
    if (v === null || v === undefined || v === "") return def;
    const n = parseInt(v, 10);
    return Number.isFinite(n) ? n : def;
  }
  function getBoolParam(sp, key, def) {
    const v = sp.get(key);
    if (v === null || v === undefined || v === "") return def;
    const s = String(v).toLowerCase();
    if (s === "true" || s === "1" || s === "yes" || s === "y" || s === "on") return true;
    if (s === "false" || s === "0" || s === "no" || s === "n" || s === "off") return false;
    return def;
  }
  function clampInt(v,a,b){ v = Math.floor(v); return Math.max(a, Math.min(b, v)); }
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));

  const sp = new URLSearchParams(location.search);
  const CONFIG = {
    cols: getIntParam(sp, "cols", 10),
    rows: getIntParam(sp, "rows", 10),
    depths: getIntParam(sp, "depths", 10),

    minesPerCell: getIntParam(sp, "minespercell", 1),
    minesTotal: getIntParam(sp, "mines", 30),

    whiteMinesPerCell: getIntParam(sp, "whiteminespercell", 0),
    whiteMinesTotal: getIntParam(sp, "whitemines", 0),

    useMark: getBoolParam(sp, "usemark", true),
    useColor: getBoolParam(sp, "usecolor", true), // 기본 true
  };

  CONFIG.cols = Math.max(1, CONFIG.cols);
  CONFIG.rows = Math.max(1, CONFIG.rows);
  CONFIG.depths = Math.max(1, CONFIG.depths);
  CONFIG.minesPerCell = clampInt(CONFIG.minesPerCell, 0, 6);
  CONFIG.whiteMinesPerCell = clampInt(CONFIG.whiteMinesPerCell, 0, 6);
  CONFIG.minesTotal = Math.max(0, CONFIG.minesTotal);
  CONFIG.whiteMinesTotal = Math.max(0, CONFIG.whiteMinesTotal);

  const SIZE = { x: CONFIG.cols, y: CONFIG.rows, z: CONFIG.depths };
  /* ===== 3D <-> parent bridge ===== */
const __BRIDGE = {
  ready: false,
  pendingInit: null,
  soundEnabled: false,
};
function countFlags3D(){
  let pos = 0, neg = 0;
  for (const c of cells){
    if (c.markType === MARK_POS) pos += (c.markCount|0);
    else if (c.markType === MARK_NEG) neg += (c.markCount|0);
  }
  return { pos, neg };
}

function sendCountersToParent(){
  const { pos, neg } = countFlags3D();

  // ✅ 첫 클릭 전엔 CONFIG 총량, 시작 후엔 실제 배치량(placed*) 기준
  const blackTotal = firstOpen ? (CONFIG.minesTotal|0) : (placedBlackMines|0);
  const whiteTotal = firstOpen ? (CONFIG.whiteMinesTotal|0) : (placedWhiteMines|0);

  postToParent({
    type: "counters",
    payload: {
      blackTotal,
      whiteTotal,
      blackRemain: blackTotal - pos,
      whiteRemain: whiteTotal - neg,
    }
  });
}

function postToParent(msg){
  if (window.parent && window.parent !== window){
    window.parent.postMessage({ __mine3d: 1, ...msg }, "*");
  }
}

// parent로부터 메시지 수신
window.addEventListener("message", (e) => {
  const m = e.data;
  if (!m || !m.__mine3d) return;

  if (m.type === "init") {
    // init이 너무 빨리 오면(아직 scene/renderer 없음) 큐에 저장
    if (!__BRIDGE.ready) { __BRIDGE.pendingInit = m.payload; return; }
    applyInitFromParent(m.payload);
    return;
  }

  if (m.type === "reset") {
    // main의 얼굴도 기본으로 돌려달라고 요청하는 흐름을 맞추기
    hardResetFromParent();
    postToParent({ type: "face", status: 0 });
    return;
  }

  if (m.type === "sound") {
    __BRIDGE.soundEnabled = !!m.enabled;
    return;
  }
  if (m.type === "config"){
    if (typeof m.usemark  !== 'undefined') CONFIG.useMark  = !!m.usemark;
    if (typeof m.usecolor !== 'undefined') { 
      CONFIG.useColor = !!m.usecolor;
      // 숫자/깃발 색 즉시 갱신
      refreshColorsNow();
    }
    return;
  }
    if (m.type === "assist") {
    // payload: { cause:'hint'|'auto', isFirstAuto:true|false }
    const reqId = m.requestId || null;
    let res = null;
    try {
      res = __mine3d_assist_once(m.payload || {});
    } catch (err) {
      res = { ok:false, error:String(err) };
      console.error(err);
    }
    postToParent({ type:"assistResult", requestId:reqId, payload:res });
    return;
  }

});
function refreshColorsNow(){
  // 숫자 스프라이트 캐시 초기화
  numberSpriteCache.clear();

  // 모든 열린 칸의 숫자 다시 입히기
  for (const c of cells){
    if (!c.isOpen) continue;
    if (c._numberSprite){
      c.content.remove(c._numberSprite);
      c._numberSprite = null;
    }
    if (c.mineValue !== 0) continue;
    if (c.adjValue === 0){
      continue;
    } else if (c.adjValue === 1000){
      const spr = getNumberSprite("0", numberColorByRule(0));
      spr.userData.cell = c;
      c.content.add(spr);
      c._numberSprite = spr;
    } else {
      const spr = getNumberSprite(String(c.adjValue), numberColorByRule(c.adjValue));
      inheritLayersFromCell(c, spr); 
      spr.userData.cell = c;
      c.content.add(spr);
      c._numberSprite = spr;
    }
  }

  // 깃발 색은 applyMarkVisual에 들어 있으니,
  // 닫힌 칸들만 한 번 돌면서 다시 칠해줌
  for (const c of cells){
    if (!c.isOpen && (c.markType === MARK_POS || c.markType === MARK_NEG || c.markType === MARK_Q)){
      c.applyMarkVisual();
    }
  }
    // ✅ X 색도 즉시 갱신(현재 표시 중인 것들)
  const xHex = xColorByRule();
  for (const c of cells){
    if (c.xMark?.visible && c.xMark.userData?.xMat){
      c.xMark.userData.xMat.color.setHex(xHex);
    }
  }

}

// 3D 내부에서 “소리 재생 요청”을 parent로 올림(실제 재생은 main이 함)
function requestPlaySound(file){
  if (!__BRIDGE.soundEnabled) return;
  postToParent({ type: "playSound", file });
}

// parent에 얼굴 상태 보내기(0 normal, 2 thinking, -1 dead, -2 win)
function setFace(status){
  postToParent({ type: "face", status });
}
function normalizeInitPayload(p){
  const cols  = Math.max(1, (p?.cols|0));
  const rows  = Math.max(1, (p?.rows|0));
  const depth = Math.max(1, (p?.depth|0));

  const minesPerCell       = Math.max(0, Math.min(6, (p?.minespercell|0)));
  const whiteMinesPerCell  = Math.max(0, Math.min(6, (p?.whiteminespercell|0)));

  const minesTotal     = Math.max(0, (p?.mines|0));
  const whiteMinesTotal= Math.max(0, (p?.whitemines|0));

  return { cols, rows, depth, minesPerCell, minesTotal, whiteMinesPerCell, whiteMinesTotal };
}

function applyInitFromParent(payload){
  const n = normalizeInitPayload(payload);

  // ✅ CONFIG 갱신 (기존 CONFIG 구조 유지)
  CONFIG.cols = n.cols;
  CONFIG.rows = n.rows;
  CONFIG.depths = n.depth;

  CONFIG.minesPerCell = n.minesPerCell;
  CONFIG.minesTotal   = n.minesTotal;

  CONFIG.whiteMinesPerCell = n.whiteMinesPerCell;
  CONFIG.whiteMinesTotal   = n.whiteMinesTotal;

  // SIZE 갱신
  SIZE.x = CONFIG.cols;
  SIZE.y = CONFIG.rows;
  SIZE.z = CONFIG.depths;

  

  // ✅ “보드 재구성” 호출 (아래 3)에서 구현/연결)
  rebuildBoardAfterInit();
}
function markBridgeReady(){
  __BRIDGE.ready = true;
  postToParent({ type: "ready" });

  // init이 먼저 와있었다면 지금 적용
  if (__BRIDGE.pendingInit){
    applyInitFromParent(__BRIDGE.pendingInit);
    __BRIDGE.pendingInit = null;
  }
}
function rebuildBoardAfterInit(){
  if (__BRIDGE.bootTimeout){
    clearTimeout(__BRIDGE.bootTimeout);
    __BRIDGE.bootTimeout = null;
  }
  resetGame();
  setFace(0);
  showOverlay(false);
}


function hardResetFromParent(){
  // 부모 reset 요청 → 현재 보드를 완전 리셋
 resetGame();        // 기존 재생성
  setFace(0);
  stopParentTimer(false);
  __elapsed = 0;
  postToParent({ __mine3d:1, type:'timer', elapsed: 0 }); // 0으로 표시 맞춤
}

  // ===== 시각 =====
  const SPACING = 1.18;
  const OPACITY_CLOSED = 0.95;
  const OPACITY_MARKED = 0.50;

  // “눌림/Chord 상태”에서 요구한 70%
  const OPACITY_PRESSED = 0.50;
  const OPACITY_CHORD_HI = 0.50;
  // ===== GAME OVER (WinXP 스타일 공개) =====
  const DIE_OPACITY_HIT   = 0.45; // 밟은 지뢰: 붉은 반투명
  const DIE_OPACITY_OTHER = 0.45; // 나머지 지뢰/오답깃발: 흰 반투명
  const DIE_COLOR_HIT     = 0xff7070;
  const DIE_COLOR_HIT_NOCOLOR = 0xC0C0C0;
  const DIE_COLOR_OTHER   = 0xffffff;
// === pick helpers ===
const __FLAG_PICKABLES = []; // 깃발(폴/천) 메쉬만 모아둠

function __isDeepVisible(obj){
  let o = obj;
  while (o){
    if (o.visible === false) return false;
    o = o.parent;
  }
  return true;
}

function __hideMarksVisualOnly(c){
  // 점수/카운트(markType)는 건드리지 않고 “보이는 것만” 숨김
  if (c.flagSlots) for (const s of c.flagSlots) s.visible = false;
  if (c.qSprite) c.qSprite.visible = false;
}

function __setDeadCube(c, colorHex, opacity){
  c.cube.visible = true;
  c.cube.material.color.setHex(colorHex);
  c.cube.material.opacity = opacity;
  c.cube.material.emissive.setHex(0x000000);
  c.cube.material.emissiveIntensity = 0.0;
}

function __renderNumberOnly(c){
  // cube는 사라진 상태에서 숫자만 보이게(열린칸처럼)
  c.content.visible = true;
  c.mineGroup.visible = false;

  __hideMarksVisualOnly(c);
  c.showX(false);

  if (c._numberSprite){
    c.content.remove(c._numberSprite);
    c._numberSprite = null;
  }

  // 기존 오픈 로직과 동일하게 표기:
  // adjValue===0: 진짜 0(빈칸) -> 숫자 없음
  // adjValue===1000: net=0 but 주변에 지뢰 존재 -> "0" 표시
  if (c.adjValue === 0){
    // 빈칸(숫자 없음)
    return;
  }
  if (c.adjValue === 1000){
    const spr = getNumberSprite("0", numberColorByRule(0));
    spr.userData.cell = c;
    c.content.add(spr);
    c._numberSprite = spr;
    return;
  }
  const spr = getNumberSprite(String(c.adjValue), numberColorByRule(c.adjValue));
  inheritLayersFromCell(c, spr); 
  spr.userData.cell = c;
  c.content.add(spr);
  c._numberSprite = spr;
}

function __showFakeMineForWrongFlag(c){
  // "지뢰 없는 칸에 깃발" → 흰 반투명 + 지뢰 + X
  c.content.visible = true;
  c.mineGroup.visible = true;

  // mineValue=0 이라 buildMinesVisual()이 안 켜주므로 1개를 수동으로 켬
  for (let i=0;i<6;i++){
    const s = c.mineSpheres[i];
    s.visible = (i === 0);
    if (i === 0){
      s.material.color.setHex(0x000000);
      s.position.set(0,0,0);
    }
  }
}

function revealAfterDeath_WinXP(hitCell=null){
  for (const c of cells){
    // hover 잔상 제거
    c.setHover(false);

    // 1) 지뢰칸: 전부 cube 보이게 + 지뢰
    if (c.mineValue !== 0){
      c.content.visible = true;
      c.mineGroup.visible = true;
      c.buildMinesVisual();

      __hideMarksVisualOnly(c);
      c.showX(false);

      if (hitCell && c === hitCell){
        // 밟은 지뢰: 붉은 반투명 + 지뢰
        const hitColor = CONFIG.useColor ? DIE_COLOR_HIT : DIE_COLOR_HIT_NOCOLOR; // 회색(원하면 값 변경)
        __setDeadCube(c, hitColor, DIE_OPACITY_HIT);
      } else {
        // 안 밟은 지뢰: 흰 반투명 + 지뢰
        __setDeadCube(c, DIE_COLOR_OTHER, DIE_OPACITY_OTHER);
      }
      continue;
    }

    // 2) 이미 열려있던 칸: 숫자 유지(그대로)
    if (c.isOpen){
      c.cube.visible = false;
      c.showX(false);
      continue;
    }

    // 3) 지뢰가 없는데 깃발 꽂은 칸: 흰 반투명 + 지뢰 + X
    if (isFlagged(c)){
      __hideMarksVisualOnly(c);
      __setDeadCube(c, DIE_COLOR_OTHER, DIE_OPACITY_OTHER);
      __showFakeMineForWrongFlag(c);
      c.showX(true);
      continue;
    }

    // 4) 지뢰 없고 안 열린 칸: cube 사라지고 숫자(열린 것처럼)
    c.cube.visible = false;
    __renderNumberOnly(c);
  }
}

  const POS_DIGIT_COLOR = {1:"#0000ff",2:"#003800",3:"#ff0000",4:"#000038",5:"#380000",6:"#003838",7:"#000000",8:"#383838",9:"#383800",0:"#380038"};
  const NONPOS_DIGIT_COLOR = {0:"#ffffff",1:"#c45c00",2:"#380000",3:"#00ffff",4:"#383800",5:"#003800",6:"#8a3800",7:"#000000",8:"#383838",9:"#ffff00"};
  function numberColorByRule(val){
    if(!CONFIG.useColor) return "#000000";
    const d = Math.abs(val) % 10;
    return (val > 0) ? POS_DIGIT_COLOR[d] : NONPOS_DIGIT_COLOR[d];
  }
  const POS_FLAG_COLORS_BASE = [ "#ff0000", "#003800", "#003838", "#383800",  "#380038",  "#383838" ];

const NEG_FLAG_COLORS_BASE = ["#0000ff","#00ff00","#00ffff","#ffff00","#ff00ff","#ffffff",];


function flagColorByRule(markType, i){
  if (!CONFIG.useColor) return "#000000";
  const base = (markType === MARK_POS) ? POS_FLAG_COLORS_BASE : NEG_FLAG_COLORS_BASE;
  return base[i] || "#000000";
}

  // ===== (깃발 위치 패턴) =====
  const FLAG_LAYOUT = {
    1: [[ 0, 0]],
    2: [[-1, 0],[ 1, 0]],
    3: [[-1,-1],[ 1,-1],[ 0, 1]],
    4: [[-1,-1],[ 1,-1],[-1, 1],[ 1, 1]],
    5: [[-1,-1],[ 1,-1],[0, 0],[ -1, 1],[ 1, 1]],
    6: [[-1,-1],[ 1,-1],[-1, 0],[ 1, 0],[-1, 1],[ 1, 1]],
  };
  const FLAG_DX = 0.20;
  const FLAG_DZ = 0.20;

  // ===== THREE =====
  let renderer, scene, camera;
  const raycaster = new THREE.Raycaster();
  const mouseNDC = new THREE.Vector2();
  const overlayEl = document.getElementById("loading-overlay");
const assistEl = document.getElementById("assist-panel");

// pointerId -> { startedInMain: bool }
const __ptrStart = new Map();

function __isInActiveArea(clientX, clientY){
  if (!__PICK.rect) return false;

  const r = __PICK.rect;
  if (clientX < r.left || clientX > r.right || clientY < r.top || clientY > r.bottom) return false;

  // main 입력일 때만 보조창 제외
  if (__PICK.source === "main" && assistEl){
    const ar = assistEl.getBoundingClientRect();
    if (clientX >= ar.left && clientX <= ar.right && clientY >= ar.top && clientY <= ar.bottom) return false;
  }
  return true;
}
function __setPickContext(source, domEl){
  __PICK.source = source;
  __PICK.dom = domEl;
  __PICK.rect = domEl.getBoundingClientRect();
  __PICK.camera = (source === "assist") ? assistCamera : camera;
}
function __releaseAllInputs(pointerId){
  // 입력 상태 전부 강제 해제 (메인 바깥으로 나가면 즉시 release)
  leftDown = false;
  middleDown = false;
  rightDown = false;
leftDownAxis = null;
  panDown = false;
  rotDown = false;
  leftRotDown = false;

  lrChordActive = false;
  lrChordCenter = null;

  rightDownCell = null;
  rightStartXY = null;
  rightMoved = false;

  leftDownCell = null;
  leftDownXY = null;
  leftPressedApplied = false;
  leftCanceledByChord = false;

  middleStartXY = null;
  middleMoved = false;

  chordArmed = false;
  chordKind = null;
  chordPointerId = null;

  setChordHighlight(false, null);
  clearPressedAndChord();

  // hover 잔상 제거
  if (hoverCell){ hoverCell.setHover(false); hoverCell = null; }

  // 터치 상태도 정리
  try { resetTouchState(); } catch(e) {}
  try {
    TOUCH2?.pointers?.clear?.();
    if (TOUCH2) { TOUCH2.mode = "none"; TOUCH2.justGesture = false; }
  } catch(e){}

  // 얼굴: 생성중이면 그대로(Generating), 아니면 normal
  if (!_is_generating && !(gameState === "over" || gameState === "win")) setFace(0);

  // pointer capture 해제
try { (__PICK.dom || renderer.domElement).releasePointerCapture(pointerId); } catch(e) {}

__ptrStart.delete(__PICK.source+"|"+pointerId);

}

  let cells = [];
  let cubeMeshes = [];
  let firstOpen = true;
  let gameState = "ready"; // ready | playing | over | win
  let openedCount = 0;
  let hoverCell = null;

  let placedBlackMines = 0;
  let placedWhiteMines = 0;

  const numberSpriteCache = new Map();

  // ===== Orbit(우클릭 드래그 회전) + Pan(중클릭 드래그) =====
  const orbit = {
    target: new THREE.Vector3(0,0,0),
    radius: 26,
    theta: 0.9,
    phi: 1.0,
    roll: 0.0,
    minRadius: 8,
    maxRadius: 400
  };
  const __tmpForward = new THREE.Vector3();
const __tmpUp = new THREE.Vector3();

function updateCameraOrbit(){
  const eps = 0.05;
  orbit.phi = clamp(orbit.phi, eps, Math.PI - eps);

  const sinPhi = Math.sin(orbit.phi);
  const x = orbit.radius * sinPhi * Math.cos(orbit.theta);
  const y = orbit.radius * Math.cos(orbit.phi);
  const z = orbit.radius * sinPhi * Math.sin(orbit.theta);

  camera.position.set(
    orbit.target.x + x,
    orbit.target.y + y,
    orbit.target.z + z
  );

  // ✅ roll: forward(시선)축 기준으로 up을 회전시켜 lookAt에 반영
  __tmpForward.subVectors(orbit.target, camera.position).normalize(); // forward
  __tmpUp.set(0, 1, 0).applyAxisAngle(__tmpForward, orbit.roll || 0);  // rolled up
  camera.up.copy(__tmpUp);

  camera.lookAt(orbit.target);
}
  function panByPixels(dx, dy){
    const panSpeed = orbit.radius * 0.0016;
    const m = new THREE.Matrix4().extractRotation(camera.matrixWorld);
    const right = new THREE.Vector3(1,0,0).applyMatrix4(m);
    const up = new THREE.Vector3(0,1,0).applyMatrix4(m);
    orbit.target.addScaledVector(right, -dx * panSpeed);
    orbit.target.addScaledVector(up,  dy * panSpeed);
    updateCameraOrbit();
  }

  // ===== utils =====
  function idx(x,y,z){ return x + SIZE.x * (y + SIZE.y * z); }
  function inBounds(x,y,z){ return x>=0 && x<SIZE.x && y>=0 && y<SIZE.y && z>=0 && z<SIZE.z; }
  function randInt(a,b){ return (a + Math.floor(Math.random()*(b-a+1))); }
  function neighbors26(cell){
    const out=[];
    for(let dz=-1; dz<=1; dz++) for(let dy=-1; dy<=1; dy++) for(let dx=-1; dx<=1; dx++){
      if(dx===0 && dy===0 && dz===0) continue;
      const nx=cell.x+dx, ny=cell.y+dy, nz=cell.z+dz;
      if(inBounds(nx,ny,nz)) out.push(cells[idx(nx,ny,nz)]);
    }
    return out;
  }

  // ===== 숫자/물음표 =====
  function getNumberSprite(text, color){
    const key = text + "|" + color;
    if(numberSpriteCache.has(key)) return numberSpriteCache.get(key).clone();

    const canvas=document.createElement("canvas");
    canvas.width=256; canvas.height=256;
    const ctx=canvas.getContext("2d");
    ctx.clearRect(0,0,256,256);

    ctx.fillStyle = color;
    ctx.font = "bold 140px system-ui, sans-serif";
    ctx.textAlign="center";
    ctx.textBaseline="middle";
    ctx.fillText(text, 128, 132);

    const tex=new THREE.CanvasTexture(canvas);
    tex.anisotropy=4;

    const mat=new THREE.SpriteMaterial({ map: tex, transparent:true });
    const spr=new THREE.Sprite(mat);
    spr.scale.set(0.68,0.68,0.68);

    numberSpriteCache.set(key, spr);
    return spr.clone();
  }
  function makeQuestionSprite(){
    const canvas = document.createElement("canvas");
    canvas.width = 256; canvas.height = 256;
    const ctx = canvas.getContext("2d");
    ctx.clearRect(0,0,256,256);
    ctx.fillStyle = "#000000";
    ctx.font = "bold 170px system-ui, sans-serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("?", 128, 140);
    const tex = new THREE.CanvasTexture(canvas);
    tex.anisotropy = 4;
    const mat = new THREE.SpriteMaterial({ map: tex, transparent:true });
      mat.depthTest = false; 
    const spr = new THREE.Sprite(mat);
    spr.scale.set(0.7,0.7,0.7);
    spr.renderOrder = 99999999; 
    return spr;
  }

  // ===== 지뢰 구 =====
  const MINE_OFFSETS = [
    [new THREE.Vector3(0,0,0)],
    [new THREE.Vector3(-0.16, 0.12, 0.00), new THREE.Vector3(0.16,-0.12,0.00)],
    [new THREE.Vector3(-0.18, 0.14, 0.00), new THREE.Vector3(0.18, 0.14,0.00), new THREE.Vector3(0,-0.18,0.00)],
    [new THREE.Vector3(-0.18, 0.18, 0.12), new THREE.Vector3(0.18, 0.18,-0.12), new THREE.Vector3(-0.18,-0.18,-0.12), new THREE.Vector3(0.18,-0.18,0.12)],
    [new THREE.Vector3(0,0,0), new THREE.Vector3(-0.20, 0.18,0.00), new THREE.Vector3(0.20, 0.18,0.00), new THREE.Vector3(-0.20,-0.18,0.00), new THREE.Vector3(0.20,-0.18,0.00)],
    [new THREE.Vector3(-0.20, 0.20, 0.20), new THREE.Vector3(0.20, 0.20,-0.20), new THREE.Vector3(-0.20,-0.20,-0.20),
     new THREE.Vector3(0.20,-0.20,0.20), new THREE.Vector3(-0.20,0.20,-0.20), new THREE.Vector3(0.20,-0.20,-0.20)]
  ];

  // ===== 마킹 =====
  const MARK_NONE="none", MARK_POS="pos", MARK_NEG="neg", MARK_Q="q";
  function isFlagged(cell){ return cell.markType===MARK_POS || cell.markType===MARK_NEG; }
  function isFlaglessForChord(cell){
    // “깃발없는 (?는 깃발없는것과같다)”
    return (cell.markType===MARK_NONE || cell.markType===MARK_Q);
  }
  function flagSignedCount(cell){
    if(cell.markType===MARK_POS) return cell.markCount;
    if(cell.markType===MARK_NEG) return -cell.markCount;
    return 0;
  }
  function flagAbsCount(cell){ return isFlagged(cell) ? cell.markCount : 0; }
  function flagMatchesMineExactly(cell){
    if(cell.markType===MARK_POS) return cell.mineValue === +cell.markCount;
    if(cell.markType===MARK_NEG) return cell.mineValue === -cell.markCount;
    return false;
  }

  // ===== 깃발 / X표 =====
  function makeFlagMesh(triColor){
    const g = new THREE.Group();
    const poleGeo = new THREE.CylinderGeometry(0.03,0.03,0.75,10);
    const poleMat = new THREE.MeshStandardMaterial({ color:0x000000, roughness:0.5 });
    const pole = new THREE.Mesh(poleGeo, poleMat);
    pole.position.set(0, -0.05, 0);
    g.add(pole);

    const shape = new THREE.Shape();
    shape.moveTo(0, 0.12);
    shape.lineTo(0.35, 0.0);
    shape.lineTo(0, -0.12);
    shape.lineTo(0, 0.12);

    const flagGeo = new THREE.ShapeGeometry(shape);
    const flagMat = new THREE.MeshStandardMaterial({
      color: new THREE.Color(triColor),
      side: THREE.DoubleSide,
      roughness: 0.35
    });
    const flag = new THREE.Mesh(flagGeo, flagMat);
    flag.position.set(0.03, 0.18, 0.00); // XY(z=0) 평면
    g.add(flag);

    return g;
  }

  function makeXMarkLines(){
  const mat = new THREE.LineBasicMaterial({ color: DIE_COLOR_HIT }); // 기본(컬러)
  const g1 = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-0.5, -0.5, 0), new THREE.Vector3( 0.5,  0.5, 0)]);
  const g2 = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-0.5,  0.5, 0), new THREE.Vector3( 0.5, -0.5, 0)]);
  const grp = new THREE.Group();

  const l1 = new THREE.Line(g1, mat);
  const l2 = new THREE.Line(g2, mat);
  grp.add(l1);
  grp.add(l2);

  // ✅ 나중에 색 바꾸기 위해 material을 보관
  grp.userData.xMat = mat;

  grp.visible = false;
  return grp;
}
function xColorByRule(){
  return CONFIG.useColor ? DIE_COLOR_HIT : 0x000000; // 흑백이면 회색
}
  // ===== 클릭/상태 흐름(요청 코드 구조 반영) =====
  let _is_generating = false; // ★ on_up 방어용 (코드와 동일 개념)
  let game_status2 = 0;       // “표정”같은 보조 상태 자리
  function on_game_status_changed2(){
    // 우리에겐 얼굴이 없으니, 상태 텍스트에만 반영
    // (요청: 흐름 유지가 핵심)
    // game_status2=0 -> 기본
  }

  function on_up_global(){
  if (_is_generating) return;
    // ✅ 게임 끝났으면 절대로 0(웃는얼굴)로 되돌리지 않음
  if (gameState === "over" || gameState === "win") return;
  game_status2 = 0;
  on_game_status_changed2();

  setFace(0); // ✅ 추가
}

let assistRenderer = null;
let assistCamera = null;
let assistCanvas = null;

const L_MAIN = 0;
const L_ASSIST_CELLS = 1;
const L_ASSIST_UI = 2;

let __PICK = { source:"main", dom:null, camera:null, rect:null };

let __assistPrevCells = [];   // 이전에 layer1 켰던 셀들
let __assistCells = [];       // 현재 focused 주변 셀들(최대 27)
const __AXIS_PICKABLES = [];  // 삼각뿔 피킹
let axisGroup = null;
function setLayerRecursive(obj, layer, enable){
  obj.traverse((o)=>{
    if (!o.layers) return;
    if (enable) o.layers.enable(layer);
    else o.layers.disable(layer);
  });
}

  // ===== chord 하이라이트(전역) =====
  let chordHighlightActive = false;
let chordCenterCell = null;
let chordHighlighted = new Set(); // 현재 70%로 낮춘 셀들 기록

function setChordHighlight(active, centerCell = null){
  // 먼저 이전에 낮춘 것들 원복
  for (const c of chordHighlighted) c.syncCubeOpacity();
  chordHighlighted.clear();

  chordHighlightActive = !!active;
  chordCenterCell = active ? centerCell : null;

  if (!chordHighlightActive || !chordCenterCell) return;

  // ✅ “중심 숫자 셀”의 인접(26) 중에서
  // ✅ 안열린 + 깃발없는(= ? 포함)만 70%
   // ✅ 0) 클릭된 자기 자신도 포함 (조건 만족할 때만)
  const c0 = chordCenterCell;
  setFocusedCell(chordCenterCell);
  if (c0.cube.visible && !c0.isOpen && isFlaglessForChord(c0)) {
    c0.cube.material.opacity = OPACITY_CHORD_HI; // 0.70
    chordHighlighted.add(c0);
  }
  const neigh = neighbors26(chordCenterCell);
  for (const n of neigh){
    if(!n.cube.visible) continue;
    if(n.isOpen) continue;
    if(!isFlaglessForChord(n)) continue; // MARK_NONE or MARK_Q

    n.cube.material.opacity = OPACITY_CHORD_HI; // 0.70
    chordHighlighted.add(n);
  }
}
  // ===== pointer 입력 상태 =====
  let leftDown = false;
  let middleDown = false;
  let rightDown = false;
// ✅ 우클릭 드래그=pan, 클릭=마킹(드래그하면 마킹 취소)
let rightDownCell = null;
let rightStartXY = null;
let rightMoved = false;
let rightPanLastX = 0, rightPanLastY = 0;
  let leftDownCell = null;
  let leftDownXY = null;
  let leftPressedApplied = false;

  let chordArmed = false;      // “다운~업 동안 chord 상태”
  let chordKind = null;        // 'middle' | 'shiftLeft' | 'lr'
  let chordPointerId = null;

  let panDown = false;
  let panLastX=0, panLastY=0;

  // 우클릭 회전
  let rotDown=false;
  let leftRotDown = false;
  let rotLastX=0, rotLastY=0;
  let rotStartX=0, rotStartY=0;

  const MOVE_CANCEL_PX = 8;
let leftCanceledByChord = false;

// 중클릭: 숫자 아니면 "큐브 chord 시도" + 드래그하면 pan으로 전환
let middleStartXY = null;
let middleMoved = false;
// ===== 모바일(터치) 전용 제스처 =====
const IS_MOBILE = matchMedia?.("(pointer: coarse)")?.matches || ("ontouchstart" in window);

const TOUCH = {
  active:false,
  pointerId:null,
  startX:0, startY:0,
  lastX:0, lastY:0,
  rotate:false,
  longPressTimer:null,
  longPressFired:false,
  downCell:null,
  pressedApplied:false,
};
// ===== 2-touch (pinch zoom + parallel pan) =====
const TOUCH2 = {
  pointers: new Map(),   // pointerId -> {x,y}
  mode: "none",          // "none" | "gesture"
  lastMidX: 0,
  lastMidY: 0,
  lastDist: 0,
  lastAngle: 0,
  justGesture: false,    // 제스처 끝난 직후 탭 방지용
};

function t2_setPointer(ev){
  TOUCH2.pointers.set(ev.pointerId, { x: ev.clientX, y: ev.clientY });
}
function t2_delPointer(ev){
  TOUCH2.pointers.delete(ev.pointerId);
}
function t2_get2(){
  const ids = Array.from(TOUCH2.pointers.keys()).sort((a,b)=>a-b);
  const a = TOUCH2.pointers.get(ids[0]);
  const b = TOUCH2.pointers.get(ids[1]);
  return [a,b];
}
function t2_midDist(){
  const [a,b] = t2_get2();
  const midX = (a.x + b.x) * 0.5;
  const midY = (a.y + b.y) * 0.5;
  const dist = Math.hypot(a.x - b.x, a.y - b.y);
  const angle = Math.atan2(b.y - a.y, b.x - a.x);
  return { midX, midY, dist, angle };
}
function t2_enterGesture(){
  TOUCH2.mode = "gesture";
  TOUCH2.justGesture = true;
  const { midX, midY, dist, angle } = t2_midDist();
  TOUCH2.lastMidX = midX;
  TOUCH2.lastMidY = midY;
  TOUCH2.lastDist = dist;
  TOUCH2.lastAngle = angle; 
  // 1손가락 탭/롱프레스/pressed 모두 취소
  clearLongPress();
  if (TOUCH.downCell && TOUCH.pressedApplied){
    TOUCH.downCell.setPressed(false);
    TOUCH.pressedApplied = false;
  }
  // 단일터치 로직은 더 이상 실행하지 않게
  TOUCH.active = false;
  TOUCH.pointerId = null;
  TOUCH.rotate = false;
  TOUCH.longPressFired = true; // 탭 방지(의미상)
}

const DOUBLE_TAP_MS = 280;
const DOUBLE_TAP_DIST = 22;
let lastTap = { t:0, x:0, y:0, onNumber:false };

function clearLongPress(){
  if (TOUCH.longPressTimer){
    clearTimeout(TOUCH.longPressTimer);
    TOUCH.longPressTimer = null;
  }
}

function resetTouchState(){
  clearLongPress();
  TOUCH.active = false;
  TOUCH.pointerId = null;
  TOUCH.rotate = false;
  TOUCH.longPressFired = false;
  TOUCH.downCell = null;
  TOUCH.pressedApplied = false;
}

function touchDist(ev){
  return Math.hypot(ev.clientX - TOUCH.startX, ev.clientY - TOUCH.startY);
}
function inheritLayersFromCell(cell, obj){
  if (!cell || !obj || !obj.layers) return;
  obj.layers.mask = cell.group.layers.mask; // ✅ cell이 가진 레이어를 그대로 상속
}
  // ===== Cell =====
  class Cell{
    constructor(x,y,z, worldPos){
      this.x=x; this.y=y; this.z=z;
      this.mineValue=0;  // 0 / +k / -k
      this.adjValue=0;   // net / 0 / 1000
      this.isOpen=false;

      this.markType=MARK_NONE;
      this.markCount=0;

      this.group = new THREE.Group();
      this.group.position.copy(worldPos);

      const cubeGeo=new THREE.BoxGeometry(1,1,1);
      const cubeMat=new THREE.MeshStandardMaterial({
        color:0xffffff, transparent:true, opacity:OPACITY_CLOSED,
        roughness:0.25, metalness:0.0, depthWrite:true,
        emissive:0x000000, emissiveIntensity:0.35
      });
      this.cube = new THREE.Mesh(cubeGeo, cubeMat);
      this.cube.userData.cell = this;
      this.group.add(this.cube);

      this.content = new THREE.Group();
      this.content.visible = false;
      this.group.add(this.content);

      // mines
      this.mineGroup = new THREE.Group();
      this.mineSpheres=[];
      const sphereGeo=new THREE.SphereGeometry(0.17,16,16);
      for(let i=0;i<6;i++){
        const m=new THREE.Mesh(sphereGeo, new THREE.MeshStandardMaterial({color:0x000000, roughness:0.35}));
        m.visible=false;
        this.mineGroup.add(m);
        this.mineSpheres.push(m);
      }
      this.mineGroup.visible=false;
      this.content.add(this.mineGroup);

      // flags (6 slots, positioned by FLAG_LAYOUT)
      this.flagsGroup=new THREE.Group();
      this.flagSlots=[];
      for(let i=0;i<6;i++){
        const slot=makeFlagMesh("#000000");
        slot.visible=false;
        this.flagsGroup.add(slot);
        this.flagSlots.push(slot);
        // ✅ slot 안의 실제 메쉬(폴/깃발천)를 피킹 대상으로 등록
  slot.traverse((o)=>{
    if (o && o.isMesh){
      o.userData.cell = this;
      o.userData.pickType = "flag";
      __FLAG_PICKABLES.push(o);
    }
  });
      }
      this.group.add(this.flagsGroup);

      this.qSprite = makeQuestionSprite();
      this.qSprite.visible=false;
      this.group.add(this.qSprite);

      this.xMark = makeXMarkLines();
      this.group.add(this.xMark);

      this._numberSprite=null;
    }

    syncCubeOpacity(){
      if(!this.cube.visible) return;
      // chord 하이라이트가 켜져있다면, “깃발없는”은 0.70 유지해야 함
      
      this.cube.material.opacity = (this.markType !== MARK_NONE) ? OPACITY_MARKED : OPACITY_CLOSED;
    }

    showX(on){
  this.xMark.visible = !!on;
  if (on && this.xMark.userData.xMat){
    this.xMark.userData.xMat.color.setHex(xColorByRule());
  }
}


    setMarkNone(){
      this.markType=MARK_NONE;
      this.markCount=0;
      this.applyMarkVisual();
    }

    applyMarkVisual(){
      for(const s of this.flagSlots) s.visible=false;
      this.qSprite.visible=false;

      if(this.markType===MARK_POS || this.markType===MARK_NEG){
        const count = Math.min(6, this.markCount);
        const layout = FLAG_LAYOUT[count] || FLAG_LAYOUT[1];
        for(let i=0;i<count;i++){
          const [u,v]=layout[i];
          this.flagSlots[i].position.set(u*FLAG_DX, 0, v*FLAG_DZ);
          const tri=this.flagSlots[i].children[1];
          const col = flagColorByRule(this.markType, i);

          tri.material.color.set(col);
          this.flagSlots[i].visible=true;
        }
      } else if(this.markType===MARK_Q){
        this.qSprite.visible=true;
      }

      this.syncCubeOpacity();
      updateScore();
      sendCountersToParent();
    }

    // ★ 우클릭 다운에서 즉시 적용
    cycleMark(){
      setFocusedCell(this);
      if(this.isOpen) return;
      if(gameState==="over" || gameState==="win") return;

      const maxPos = CONFIG.minesPerCell;
      const maxNeg = CONFIG.whiteMinesPerCell;

      const canPos = maxPos>0;
      const canNeg = maxNeg>0;
      const canQ = CONFIG.useMark;

      if(this.markType===MARK_NONE){
        if(canPos){ this.markType=MARK_POS; this.markCount=1; }
        else if(canNeg){ this.markType=MARK_NEG; this.markCount=1; }
        else if(canQ){ this.markType=MARK_Q; this.markCount=0; }
      } else if(this.markType===MARK_POS){
        if(this.markCount < maxPos) this.markCount++;
        else {
          if(canNeg){ this.markType=MARK_NEG; this.markCount=1; }
          else if(canQ){ this.markType=MARK_Q; this.markCount=0; }
          else { this.setMarkNone(); return; }
        }
      } else if(this.markType===MARK_NEG){
        if(this.markCount < maxNeg) this.markCount++;
        else {
          if(canQ){ this.markType=MARK_Q; this.markCount=0; }
          else { this.setMarkNone(); return; }
        }
      } else if(this.markType===MARK_Q){
        this.setMarkNone(); return;
      }

      this.applyMarkVisual();
    }
// ✅ 좌클릭(깃발 위) 전용: ?/해제 없이 "깃발만" 순환
cycleFlagOnly(){
  setFocusedCell(this);
  if (this.isOpen) return;
  if (gameState === "over" || gameState === "win") return;

  const maxPos = CONFIG.minesPerCell | 0;
  const maxNeg = CONFIG.whiteMinesPerCell | 0;
  const canPos = maxPos > 0;
  const canNeg = maxNeg > 0;

  // 혹시 비정상 상태로 들어오면 시작점 보정
  if (this.markType !== MARK_POS && this.markType !== MARK_NEG){
    if (canPos){ this.markType = MARK_POS; this.markCount = 1; this.applyMarkVisual(); }
    else if (canNeg){ this.markType = MARK_NEG; this.markCount = 1; this.applyMarkVisual(); }
    return;
  }

  if (this.markType === MARK_POS){
    if (this.markCount < maxPos) {
      this.markCount++;
    } else {
      // pos max -> neg1 (가능하면), 아니면 pos1로 래핑
      if (canNeg){ this.markType = MARK_NEG; this.markCount = 1; }
      else { this.markType = MARK_POS; this.markCount = 1; }
    }
  } else { // MARK_NEG
    if (this.markCount < maxNeg) {
      this.markCount++;
    } else {
      // neg max -> pos1 (가능하면), 아니면 neg1로 래핑
      if (canPos){ this.markType = MARK_POS; this.markCount = 1; }
      else { this.markType = MARK_NEG; this.markCount = 1; }
    }
  }

  this.applyMarkVisual();
}

    // 눌림 피드백(좌클릭 down 동안)
    setPressed(on){
      if(!this.cube.visible) return;
      if(on){
        this.cube.material.opacity = OPACITY_PRESSED;
      } else {
        this.syncCubeOpacity();
      }
    }

    buildMinesVisual(){
      const v=this.mineValue;
      const count=Math.min(6, Math.abs(v));
      const isNeg=v<0;
      const col=isNeg?0xffffff:0x000000;

      for(let i=0;i<6;i++) this.mineSpheres[i].visible=false;
      if(count<=0) return;

      const offsets=MINE_OFFSETS[count-1]||MINE_OFFSETS[0];
      for(let i=0;i<count;i++){
        const s=this.mineSpheres[i];
        s.material.color.setHex(col);
        s.position.copy(offsets[i]||new THREE.Vector3(0,0,0));
        s.visible=true;
      }
    }

    // 좌클릭/Chord는 “업”에서 처리하도록 외부에서 호출
    openFromClick(){
      setFocusedCell(this);

      if(this.isOpen) return;
      if(gameState==="over" || gameState==="win") return;

      // ?면 제거 후 열기
      if(this.markType===MARK_Q){
        this.setMarkNone();
      }

      // ✅ 깃발이면 "열기" 대신 깃발만 순환( ?/해제 없음 )
if (isFlagged(this)){
  this.cycleFlagOnly();
  return;
}

      on_click_cell(this); // “on_click 흐름”으로 처리
    }

    openFromChord(){
      if(this.isOpen) return;
      if(isFlagged(this)) return;
      if(this.markType===MARK_Q) this.setMarkNone();
      on_click_cell(this);
    }

    // 내부 실제 open (start 이후 expand 포함)
    _openInternal_afterStart(){
      if(this.isOpen) return;
      this.isOpen=true;
      openedCount++;

      this.cube.visible=false;
      this.content.visible=true;

      // 마킹/X 제거
      this.setMarkNone();
      this.showX(false);

      // 지뢰면 게임오버
      if(this.mineValue!==0){
        this.mineGroup.visible=true;
        gameOver(this);
        return;
      }

      // 숫자/확장
      if(this._numberSprite){
        this.content.remove(this._numberSprite);
        this._numberSprite=null;
      }

      if(this.adjValue===0){
        expandTrueZerosFrom(this);
      } else if(this.adjValue===1000){
        const spr=getNumberSprite("0", numberColorByRule(0));
        inheritLayersFromCell(this, spr);  
        spr.userData.cell=this;
        this.content.add(spr);
        this._numberSprite=spr;
      } else {
        const spr=getNumberSprite(String(this.adjValue), numberColorByRule(this.adjValue));
        inheritLayersFromCell(this, spr); 
        spr.userData.cell=this;
        this.content.add(spr);
        this._numberSprite=spr;
      }

      checkWin();
      updateScore();
    }

    setHover(on){
      if(!this.cube.visible) return;
      this.cube.material.emissive.setHex(on ? 0x334455 : 0x000000);
    }
  }

  // ===== “코드 흐름”에 맞춘 on_click =====
  function shouldAsyncGenerate(){
    // 원본 코드: (use_nopick || max_mines_white+max_mines>500)
    // 우리는 퍼포먼스 이슈가 실제로 생기는 조건으로 비슷하게 둠.
    const totalCells = SIZE.x*SIZE.y*SIZE.z;
    const totalMines = CONFIG.minesTotal + CONFIG.whiteMinesTotal;
    return firstOpen && (totalCells > 20000 || totalMines > 5000);
  }

  function showOverlay(on){
    if(!overlayEl) return;
    if(on){
      overlayEl.style.display = "flex";
      overlayEl.classList.add("delayed-show");
    } else {
      overlayEl.style.display = "none";
      overlayEl.classList.remove("delayed-show");
    }
  }

  function startGameAt(cell){
    // 첫 클릭에서 지뢰 배치/adj 계산/비주얼 구축
    placeMinesAvoiding_ENHANCED(cell); 
    computeAdjValues();
    for(const c of cells) c.buildMinesVisual();
    firstOpen=false;
    gameState="playing";

    startParentTimer();            // ✅ 추가
    sendCountersToParent();
  }

  // Minefield.prototype.on_click 구조를 3D로 이식
  function on_click_cell(cell){
    const oldState = gameState;
    if(gameState==="over" || gameState==="win") return;

    // (원본) 깃발 처리 로직은 여기선 “좌클릭으로 깃발 순환”을 안 쓰므로 패스
    // (요구: ? 좌클릭은 열림) -> openFromClick에서 이미 처리

    if(gameState==="ready"){
      setFace(2); // ✅ 추가: generating/thinking
      // 첫 클릭: 무거우면 비동기 분기
      if(shouldAsyncGenerate()){
        _is_generating = true;         // ★ on_up 방어
        showOverlay(true);

        // 눌린 상태 유지(pressed/chord 시각 피드백 유지)
        // (이미 down에서 적용되므로 그대로 둠)

        setTimeout(()=>{
          try{
            startGameAt(cell);
            cell._openInternal_afterStart();
            if(oldState !== gameState) { /* 상태변화 */ }
          } catch(e){
            console.error(e);
            alert("오류: " + e);
          } finally {
            _is_generating = false;
            showOverlay(false);
            setFace(0);
            // 원본 finally: on_up을 수동 동기화
            game_status2 = 0;
            on_game_status_changed2();

            // pressed/chord 해제
            clearPressedAndChord();
          }
        }, 50);
        return;
      }

      // 동기(가벼운 클릭)
      startGameAt(cell);
      cell._openInternal_afterStart();
      if(oldState !== gameState) { /* 상태변화 */ }
      return;
    }

    // playing 중 클릭(동기)
    cell._openInternal_afterStart();
  }

  // ===== 인접값/확장/승패/게임오버 =====
  // ==============================
// 3D Mines placement (2D-algo port)
// random(cluster & prefer max) -> linear sweep -> forced redistribution
// + "first-click expand if possible"
// ==============================
function placeMinesAvoiding_ENHANCED(firstCell){
  // 0) 초기화
  for (const c of cells) c.mineValue = 0;
  placedBlackMines = 0;
  placedWhiteMines = 0;

  const capB = (CONFIG.minesPerCell|0);
  const capW = (CONFIG.whiteMinesPerCell|0);

  // cap==0이면 그 색의 total은 0으로 취급(요청이 와도 불가능)
  let totalB = (capB > 0) ? (CONFIG.minesTotal|0) : 0;
  let totalW = (capW > 0) ? (CONFIG.whiteMinesTotal|0) : 0;

  // ---- forbid set: (A) expand 모드(클릭칸+26이웃) vs (B) 클릭칸만 ----
  const forbidExpand = buildForbidSet3D(firstCell, /*includeNeighbors=*/true);
  const forbidCenter = buildForbidSet3D(firstCell, /*includeNeighbors=*/false);

  // “가능하면 확장 유지”
  let forbid = null;

  if (isFeasibleWithForbid3D(forbidExpand, totalB, totalW, capB, capW)) {
    forbid = forbidExpand; // ✅ 첫클릭 확장 보장
  } else if (isFeasibleWithForbid3D(forbidCenter, totalB, totalW, capB, capW)) {
    forbid = forbidCenter; // ✅ 클릭칸만 안전(확장은 포기)
  } else {
    // 여기까지 오면 "클릭칸을 비우고도" 총량이 물리적으로 불가능
    // -> (a) 그래도 클릭칸은 안전 유지, (b) 가능한 최대치로 clamp해서 "총량=실제배치" 일치시키기
    forbid = forbidCenter;

    const avail = (SIZE.x*SIZE.y*SIZE.z) - forbid.size;

    const maxB = Math.max(0, Math.min(totalB, avail * Math.max(0, capB)));
    const maxW = Math.max(0, Math.min(totalW, avail * Math.max(0, capW)));

    // cell-count 제약(혼합 금지): ceil(B/capB)+ceil(W/capW) <= avail
    // 단순하게 W를 줄여 맞추고, 그래도 안되면 B도 줄임
    let b = maxB, w = maxW;
    const needCells = (bb, ww) =>
      (bb>0 ? Math.ceil(bb/Math.max(1,capB)) : 0) + (ww>0 ? Math.ceil(ww/Math.max(1,capW)) : 0);

    while (needCells(b,w) > avail && w > 0) w--;
    while (needCells(b,w) > avail && b > 0) b--;

    if (b !== totalB || w !== totalW) {
      console.warn("[3DMINE] requested mines exceed capacity; clamped:", { reqB: totalB, reqW: totalW, b, w });
      totalB = b; totalW = w;
      // 내부/표시 일관성 위해 CONFIG도 맞춰둠(부모가 init 다시 보내면 그때 갱신됨)
      CONFIG.minesTotal = totalB;
      CONFIG.whiteMinesTotal = totalW;
    }
  }

  const allowed = buildAllowedCoords3D(forbid); // [[x,y,z], ...] (z,y,x 순회)

  // ---- 배치 순서: 검은 -> 흰 (2D와 동일) ----
  placedBlackMines = placeColorEnhanced3D(totalB, capB, /*signNeg=*/false, forbid, allowed, capB, capW);
  placedWhiteMines = placeColorEnhanced3D(totalW, capW, /*signNeg=*/true,  forbid, allowed, capB, capW);

  // 혹시라도(버그/경계) 덜 채워졌으면 CONFIG를 실제와 일치시켜 "항상 맞게" 만듦
  if (placedBlackMines !== totalB) {
    console.warn("[3DMINE] black mismatch; fixing CONFIG to placed", { totalB, placedBlackMines });
    CONFIG.minesTotal = placedBlackMines;
  }
  if (placedWhiteMines !== totalW) {
    console.warn("[3DMINE] white mismatch; fixing CONFIG to placed", { totalW, placedWhiteMines });
    CONFIG.whiteMinesTotal = placedWhiteMines;
  }
}

// ---------- forbid / feasibility ----------
function buildForbidSet3D(firstCell, includeNeighbors){
  const s = new Set();
  s.add(idx(firstCell.x, firstCell.y, firstCell.z));
  if (includeNeighbors){
    for (const n of neighbors26(firstCell)) s.add(idx(n.x, n.y, n.z));
  }
  return s;
}

// 혼합 금지 + cap 제약이 있는 "필요 칸 수" 기반 feasibility(2D에서 쓰는 핵심 조건)
function isFeasibleWithForbid3D(forbidSet, totalB, totalW, capB, capW){
  const totalCells = SIZE.x*SIZE.y*SIZE.z;
  const avail = totalCells - forbidSet.size;

  if (totalB < 0 || totalW < 0) return false;

  // cap==0인데 total>0이면 불가
  if (capB <= 0 && totalB > 0) return false;
  if (capW <= 0 && totalW > 0) return false;

  if (totalB > avail * Math.max(0, capB)) return false;
  if (totalW > avail * Math.max(0, capW)) return false;

  const needB = (totalB>0) ? Math.ceil(totalB/Math.max(1,capB)) : 0;
  const needW = (totalW>0) ? Math.ceil(totalW/Math.max(1,capW)) : 0;

  // 혼합 금지이므로 필요한 “칸 수”가 avail을 넘으면 불가
  if (needB + needW > avail) return false;

  return true;
}

function buildAllowedCoords3D(forbidSet){
  const out = [];
  for (let z=0; z<SIZE.z; z++){
    for (let y=0; y<SIZE.y; y++){
      for (let x=0; x<SIZE.x; x++){
        const id = idx(x,y,z);
        if (forbidSet.has(id)) continue;
        out.push([x,y,z]);
      }
    }
  }
  return out;
}

// ---------- placement helpers (2D port) ----------
function placeColorEnhanced3D(TOTAL, CAP, signNeg, forbidSet, allowedCoords, capB, capW){
  if (TOTAL <= 0 || CAP <= 0) return 0;

  const oppNeg = !signNeg;
  const signCap = (neg) => (neg ? capW : capB);

  const canAdd = (x,y,z, neg) => {
    const c = cells[idx(x,y,z)];
    const v = c.mineValue|0;
    if (neg){
      if (v > 0) return false;            // 혼합 금지
      return Math.abs(v) < CAP;
    } else {
      if (v < 0) return false;
      return Math.abs(v) < CAP;
    }
  };

  const addOne = (x,y,z, neg) => {
    const c = cells[idx(x,y,z)];
    c.mineValue = (c.mineValue|0) + (neg ? -1 : +1);
  };

  const hasNeighborMineSameColorOnly = (x,y,z, neg) => {
    const c = cells[idx(x,y,z)];
    const wantSign = neg ? -1 : +1;
    let hasSame = false;
    for (const n of neighbors26(c)){
      const v = (n.mineValue|0);
      if (v === 0) continue;
      const s = (v > 0) ? +1 : -1;
      if (s !== wantSign) return false;  // 다른 색 있으면 false
      hasSame = true;
    }
    return hasSame;
  };

  let created = 0;

  // ===== 1) 랜덤 뿌리기(클러스터 + "가능하면 n_max") =====
  let n2 = allowedCoords.length * 220 / 480;               // 2D 원본 그대로
  const randStallLimit = Math.max(2000, Math.floor(allowedCoords.length * 8));
  let stall = 0;

  while (created < TOTAL && stall < randStallLimit){
    const pick = allowedCoords[(Math.random()*allowedCoords.length)|0];
    const x = pick[0], y = pick[1], z = pick[2];

    const c = cells[idx(x,y,z)];
    const cur = c.mineValue|0;

    // 혼합 금지
    if ((signNeg && cur > 0) || (!signNeg && cur < 0)) { stall++; continue; }

    const curAbs = Math.abs(cur);
    if (curAbs >= CAP) { stall++; continue; }

    const n_max = Math.min(CAP - curAbs, TOTAL - created);
    let n;
    if ((TOTAL - created) > n2) { n = n_max; n2 -= 0.5; }  // ✅ 6짜리 많이(=max 많이)
    else { n = ((Math.random()*n_max)|0) + 1; }

    // 클러스터링(2D 로직 그대로: n>=2면 확률적으로 “주변 지뢰 없으면 skip”)
    if (n >= 2){
      const p = (n === 2 ? 0.2 :
                n === 3 ? 0.5 :
                n === 4 ? 0.5 :
                n === 5 ? 0.5 :
                n === 6 ? 0.5 : 0);
      if (Math.random() < p){
        if (!hasNeighborMineSameColorOnly(x,y,z, signNeg)){
          stall++; continue;
        }
      }
    }

    c.mineValue = cur + (signNeg ? -n : +n);
    created += n;
    stall = 0;
  }
  if (created >= TOTAL) return created;

  // ===== 2) 선형 스윕으로 보충(칸 하나를 0->CAP까지 끝까지 채우므로 누락 방지) =====
  for (let i=0; i<allowedCoords.length && created < TOTAL; i++){
    const [x,y,z] = allowedCoords[i];
    while (created < TOTAL && canAdd(x,y,z, signNeg)){
      addOne(x,y,z, signNeg);
      created++;
    }
  }
  if (created >= TOTAL) return created;

  // ===== 3) 강제 통합/비우기(상대색을 분산 → 내 색 칸 확보) =====
  // 2D 로직을 3D allowedCoords 기준으로 그대로 이식
  let safety = allowedCoords.length * 4;

  const valAt = (x,y,z) => (cells[idx(x,y,z)].mineValue|0);
  const setAt = (x,y,z,v) => { cells[idx(x,y,z)].mineValue = v|0; };

  while (created < TOTAL && safety-- > 0){
    let freed = null; // [fx,fy,fz, hadAbs]

    // 3-a) 상대색 칸(작은 수량부터) 찾기
    find_source:
    for (let want=1; want<=signCap(oppNeg); want++){
      for (let i=0; i<allowedCoords.length; i++){
        const [sx,sy,sz] = allowedCoords[i];
        const v = valAt(sx,sy,sz);
        if (v === 0) continue;

        // 상대색만
        if (signNeg ? (v <= 0) : (v >= 0)) continue;
        if (Math.abs(v) !== want) continue;

        // 이 칸의 상대색 지뢰를 다른 곳으로 전부 옮길 수 있는지 capacity 체크
        let remain = Math.abs(v);
        const capOpp = signCap(oppNeg);

        for (let j=0; j<allowedCoords.length && remain>0; j++){
          const [tx,ty,tz] = allowedCoords[j];
          if (tx===sx && ty===sy && tz===sz) continue;

          const vv = valAt(tx,ty,tz);

          // oppNeg 색이 수용 가능한 곳(같은 색 또는 빈칸)
          if (oppNeg){
            if (vv > 0) continue; // 혼합 불가
            const room = capOpp - Math.abs(vv);
            if (room > 0) remain -= Math.min(room, remain);
          } else {
            if (vv < 0) continue;
            const room = capOpp - Math.abs(vv);
            if (room > 0) remain -= Math.min(room, remain);
          }
        }

        if (remain <= 0){
          freed = [sx,sy,sz, Math.abs(v)];
          break find_source;
        }
      }
    }

    if (!freed) break;

    const [freedX, freedY, freedZ, freedHad] = freed;

    // 3-b) 실제로 상대색을 분산해 freed 칸 비우기
    {
      let remain = freedHad;
      const capOpp = signCap(oppNeg);

      // (1) 기존 상대색 칸부터 CAP까지 채우기
      for (let j=0; j<allowedCoords.length && remain>0; j++){
        const [tx,ty,tz] = allowedCoords[j];
        if (tx===freedX && ty===freedY && tz===freedZ) continue;

        const vv = valAt(tx,ty,tz);
        // oppNeg 색 or 0만 수용
        if (oppNeg){
          if (vv > 0) continue;
          if (vv < 0){
            const room = capOpp - Math.abs(vv);
            if (room>0){
              const mv = Math.min(room, remain);
              setAt(tx,ty,tz, vv - mv); // vv 음수, 더 음수로
              remain -= mv;
            }
          }
        } else {
          if (vv < 0) continue;
          if (vv > 0){
            const room = capOpp - Math.abs(vv);
            if (room>0){
              const mv = Math.min(room, remain);
              setAt(tx,ty,tz, vv + mv);
              remain -= mv;
            }
          }
        }
      }

      // (2) 부족하면 빈칸을 상대색으로 신규 채우기
      for (let j=0; j<allowedCoords.length && remain>0; j++){
        const [tx,ty,tz] = allowedCoords[j];
        if (tx===freedX && ty===freedY && tz===freedZ) continue;

        const vv = valAt(tx,ty,tz);
        if (vv !== 0) continue;

        const mv = Math.min(capOpp, remain);
        setAt(tx,ty,tz, oppNeg ? -mv : +mv);
        remain -= mv;
      }

      // 원본 칸 비우기(전량 옮겼으므로 0)
      setAt(freedX, freedY, freedZ, 0);
    }

    // 3-c) 비워진 칸에 내 색을 채워 넣기
    while (created < TOTAL && canAdd(freedX,freedY,freedZ, signNeg)){
      addOne(freedX,freedY,freedZ, signNeg);
      created++;
    }
  }

  return created;
}

  function computeAdjValues(){
    for(const c of cells){
      let net=0, absSum=0;
      for(const n of neighbors26(c)){
        net += n.mineValue;
        absSum += Math.abs(n.mineValue);
      }
      c.adjValue = (net===0) ? ((absSum===0)?0:1000) : net;
    }
  }

  function expandTrueZerosFrom(start){
    const q=[start];
    const visited=new Set([idx(start.x,start.y,start.z)]);
    while(q.length){
      const cur=q.shift();
      for(const n of neighbors26(cur)){
        const id=idx(n.x,n.y,n.z);
        if(visited.has(id)) continue;
        visited.add(id);

        if(n.isOpen) continue;
        if(isFlagged(n)) continue;
        if(n.mineValue!==0) continue;
        if(n.markType===MARK_Q) continue;

        n.isOpen=true;
        openedCount++;
        n.cube.visible=false;
        n.content.visible=true;

        if(n._numberSprite){
          n.content.remove(n._numberSprite);
          n._numberSprite=null;
        }

        if(n.adjValue===0){
          q.push(n);
        } else if(n.adjValue===1000){
          const spr=getNumberSprite("0", numberColorByRule(0));
          inheritLayersFromCell(n, spr); 
          spr.userData.cell=n;
          n.content.add(spr);
          n._numberSprite=spr;
        } else {
          const spr=getNumberSprite(String(n.adjValue), numberColorByRule(n.adjValue));
          inheritLayersFromCell(n, spr);
          spr.userData.cell=n;
          n.content.add(spr);
          n._numberSprite=spr;
        }
      }
    }
  }

  function mineCellCount(){ let m=0; for(const c of cells) if(c.mineValue!==0) m++; return m; }
  

  
function autoFlagAllMines(){
  for (const c of cells){
    if (c.mineValue > 0){
      c.markType = MARK_POS;
      c.markCount = Math.min(6, Math.abs(c.mineValue));
      c.applyMarkVisual();
    } else if (c.mineValue < 0){
      c.markType = MARK_NEG;
      c.markCount = Math.min(6, Math.abs(c.mineValue));
      c.applyMarkVisual();
    }
  }
}

function gameOver(hitCell){
  if (gameState === "over" || gameState === "win") return;

  gameState = "over";


  setFace(-1);
  requestPlaySound("gameover.wav");

  // WinXP 스타일로 전체 공개
  revealAfterDeath_WinXP(hitCell);

  stopParentTimer();   // 타이머 정지 & 최종 전송
  updateScore();
}


function checkWin(){
  if (gameState !== "playing") return;

  const totalCells = SIZE.x * SIZE.y * SIZE.z;

  // ✅ “지뢰가 들어있는 칸”의 개수(양/음 모두 포함)
  let mineCells = 0;
  for (const c of cells) if (c.mineValue !== 0) mineCells++;

  const safeCells = totalCells - mineCells;

  // ✅ 승리 조건: 모든 안전칸 오픈
  if (openedCount >= safeCells){
    gameState = "win";


    setFace(-2);
    requestPlaySound("clear.wav");

    // (선택) 남은 지뢰 자동 마킹
    autoFlagAllMines();

    updateScore();
  stopParentTimer();             // ✅ 타이머 정지

  }
}



function updateScore(){


  // 실제 배치된 지뢰 “총 수”는 placedBlackMines / placedWhiteMines (숫자 합)
  let posFlags = 0, negFlags = 0;
  for (const c of cells){
    if (c.markType === MARK_POS) posFlags += (c.markCount|0);
    else if (c.markType === MARK_NEG) negFlags += (c.markCount|0);
  }

  const totalCells = SIZE.x * SIZE.y * SIZE.z;
  let mineCells = 0;
  for (const c of cells) if (c.mineValue !== 0) mineCells++;
  const safeCells = totalCells - mineCells;


      
}

  

  // ===== Chord: “업”에서 실행 (정확히 숫자 스프라이트 클릭) =====
 function getPickNumberCell(ev){
  const rect = __PICK.rect || renderer.domElement.getBoundingClientRect();
  mouseNDC.x=((ev.clientX-rect.left)/rect.width)*2-1;
  mouseNDC.y=-(((ev.clientY-rect.top)/rect.height)*2-1);
  raycaster.setFromCamera(mouseNDC, __PICK.camera || camera);

  const targets=[];
  // ✅ assist면 현재 27셀 범위만 스프라이트 탐색(빠름)
  const srcCells = (__PICK.source === "assist") ? __assistCells : cells;
  for(const c of srcCells){
    if(c && c.isOpen && c._numberSprite) targets.push(c._numberSprite);
  }

  const hits = raycaster.intersectObjects(targets, false);
  if(!hits.length) return null;

  // ✅ assist면 layer로 한 번 더 필터(안전)
  for (const h of hits){
    const obj = h.object;
    if (!obj) continue;
    if (__PICK.source === "assist"){
      if (!obj.layers.test(assistCamera.layers)) continue;
    } else {
      if (!obj.layers.test(camera.layers)) continue;
    }
    return obj.userData.cell || null;
  }
  return null;
}


  let chordCenterPicked = null;
  function chordExecute(ev, forcedCell=null){
  if(gameState!=="playing") return false;

  const cell = forcedCell || getPickNumberCell(ev);
  setFocusedCell(cell);

  if(!cell) return false;

  const shown = (cell.adjValue===1000) ? 0 : cell.adjValue;

  let sumFlags=0, absFlags=0;
  const neigh=neighbors26(cell);
  for(const n of neigh){
    sumFlags += flagSignedCount(n);
    absFlags += flagAbsCount(n);
  }

  if(shown===0){
    if(absFlags===0) return true;
    if(sumFlags!==0) return true;
    for(const n of neigh){
      if(n.isOpen) continue;
      if(isFlagged(n)) continue;
      n.openFromChord();
    }
    return true;
  }

  if(sumFlags!==shown) return true;

  for(const n of neigh){
    if(n.isOpen) continue;
    if(isFlagged(n)) continue;
    n.openFromChord();
  }
  return true;
}
let focusOutline = null;
let focusedCell = null;
let __focusOutlineTimer = null;
let __focusOutlineToken = 0;

const __tmpV3 = new THREE.Vector3();
let leftDownAxis = null;        // ✅ assist 축 삼각뿔 down 저장용
let __lastClickSource = "main"; // ✅ 마지막 클릭이 main/assist 중 어디였는지
function __focusFromPress(cell){
  if (!cell || cell.__axis) return;     // axis는 제외(메인엔 어차피 없음)
  __lastClickSource = __PICK.source;    // main/assist 구분
  setFocusedCell(cell);                 // 여기서 outline 위치/표시 규칙이 적용됨
}

function createFocusOutline(){
  const geo = new THREE.EdgesGeometry(new THREE.BoxGeometry(1.03, 1.03, 1.03));
  const mat = new THREE.LineBasicMaterial({ color: 0x000000 });
  mat.depthTest = true;   // 큐브가 없어도, 다른 것 뒤여도 선이 보이게
  mat.depthWrite = false;

  focusOutline = new THREE.LineSegments(geo, mat);
  focusOutline.visible = false;
  focusOutline.renderOrder = 10000;
  focusOutline.frustumCulled = false;
  scene.add(focusOutline);
}
function __updateFocusOutlineVisibility(){
  if (!focusOutline) return;

  // 기존 타이머 정리
  if (__focusOutlineTimer){
    clearTimeout(__focusOutlineTimer);
    __focusOutlineTimer = null;
  }

  if (!focusedCell){
    focusOutline.visible = false;
    return;
  }

  // assist면 계속 표시
  if (__lastClickSource === "assist"){
    focusOutline.visible = true;
    return;
  }

  // main이면 1초만 표시 후 숨김
  if (__lastClickSource === "main"){
    focusOutline.visible = true;

    const myToken = ++__focusOutlineToken;
    const myCell = focusedCell;

    __focusOutlineTimer = setTimeout(() => {
      // 그 사이에 다른 이벤트/포커스 변화가 있었으면 무시
      if (myToken !== __focusOutlineToken) return;
      if (__lastClickSource !== "main") return;
      if (focusedCell !== myCell) return;

      focusOutline.visible = false;
      __focusOutlineTimer = null;
    }, 100);

    return;
  }

  // 그 외는 숨김
  focusOutline.visible = false;
}


function createAxisPyramids(){
  const g = new THREE.Group();
  g.visible = false;

  const geo = new THREE.ConeGeometry(0.35, 0.55, 4); // ✅ 삼각뿔 느낌(4면)
  const mat = new THREE.MeshStandardMaterial({ color:0x8a8a8a, roughness:0.8, metalness:0.0 });

  // ConeGeometry는 기본이 +Y 방향이 “뾰족”
  const dirs = [
    { name:"+X", dx:+1, dy:0, dz:0, wdir:new THREE.Vector3(+1,0,0) },
    { name:"-X", dx:-1, dy:0, dz:0, wdir:new THREE.Vector3(-1,0,0) },

    // 논리 y(행)는 world Z
    { name:"+Y", dx:0, dy:+1, dz:0, wdir:new THREE.Vector3(0,0,+1) },
    { name:"-Y", dx:0, dy:-1, dz:0, wdir:new THREE.Vector3(0,0,-1) },

    // 논리 z(깊이)는 world Y
    { name:"+Z", dx:0, dy:0, dz:+1, wdir:new THREE.Vector3(0,+1,0) },
    { name:"-Z", dx:0, dy:0, dz:-1, wdir:new THREE.Vector3(0,-1,0) },
  ];

  const up = new THREE.Vector3(0,1,0);

  for (const d of dirs){
    const m = new THREE.Mesh(geo, mat.clone());
    m.userData.pickType = "axis";
    m.userData.dir = { dx:d.dx, dy:d.dy, dz:d.dz };
    m.userData.wdir = d.wdir.clone().normalize();
    m.quaternion.setFromUnitVectors(up, m.userData.wdir); // 방향 회전
    __AXIS_PICKABLES.push(m);
    g.add(m);
  }

  // 보조창 전용 레이어
    // ✅ "보조창 전용": layer를 enable이 아니라 set으로 고정
  g.traverse((o)=>{
    if (o.layers) o.layers.set(L_ASSIST_UI);  // layer 2 ONLY
  });
  return g;
}

function updateAxisPyramids(){
  if (!axisGroup) return;

  if (!focusedCell){
    axisGroup.visible = false;
    return;
  }

  focusedCell.group.getWorldPosition(__tmpV3);

  const offset = SPACING * 1.2; // 중심으로부터 거리
  let anyVisible = false;

  for (const m of axisGroup.children){
    const d = m.userData?.dir;
    if (!d){ m.visible = false; continue; }

    const nx = (focusedCell.x + (d.dx|0))|0;
    const ny = (focusedCell.y + (d.dy|0))|0;
    const nz = (focusedCell.z + (d.dz|0))|0;

    const canMove = inBounds(nx, ny, nz);

    // ✅ 이동 불가면 아예 안 뜸
    m.visible = !!canMove;

    if (canMove){
      anyVisible = true;
      const wdir = m.userData.wdir;
      m.position.copy(__tmpV3).addScaledVector(wdir, offset);
    }
  }

  // ✅ 6방향 모두 이동 불가면 axisGroup 자체 숨김 (ex: 1*1*1)
  axisGroup.visible = anyVisible;
}

function moveFocusByAxis(dx,dy,dz){
  if (!focusedCell) return;
  const nx = focusedCell.x + dx;
  const ny = focusedCell.y + dy;
  const nz = focusedCell.z + dz;
  if (!inBounds(nx,ny,nz)) return;
  setFocusedCell(cells[idx(nx,ny,nz)]);
}

function updateAssistNeighborhood(centerCell){
  // 1) 이전 layer1 끄기
  for (const c of __assistPrevCells){
    if (!c) continue;
    setLayerRecursive(c.group, L_ASSIST_CELLS, false);
  }
  __assistPrevCells = [];
  __assistCells = [];

  if (!centerCell) {
    if (axisGroup) axisGroup.visible = false;
    return;
  }

  // 2) 중심 포함 27(경계면 더 적음)
  for (let dz=-1; dz<=1; dz++){
    for (let dy=-1; dy<=1; dy++){
      for (let dx=-1; dx<=1; dx++){
        const x = centerCell.x + dx;
        const y = centerCell.y + dy;
        const z = centerCell.z + dz;
        if (!inBounds(x,y,z)) continue;
        const c = cells[idx(x,y,z)];
        if (!c) continue;
        __assistCells.push(c);
      }
    }
  }

  // 3) 해당 셀들 layer1 켜기
  for (const c of __assistCells){
    setLayerRecursive(c.group, L_ASSIST_CELLS, true);
    __assistPrevCells.push(c);
  }

  // 4) 삼각뿔 UI 갱신
  updateAxisPyramids();
}

function setFocusedCell(cell){
  focusedCell = cell;
  if (!focusOutline) return;

if (!cell){
  focusOutline.visible = false;
  updateAssistNeighborhood(null);
  return;
}

  cell.group.getWorldPosition(__tmpV3);
  focusOutline.position.copy(__tmpV3);
  __updateFocusOutlineVisibility();

  updateAssistNeighborhood(cell);    // ✅ 추가
}

  // ===== 클릭(큐브) 피킹: visible=true만 선택 (안보이는 큐브가 가로채지 못함) =====
function getPickCell(ev){
  const rect = __PICK.rect || renderer.domElement.getBoundingClientRect();
  mouseNDC.x=((ev.clientX-rect.left)/rect.width)*2-1;
  mouseNDC.y=-(((ev.clientY-rect.top)/rect.height)*2-1);
  raycaster.setFromCamera(mouseNDC, __PICK.camera || camera);

  // ✅ assist는 삼각뿔도 피킹 대상
  const targets = (__PICK.source === "assist")
    ? (__AXIS_PICKABLES.concat(__FLAG_PICKABLES, cubeMeshes))
    : (__FLAG_PICKABLES.concat(cubeMeshes));

  const hits = raycaster.intersectObjects(targets, false);
  if(!hits.length) return null;

  for(const h of hits){
    const obj = h.object;
    if(!obj) continue;
    if(!__isDeepVisible(obj)) continue;

    // ✅ layer 필터
    if (__PICK.source === "assist"){
      if (!obj.layers.test(assistCamera.layers)) continue;
    } else {
      if (!obj.layers.test(camera.layers)) continue;
    }

    // ✅ 삼각뿔 클릭
    if (obj.userData.pickType === "axis"){
      return { __axis:true, dir: obj.userData.dir };
    }

    const c = obj.userData.cell || null;
    if(!c) continue;

    if(obj.userData.pickType === "flag"){
      return c;
    }
    if(obj === c.cube){
      if(isFlagged(c)) continue;
      return c;
    }
    if(!isFlagged(c)) return c;
  }
  return null;
}

  // ===== pressed/chord 상태 정리 =====
  function clearPressedAndChord(){
    if(leftDownCell && leftPressedApplied){
      leftDownCell.setPressed(false);
    }
    leftDownCell = null;
    leftPressedApplied = false;
    setChordHighlight(false, null);
    chordArmed = false;
    chordKind = null;
    chordPointerId = null;
    leftCanceledByChord = false;
middleStartXY = null;
middleMoved = false;
leftDownAxis = null;
  }
function updateAssistCamera(){
  if (!assistCamera || !assistRenderer) return;

  const w = assistEl.clientWidth|0;
  const h = assistEl.clientHeight|0;
  if (w <= 2 || h <= 2) return;

  // 캔버스 리사이즈(필요할 때만)
  const needResize = (assistCanvas.width !== Math.floor(w*devicePixelRatio)) || (assistCanvas.height !== Math.floor(h*devicePixelRatio));
  if (needResize){
    assistRenderer.setSize(w, h, false);
    assistCamera.aspect = w / h;
    assistCamera.updateProjectionMatrix();
  }

  // focused 기준으로 target 잡고, 메인 orbit의 방향(theta/phi/roll)은 공유
  const target = __tmpV3;
  if (focusedCell) focusedCell.group.getWorldPosition(target);
  else target.set(0,0,0);

  const r = SPACING * 4.2; // 주변 3x3x3이 들어오는 적당한 거리
  const eps = 0.05;
  const phi = clamp(orbit.phi, eps, Math.PI - eps);

  const sinPhi = Math.sin(phi);
  const x = r * sinPhi * Math.cos(orbit.theta);
  const y = r * Math.cos(phi);
  const z = r * sinPhi * Math.sin(orbit.theta);

  assistCamera.position.set(target.x + x, target.y + y, target.z + z);

  __tmpForward.subVectors(target, assistCamera.position).normalize();
  __tmpUp.set(0,1,0).applyAxisAngle(__tmpForward, orbit.roll || 0);
  assistCamera.up.copy(__tmpUp);
  assistCamera.lookAt(target);
}

  // ===== init =====
init();

// iframe(부모가 존재)에서 열렸으면 init 받을 때까지 기본 보드 만들지 않음
if (window.parent === window) {
  // 단독 실행(직접 열기)일 땐 기존처럼 기본 보드
  resetGame();
} else {
  // 임베드 실행이면: 화면 비워두고(또는 오버레이) init 기다림
  showOverlay(true);
  overlayEl.querySelector('.box').textContent = 'Loading…';

  // 혹시 init이 안 오는 경우 대비(선택)
  __BRIDGE.bootTimeout = setTimeout(() => {
    // fallback: 그래도 기본 보드라도 띄우고 싶으면
    resetGame();
    showOverlay(false);
  }, 800);
}


  function init(){
    renderer=new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    scene=new THREE.Scene();
    scene.fog=new THREE.Fog(0xC0C0C0, 18, 260);


    camera=new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 900);

    scene.add(new THREE.AmbientLight(0xffffff, 0.65));
    const dir=new THREE.DirectionalLight(0xffffff, 1.0);
    dir.position.set(12,24,10);
    scene.add(dir);
    for (const obj of scene.children){
  if (obj && obj.isLight){
    obj.layers.enable(L_ASSIST_CELLS);
    obj.layers.enable(L_ASSIST_UI);
  }
}
createFocusOutline();
// ===== assist renderer/camera =====
assistCanvas = document.getElementById("assist-canvas");
assistRenderer = new THREE.WebGLRenderer({ canvas: assistCanvas, antialias:true, alpha:false });
assistRenderer.setPixelRatio(devicePixelRatio);
assistRenderer.setClearColor(0xC0C0C0, 1);

assistCamera = new THREE.PerspectiveCamera(60, 1, 0.1, 900);
assistCamera.layers.set(L_ASSIST_CELLS);
assistCamera.layers.enable(L_ASSIST_UI);

axisGroup = createAxisPyramids();
scene.add(axisGroup);
    window.addEventListener("resize", onResize);

renderer.domElement.addEventListener("pointermove", (ev)=>{ __setPickContext("main", renderer.domElement); onPointerMove(ev); });
renderer.domElement.addEventListener("pointerdown", (ev)=>{ __setPickContext("main", renderer.domElement); onPointerDown(ev); });
renderer.domElement.addEventListener("pointerup",   (ev)=>{ __setPickContext("main", renderer.domElement); onPointerUp(ev); });
renderer.domElement.addEventListener("wheel", (ev)=>{ __setPickContext("main", renderer.domElement); onWheel(ev); }, { passive:false });

    renderer.domElement.addEventListener("contextmenu", (e)=>e.preventDefault());

    renderer.domElement.addEventListener("pointercancel", (ev)=>{
  if (__ptrStart.get(__PICK.source+"|"+ev.pointerId)) __releaseAllInputs(ev.pointerId);});
// ===== assist input bind (same handlers, different pick context) =====
assistCanvas.addEventListener("pointermove", (ev)=>{ __setPickContext("assist", assistCanvas); onPointerMove(ev); });
assistCanvas.addEventListener("pointerdown", (ev)=>{ __setPickContext("assist", assistCanvas); onPointerDown(ev); });
assistCanvas.addEventListener("pointerup",   (ev)=>{ __setPickContext("assist", assistCanvas); onPointerUp(ev); });
assistCanvas.addEventListener("pointercancel",(ev)=>{ __setPickContext("assist", assistCanvas); 
  if (__ptrStart.get(__PICK.source+"|"+ev.pointerId)) __releaseAllInputs(ev.pointerId);
});
assistCanvas.addEventListener("contextmenu", (e)=>e.preventDefault());
assistCanvas.addEventListener("wheel", (ev)=>{ __setPickContext("assist", assistCanvas); onWheel(ev); }, { passive:false });

    renderer.domElement.style.touchAction = "none";

// iOS/일부 브라우저에서 스와이프/스크롤 제스처가 살아있는 경우를 강제로 차단
renderer.domElement.addEventListener("touchmove", (e) => {
  e.preventDefault();
}, { passive: false });

// ✅ Middle-click auto-scroll(스크롤 아이콘) 방지: Chrome/Edge/Firefox 공통
const stopMiddleAutoScroll = (e) => {
  if (e.button === 1) {          // middle
    e.preventDefault();
    e.stopPropagation();
    return false;
  }
};

// 캡처링 + passive:false 가 중요
renderer.domElement.addEventListener("mousedown", stopMiddleAutoScroll, { capture:true, passive:false });
renderer.domElement.addEventListener("auxclick",  stopMiddleAutoScroll, { capture:true, passive:false });
renderer.domElement.addEventListener("mouseup",   stopMiddleAutoScroll, { capture:true, passive:false });

    updateCameraOrbit();
    animate();
    updateScore();
    markBridgeReady();
  }

  function resetGame(){
    setFocusedCell(null);
__focusOutlineToken++; // 진행 중 타이머 무효화

    stopParentTimer(false);
  __elapsed = 0;
  postToParent({ __mine3d:1, type:'timer', elapsed: 0 });
    const old=scene.getObjectByName("BOARD");
    if(old) scene.remove(old);

    const oldGrid=scene.getObjectByName("GRID");
    if(oldGrid) scene.remove(oldGrid);

    const grid=new THREE.GridHelper(
      Math.max(SIZE.x, SIZE.y)*SPACING*3,
      Math.max(SIZE.x, SIZE.y)*3,
      0x2a2a2a, 0x1f1f1f
    );
    grid.position.y = -SIZE.z*SPACING*0.5 - 2.2; // ✅ 깊이(SIZE.z)가 위/아래 축이 됨

    grid.name="GRID";

    scene.add(grid);

    cells=[]; cubeMeshes=[];
    firstOpen=true; gameState="ready";
    openedCount=0; hoverCell=null;
    placedBlackMines=0; placedWhiteMines=0;

    _is_generating = false;
    showOverlay(false);
    clearPressedAndChord();

    
setFace(0); // ✅ reset은 항상 normal

    const board=new THREE.Group();
    board.name="BOARD";
    scene.add(board);
    const ox=-(SIZE.x-1)*SPACING*0.5; // cols -> X
    const oy=-(SIZE.z-1)*SPACING*0.5; // depths -> Y (위로 쌓임)
    const oz=-(SIZE.y-1)*SPACING*0.5; // rows -> Z


    for(let z=0; z<SIZE.z; z++){
      for(let y=0; y<SIZE.y; y++){
        for(let x=0; x<SIZE.x; x++){
          const pos=new THREE.Vector3(ox + x*SPACING,  oy + z*SPACING,   oz + y*SPACING   );
          const c=new Cell(x,y,z,pos);
          cells[idx(x,y,z)]=c;
          board.add(c.group);
          cubeMeshes.push(c.cube);
        }
      }
    }

    const span=Math.max(SIZE.x,SIZE.y,SIZE.z)*SPACING;
    orbit.target.set(0,0,0);
    orbit.radius=clamp(span*2.2, orbit.minRadius, orbit.maxRadius);
    orbit.theta=0.9;
    orbit.phi=1.0;
    updateCameraOrbit();

    updateScore();
    sendCountersToParent();

  }

  function onResize(){
    camera.aspect=innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  }
let leftDownNumberCell = null;
  // ===== 입력 규칙(요청 반영) =====
  function onPointerDown(ev){
    // 메인영역 밖(보조창 포함)에서 시작한 입력은 메인에 전달하지 않음
if (!renderer) return;
if (!__isInActiveArea(ev.clientX, ev.clientY)) return;

// 이 pointer는 메인에서 시작
__ptrStart.set(__PICK.source+"|"+ev.pointerId, true);


  // ===== 모바일 터치 전용 =====
  if (IS_MOBILE && ev.pointerType === "touch") {
  (ev.currentTarget || renderer.domElement).setPointerCapture(ev.pointerId);

  // 멀티터치 상태 업데이트
  t2_setPointer(ev);

  // 2손가락 이상이면: 즉시 제스처 모드 진입(핀치/팬)
  if (TOUCH2.pointers.size >= 2) {
    if (TOUCH2.mode !== "gesture") t2_enterGesture();
    // 제스처 중엔 얼굴도 눌림(게임 살아있으면)
    if (!(gameState === "over" || gameState === "win")) setFace(2);
    return;
  }

  // 여기부터는 1손가락 단일 터치(기존 로직)
  const dead = (gameState === "over" || gameState === "win");
  if (!dead) setFace(2);

  // 제스처 직후 새 터치 시작이면 플래그 정리
  TOUCH2.justGesture = false;
  TOUCH2.mode = "none";

  resetTouchState();
  TOUCH.active = true;
  TOUCH.pointerId = ev.pointerId;
  TOUCH.startX = TOUCH.lastX = ev.clientX;
  TOUCH.startY = TOUCH.lastY = ev.clientY;

  TOUCH.downCell = dead ? null : getPickCell(ev);
  if (TOUCH.downCell && !TOUCH.downCell.isOpen) {
    __focusFromPress(TOUCH.downCell);  
    TOUCH.downCell.setPressed(true);
    TOUCH.pressedApplied = true;

    TOUCH.longPressTimer = setTimeout(() => {
      if (!TOUCH.active) return;
      if (TOUCH.rotate) return;
      if (gameState === "over" || gameState === "win") return;

      const c = TOUCH.downCell;
      if (!c || c.isOpen) return;

      c.cycleMark();
      TOUCH.longPressFired = true;

      if (TOUCH.pressedApplied) c.setPressed(false);
      TOUCH.pressedApplied = false;
    }, 520);
  }
  return;
}

    // ✅ 좌/중 클릭이 발생하면(다운) 눌린 얼굴
if ((ev.button === 0 || ev.button === 1) && !(gameState === "over" || gameState === "win")) {
  setFace(2);
}

  (__PICK.dom || renderer.domElement).setPointerCapture(ev.pointerId); // ✅ main/assist 모두 정상

  const dead = (gameState === "over" || gameState === "win");

  // ===== RIGHT DOWN: 즉시 마킹(단, chord면 마킹 금지) =====
  if(ev.button === 2){
  rightDown = true;

  // (A) 이미 leftDown이라면: "좌->우" LR chord 시도 (기존 유지)
  const numCell = (gameState==="playing") ? getPickNumberCell(ev) : null;
  rightDownNumberCell = numCell;

  if (leftDown) {
    leftCanceledByChord = true;

    const center =
      numCell || leftDownNumberCell || getPickCell(ev) || leftDownCell;

    if (center) {
      __lastClickSource = __PICK.source;  
      lrChordActive = true;
      lrChordCenter = center;
      chordKind = "lr";
      setChordHighlight(true, center);
    }
    return; // LR chord일 땐 마킹/팬 로직 안 탐
  }
  // (B) ✅ 우클릭 단독: 드래그하면 pan, 클릭(짧게)하면 마킹
  const dead = (gameState === "over" || gameState === "win");
  rightDownCell = dead ? null : getPickCell(ev);
if (rightDownCell && !rightDownCell.__axis) {
  __focusFromPress(rightDownCell);     // ✅ 큐브/깃발 눌림이면 테두리 이동
}
  rightStartXY = [ev.clientX, ev.clientY];
  rightMoved = false;
  rightPanLastX = ev.clientX;
  rightPanLastY = ev.clientY;

  // ✅ 더 이상 우클릭 회전(rotDown) 없음
  rotDown = false;
  return;
}

  // ===== LEFT DOWN: 눌림 피드백(또는 chord 준비) =====
  if(ev.button === 0){
        

  leftDown = true;
  leftCanceledByChord = false;
  leftDownXY = [ev.clientX, ev.clientY];

  // ★ 숫자 먼저 피킹
  const numCell = (gameState === "playing") ? getPickNumberCell(ev) : null;
  leftDownNumberCell = numCell;

  // 큐브 피킹(열린 숫자는 null)
  leftDownCell = getPickCell(ev);
  // ✅ assist 삼각뿔이면: 셀 pressed/회전/chord로 들어가지 말고 down만 기록
if (leftDownCell && leftDownCell.__axis){
  leftDownAxis = leftDownCell;
  leftDownCell = null;
  leftPressedApplied = false;
  return;
}
// (1) Shift+좌클릭 chord (중클릭과 동일)
 if (ev.shiftKey) {
  leftCanceledByChord = true;

  // ✅ 숫자 스프라이트가 우선, 없으면 큐브 셀(닫힌 큐브 포함)
  const center = numCell || leftDownCell;

  if (center) {
    __lastClickSource = __PICK.source;
    chordArmed = true;
    chordKind = numCell ? "shiftLeft" : "shiftLeftCube"; // ✅ 큐브면 실행 없이 하이라이트만
    chordPointerId = ev.pointerId;
    setChordHighlight(true, center);
  }

  // 회전으로 빠지지 않게 종료
  return;
}
  // (2) 열린 숫자 위를 그냥 좌클릭한 경우: 회전으로 보내지 말고 무시(권장)
  if (numCell && !leftDownCell) {
    __focusFromPress(numCell);
    return;
  }

  // (3) 여기서부터 배경회전 처리
  if (!leftDownCell) {
    leftRotDown = true;
    rotStartX = rotLastX = ev.clientX;
    rotStartY = rotLastY = ev.clientY;
    return;
  }
  if (dead) return;
    // (E) 일반 좌클릭: down에서는 pressed만(한 칸 70%), 실제 처리는 up
    if(leftDownCell){
       __focusFromPress(leftDownCell);
      leftDownCell.setPressed(true);
      leftPressedApplied = true;
    }
    return;
  }

  // ===== MIDDLE DOWN: 숫자면 chord, 아니면 "큐브 chord 시도" + 드래그 pan 가능 =====
  if(ev.button === 1){
    ev.preventDefault();
    if (dead){
      // 죽었으면 pan만 가능 (큐브/숫자 chord는 금지)
      panDown = true;
      panLastX = ev.clientX;
      panLastY = ev.clientY;
      return;
    }

    middleDown = true;
    middleStartXY = [ev.clientX, ev.clientY];
    middleMoved = false;

    if(gameState==="playing"){
      const numCell = getPickNumberCell(ev);
      if(numCell){
        __lastClickSource = __PICK.source;
        chordArmed = true;
        chordKind = "middle";
        chordPointerId = ev.pointerId;
         chordCenterPicked = numCell;
        setChordHighlight(true, numCell);
        panDown = false;
        return;
      }
    }

    // 숫자 아니면: 큐브를 chord “시도”로 취급(주변만 70%),
    // 단 드래그하면 pan으로 전환
    const cubeCell = getPickCell(ev);
if (cubeCell && !cubeCell.__axis) {
  __lastClickSource = __PICK.source;
      chordArmed = true;
      chordKind = "middleCube"; // ★ 실행은 안 함
      chordPointerId = ev.pointerId;
      setChordHighlight(true, cubeCell);
    }
    panDown = true;
    panLastX = ev.clientX;
    panLastY = ev.clientY;
    return;
  }
}

  function onPointerUp(ev){
    // ===== 모바일 터치 전용 =====
  if (IS_MOBILE && ev.pointerType === "touch") {

  // 멀티터치 상태에서 pointer 제거
  if (TOUCH2.pointers.has(ev.pointerId)) t2_delPointer(ev);

  // 제스처 중이었으면: 탭/롱프레스 처리 없이 종료만
  if (TOUCH2.mode === "gesture") {
    clearLongPress();

    // 아직 2손가락 유지 중이면 계속 제스처
    if (TOUCH2.pointers.size >= 2) return;

    // 1손가락만 남았으면: '회전 모드'로 전환(탭 방지)
    if (TOUCH2.pointers.size === 1) {
      const [pid, p] = TOUCH2.pointers.entries().next().value;

      resetTouchState();
      TOUCH.active = true;
      TOUCH.pointerId = pid;
      TOUCH.startX = TOUCH.lastX = p.x;
      TOUCH.startY = TOUCH.lastY = p.y;

      TOUCH.rotate = true;         // 남은 손가락은 드래그 회전으로만 취급(탭 금지)
      TOUCH.longPressFired = true; // 탭 금지 강화

      TOUCH2.mode = "none";
      // justGesture는 true 유지(남은 손가락이 곧 떼질 때 오픈 방지)
      if (!(gameState === "over" || gameState === "win")) setFace(0);
      return;
    }

    // 손가락 모두 떼면 완전 종료
    TOUCH2.mode = "none";
    if (!(gameState === "over" || gameState === "win")) setFace(0);
    resetTouchState();
    TOUCH2.justGesture = false;
    return;
  }

  // 제스처 직후 남은 1손가락 up: 탭 처리 금지
  if (TOUCH2.justGesture) {
    if (!(gameState === "over" || gameState === "win")) setFace(0);
    resetTouchState();
    TOUCH2.justGesture = false;
    return;
  }

  // ====== 여기부터는 기존 단일 터치 UP 로직(거의 그대로) ======
  if (!TOUCH.active || ev.pointerId !== TOUCH.pointerId) return;

  clearLongPress();

  if (TOUCH.downCell && TOUCH.pressedApplied) {
    TOUCH.downCell.setPressed(false);
    TOUCH.pressedApplied = false;
  }

  if (TOUCH.rotate) {
    if (!(gameState === "over" || gameState === "win")) setFace(0);
    resetTouchState();
    return;
  }

  if (TOUCH.longPressFired) {
    if (!(gameState === "over" || gameState === "win")) setFace(0);
    resetTouchState();
    return;
  }

  const now = performance.now();

  if (gameState === "playing") {
    const numCell = getPickNumberCell(ev);
    if (numCell) {
      const isDouble =
        lastTap.onNumber &&
        (now - lastTap.t) <= DOUBLE_TAP_MS &&
        (Math.hypot(ev.clientX - lastTap.x, ev.clientY - lastTap.y) <= DOUBLE_TAP_DIST);

      if (isDouble) {
        chordExecute(ev);
        lastTap = { t:0, x:0, y:0, onNumber:false };
        if (!(gameState === "over" || gameState === "win")) setFace(0);
        resetTouchState();
        return;
      } else {
        lastTap = { t: now, x: ev.clientX, y: ev.clientY, onNumber:true };
        if (!(gameState === "over" || gameState === "win")) setFace(0);
        resetTouchState();
        return;
      }
    }
  }

  const upCell = getPickCell(ev);
  if (upCell && TOUCH.downCell && upCell === TOUCH.downCell) {
    upCell.openFromClick();
  }

  if (!(gameState === "over" || gameState === "win")) setFace(0);
  lastTap = { t:0, x:0, y:0, onNumber:false };
  resetTouchState();
  return;
}
// 메인에서 시작한 클릭이라도 메인 안에서 끝난 경우만 유효
if (!__ptrStart.get(__PICK.source+"|"+ev.pointerId)) return; // 메인에서 시작한 게 아니면 무시

if (!__isInActiveArea(ev.clientX, ev.clientY)) {
  __releaseAllInputs(ev.pointerId);
  return;
}

// 정상 up이면 여기서부터 기존 로직 계속
__ptrStart.delete(__PICK.source + "|" + ev.pointerId);

  
// ★ on_up 흐름: 생성 중이면 리셋 금지
    // (원본처럼, up에서 상태 리셋/pressed 해제를 막아야 함)
    const dead = (gameState === "over" || gameState === "win");
    if (dead){
      // 드래그 상태만 정리하고, 셀 동작/pressed/chord는 절대 실행하지 않음
      if (ev.button === 0){
        leftDown = false;
        leftRotDown = false;
        if (lrChordActive) {
          chordExecute(null, lrChordCenter);   // ★ forcedCell
          lrChordActive = false;
          lrChordCenter = null;
          setChordHighlight(false, null);
          on_up_global();
          clearPressedAndChord();
          return;
        }
        if (leftDownCell && leftPressedApplied) leftDownCell.setPressed(false);
      }
      if (ev.button === 1){
        middleDown = false;
        panDown = false;
      }
      if (ev.button === 2){
        rightDown = false;
        rotDown = false;
        if (lrChordActive) {
    // 우클릭 마킹 금지
    rightDownCell = null;
    rightMoved = false;

    // 둘 다 올라갔으면 실행/정리
    
      chordExecute(null, lrChordCenter);   // ★ forcedCell로 실행
      lrChordActive = false;
      lrChordCenter = null;
      setChordHighlight(false, null);
      on_up_global();
      clearPressedAndChord();
    
      return;
    }
      }
      clearPressedAndChord();
      return;
    }

    const wasGenerating = _is_generating;

   if(ev.button === 2){
  rightDown = false;
  rotDown = false; // 남아있으면 정리만

  if(!wasGenerating) on_up_global();

  // ✅ LR chord 해제(기존 유지)
  if(!wasGenerating && chordArmed && chordKind==="lr"){
    setChordHighlight(false, null);
    chordArmed = false;
    chordKind = null;
    chordPointerId = null;
    leftCanceledByChord = false;

    // chord였으면 우클릭 클릭 마킹도 하지 않음
    rightDownCell = null;
    rightStartXY = null;
    rightMoved = false;
    return;
  }

  // ✅ 우클릭 "클릭"이면 마킹 (드래그 했으면 마킹 안 함)
  if(!wasGenerating && !rightMoved && rightDownCell && !(gameState === "over" || gameState === "win")){
    const upCell = getPickCell(ev);
    if (upCell && upCell === rightDownCell){
      rightDownCell.cycleMark();
    }
  }

  rightDownCell = null;
  rightStartXY = null;
  rightMoved = false;
  return;
}

if(ev.button === 1){
  middleDown = false;

  if(!wasGenerating){
    if(chordArmed && chordKind==="middle"){
      chordExecute(ev, chordCenterPicked);  // ✅ forced
    }
    // middleCube는 "시도만" 이므로 실행 없음

    panDown = false;
      if (gameState === "over" || gameState === "win"){
    clearPressedAndChord();
    return;
  }
    on_up_global();
    clearPressedAndChord(); // 여기서 하이라이트 원복됨
  }
  return;
}


    if(ev.button === 0){
      if (leftRotDown){
    leftRotDown = false;
    leftDown = false;

    if(!wasGenerating) on_up_global();
    clearPressedAndChord();
    return;
  }
  leftDown = false;

  if(!wasGenerating && leftDownCell && leftPressedApplied){
    leftDownCell.setPressed(false);
  }
  if(wasGenerating) return;

  const dist = leftDownXY ? Math.hypot(ev.clientX-leftDownXY[0], ev.clientY-leftDownXY[1]) : 0;

  // chord 모드(Shift/LR): 버튼을 떼는 순간 "숫자 위"면 실행, 아니면 아무 일 없음
  if(chordArmed && (chordKind==="shiftLeft" || chordKind==="lr")){
    chordExecute(ev);          // 숫자 아니면 false로 끝
      if (gameState === "over" || gameState === "win"){
    clearPressedAndChord();
    return;
  }
    on_up_global();
    clearPressedAndChord();
    return;
  }

  // chord로 취소된 좌클릭이면 아무 것도 안 함
  if(leftCanceledByChord){
    on_up_global();
    clearPressedAndChord();
    return;
  }

  // 일반 좌클릭: up에서 처리
  const upCell = getPickCell(ev);
  // ✅ assist의 삼각뿔 클릭이면 포커스 이동
// ✅ assist의 삼각뿔 클릭이면 포커스 이동 (down→up 동일 축일 때만)
if (upCell && upCell.__axis){
  if (leftDownAxis && leftDownAxis.__axis){
    const a = leftDownAxis.dir, b = upCell.dir;
    const same =
      ((a.dx|0)===(b.dx|0)) && ((a.dy|0)===(b.dy|0)) && ((a.dz|0)===(b.dz|0));
    if (same){
      moveFocusByAxis(b.dx|0, b.dy|0, b.dz|0);
    }
  } else {
    // down 기록이 없더라도(예외 케이스) 클릭이면 이동 허용
    const d = upCell.dir;
    moveFocusByAxis(d.dx|0, d.dy|0, d.dz|0);
  }
  leftDownAxis = null;
  clearPressedAndChord();
  return;
}


  if(dist <= MOVE_CANCEL_PX && upCell && leftDownCell && upCell === leftDownCell){
    upCell.openFromClick();
  }
// ✅ openFromClick 도중 gameOver/win이 될 수 있음 → 끝났으면 0으로 덮어쓰지 않음
if (gameState === "over" || gameState === "win"){
  clearPressedAndChord();
  return;
}
  on_up_global();
  clearPressedAndChord();
  return;
}

  }

  function onPointerMove(ev){
    // 메인에서 시작한 포인터가 메인영역을 벗어나는 순간: 즉시 release
if (__ptrStart.get(__PICK.source+"|"+ev.pointerId)) {
  if (!__isInActiveArea(ev.clientX, ev.clientY)) {
    __releaseAllInputs(ev.pointerId);
    return;
  }
}

   if (IS_MOBILE && ev.pointerType === "touch") {
    function normAngleDelta(a){
      while (a >  Math.PI) a -= Math.PI * 2;
      while (a < -Math.PI) a += Math.PI * 2;
      return a;
    }
  // 위치 갱신(해당 pointerId만)
  if (TOUCH2.pointers.has(ev.pointerId)) {
    t2_setPointer(ev);
  }

  // 2손가락 제스처: 회전 없이 팬 + 핀치줌
  if (TOUCH2.pointers.size >= 2 && TOUCH2.mode === "gesture") {
    if (hoverCell){ hoverCell.setHover(false); hoverCell = null; }

    const { midX, midY, dist, angle } = t2_midDist();

    // (1) 두손가락 평행 이동 => pan
    const dx = midX - TOUCH2.lastMidX;
    const dy = midY - TOUCH2.lastMidY;
    TOUCH2.lastMidX = midX;
    TOUCH2.lastMidY = midY;
    panByPixels(dx, dy);

    // (2) pinch => zoom (dist 늘면 zoom-in: radius 감소)
    if (TOUCH2.lastDist > 0 && dist > 0) {
      const factor = (TOUCH2.lastDist / dist);
      orbit.radius = clamp(orbit.radius * factor, orbit.minRadius, orbit.maxRadius);
      updateCameraOrbit();
    }
    TOUCH2.lastDist = dist;
    // ✅ (3) twist(두 점 기울기 회전) => roll
    let dAng = normAngleDelta(angle - TOUCH2.lastAngle);
    TOUCH2.lastAngle = angle;

    // 너무 미세한 떨림은 무시(선택)
    if (Math.abs(dAng) > 0.002) {
      orbit.roll = Number.isFinite(orbit.roll) ? orbit.roll : 0;
      orbit.roll = (orbit.roll || 0) - dAng;  // ✅ 남은 1축 회전
      updateCameraOrbit();
    }

    return; // ✅ 단일터치 로직 타지 않음
  }

  // 단일 터치
  if (!TOUCH.active || ev.pointerId !== TOUCH.pointerId) return;

  if (hoverCell){ hoverCell.setHover(false); hoverCell = null; }

  const distMove = touchDist(ev);

  if (!TOUCH.rotate && distMove > MOVE_CANCEL_PX) {
    TOUCH.rotate = true;
    clearLongPress();
    if (TOUCH.downCell && TOUCH.pressedApplied) {
      TOUCH.downCell.setPressed(false);
      TOUCH.pressedApplied = false;
    }
  }

  if (TOUCH.rotate) {
    const dx = ev.clientX - TOUCH.lastX;
    const dy = ev.clientY - TOUCH.lastY;
    TOUCH.lastX = ev.clientX;
    TOUCH.lastY = ev.clientY;

    orbit.theta += dx * 0.006;
    orbit.phi   -= dy * 0.006;
    updateCameraOrbit();
  }
  return;
}
// hover(닫힌 큐브만)
      // hover(닫힌 큐브만)
if (gameState === "over" || gameState === "win"){
  if (hoverCell){ hoverCell.setHover(false); hoverCell = null; }
} else {
  const pick = getPickCell(ev);
  const c = (pick && pick.__axis) ? null : pick;  // ✅ axis는 hover 제외

  if (c !== hoverCell){
    if(hoverCell) hoverCell.setHover(false);
    hoverCell = c;
    if(hoverCell) hoverCell.setHover(true);
  }
}

// ✅ 좌클릭: 큐브 위에서 시작했더라도 "드래그"면 회전으로 전환
if (leftDown && !leftRotDown && leftDownXY) {
  const distL = Math.hypot(ev.clientX - leftDownXY[0], ev.clientY - leftDownXY[1]);

  if (distL > MOVE_CANCEL_PX) {
    // pressed 시각효과 해제
    if (leftDownCell && leftPressedApplied) {
      leftDownCell.setPressed(false);
      leftPressedApplied = false;
    }

    // ✅ shift/lr 등 chord 하이라이트가 켜져있었다면 드래그로 간주하고 취소
    if (chordArmed && (chordKind === "shiftLeft" || chordKind === "shiftLeftCube" || chordKind === "lr")) {
      setChordHighlight(false, null);
      chordArmed = false;
      chordKind = null;
      chordPointerId = null;
      leftCanceledByChord = false;
    }

    // 회전 모드 진입
    leftRotDown = true;
    rotLastX = ev.clientX;
    rotLastY = ev.clientY;
  }
}

// 중클릭: 큐브 chord 시도 상태에서 드래그가 일정 이상이면 chord 하이라이트를 끄고 pan만 수행
if(middleDown && middleStartXY){
  const dist = Math.hypot(ev.clientX-middleStartXY[0], ev.clientY-middleStartXY[1]);
  if(!middleMoved && dist > MOVE_CANCEL_PX){
    middleMoved = true;
    if(chordArmed && chordKind === "middleCube"){
      // pan으로 전환: chord 시도 취소
      setChordHighlight(false, null);
      chordArmed = false;
      chordKind = null;
      chordPointerId = null;
    }
  }
}

// pan (middle drag)
if(panDown){
  const dx=ev.clientX-panLastX;
  const dy=ev.clientY-panLastY;
  panLastX=ev.clientX;
  panLastY=ev.clientY;
  panByPixels(dx, dy);
}
// ✅ 우클릭 드래그 = pan (중클릭 드래그와 동일)
if (rightDown && !(chordArmed && chordKind==="lr")) {
  if (rightStartXY) {
    const dist = Math.hypot(ev.clientX - rightStartXY[0], ev.clientY - rightStartXY[1]);
    if (!rightMoved && dist > MOVE_CANCEL_PX) rightMoved = true;
  }

  if (rightMoved) {
    const dx = ev.clientX - rightPanLastX;
    const dy = ev.clientY - rightPanLastY;
    rightPanLastX = ev.clientX;
    rightPanLastY = ev.clientY;
    panByPixels(dx, dy);
  } else {
    // 아직 클릭 판정 구간이면 last만 갱신(갑작스런 점프 방지)
    rightPanLastX = ev.clientX;
    rightPanLastY = ev.clientY;
  }
}


 if(leftRotDown && !(chordArmed && chordKind==="lr")){
  const dx=ev.clientX-rotLastX;
  const dy=ev.clientY-rotLastY;
  rotLastX=ev.clientX;
  rotLastY=ev.clientY;

  orbit.theta += dx*0.006;
  orbit.phi   -= dy*0.006;
  updateCameraOrbit();
}

    // 좌+우 chord: left down 상태에서 right down이 들어오면 onPointerDown에서 arm 처리
    // 여기서는 nothing
  }

  function onWheel(ev){
    ev.preventDefault();
    const factor = 1 + (ev.deltaY * 0.001);
    orbit.radius = clamp(orbit.radius * factor, orbit.minRadius, orbit.maxRadius);
    updateCameraOrbit();
  }

  function animate(){
  requestAnimationFrame(animate);

  renderer.render(scene, camera);

  // ✅ assist render
  updateAssistCamera();
  if (assistRenderer && assistCamera){
    assistRenderer.render(scene, assistCamera);
  }
  }

  // ====== 생성/보드 ======
  function buildMinesVisualAll(){
    for(const c of cells) c.buildMinesVisual();
  }
  //=====중요!자동풀이====
  // 3D drop-in: same algorithm + same "first choice" policy as 2D (only +z dimension)
function solveonestep3D(input) {
  const self = this || {};

  const W = (input && input.columns != null ? input.columns : (input && input.cols != null ? input.cols : (SIZE?.x ?? 0))) | 0;
  const H = (input && input.rows    != null ? input.rows    : (input && input.rows_ != null ? input.rows_ : (SIZE?.y ?? 0))) | 0;
  const D = (input && input.depths  != null ? input.depths  : (input && input.depth != null ? input.depth : (SIZE?.z ?? 0))) | 0;

  const capB = (input && input.max_mines != null ? input.max_mines : (input && input.max_mines_black != null ? input.max_mines_black : (CONFIG?.minesPerCell ?? 1))) | 0;
  const capW = (input && input.max_mines_white != null ? input.max_mines_white : (CONFIG?.whiteMinesPerCell ?? 0)) | 0;

  const numWhite = (input && input.num_mines_white != null)
    ? (input.num_mines_white | 0)
    : ((typeof placedWhiteMines !== "undefined" ? placedWhiteMines : 0) | 0);

  const hasWhites = (numWhite > 0) && (capW > 0);
  const classicMode = (!hasWhites) && (Math.max(1, capB) === 1);

  const idx = (x, y, z) => (x + W * (y + H * z)) | 0;

  // ---------- cell getter ----------
  function getCell(x,y,z){
    if (input && typeof input.cellAt === "function") return input.cellAt(x,y,z);
    // 3dmine.html 기준
    return cells[idx(x,y,z)];
  }

  // ---------- near value ----------
  // input.near_mines가 있으면 near[x][y][z], 없으면 cell.adjValue
  function nearVal(x,y,z){
    if (input && input.near_mines){
      const near = input.near_mines;
      return (near && near[x] && near[x][y] ? (near[x][y][z] | 0) : 0) | 0;
    }
    const c = getCell(x,y,z);
    return (c ? (c.adjValue|0) : 0) | 0;
  }

  // ---------- opened 판정 ----------
  let openedFn = null;
  if (input && input.opened != null) {
    if (typeof input.opened === "function") {
      openedFn = input.opened;
    } else {
      const op = input.opened;
      if (Array.isArray(op) && Array.isArray(op[0]) && Array.isArray(op[0][0])) {
        openedFn = (x, y, z) => !!op[x][y][z];
      } else {
        openedFn = (x, y, z) => !!op[idx(x, y, z)];
      }
    }
  } else {
    openedFn = (x, y, z) => {
      const c = getCell(x,y,z);
      return !!(c && c.isOpen);
    };
  }

  // ---------- flag 값(부호 포함) ----------
  function flagVal(x, y, z) {
    if (input && input.flags){
      const flags = input.flags;
      const v = (flags && flags[x] && flags[x][y]) ? (flags[x][y][z] | 0) : 0;
      return v | 0;
    }
    // 3dmine.html의 현재 마킹 기반
    const c = getCell(x,y,z);
    if (!c) return 0;
    if (c.markType === MARK_POS) return (c.markCount|0);
    if (c.markType === MARK_NEG) return (-(c.markCount|0))|0;
    return 0;
  }

  // ---------- 인접 좌표(26) ----------
  function neigh(x, y, z) {
    if (input && typeof input.near_positions === "function") return input.near_positions(x, y, z);
    // 3dmine.html
    const c = getCell(x,y,z);
    const ns = neighbors26(c); // Cell[]
    const out = new Array(ns.length);
    for (let i=0;i<ns.length;i++) out[i] = [ns[i].x|0, ns[i].y|0, ns[i].z|0];
    return out;
  }

  // =========================================================
  // 1) 제약에서 frontier(vars/cons) 구성 (2D와 동일)
  // =========================================================
  const varIndex = new Map();      // "x,y,z" -> id
  const vars = [];                // id -> [x,y,z]
  const cons = [];                // { vars:[id...], target:int, isAbs:bool }

  function addVar(x, y, z) {
    const key = x + "," + y + "," + z;
    let id = varIndex.get(key);
    if (id == null) { id = vars.length; varIndex.set(key, id); vars.push([x, y, z]); }
    return id;
  }

  // (A) true-zero(near==0) 열린 칸 → 인접 첫 안전 오픈
  for (let z = 0; z < D; z++) for (let y = 0; y < H; y++) for (let x = 0; x < W; x++) {
    if (!openedFn(x, y, z)) continue;
    const v0 = nearVal(x,y,z) | 0;
    if (v0 !== 0) continue;

    const adj = neigh(x, y, z);

    let bad = false;
    for (let i = 0; i < adj.length; i++) {
      const nx = adj[i][0], ny = adj[i][1], nz = adj[i][2];
      const f = flagVal(nx, ny, nz);
      if (f !== 0) { bad = true; break; }
    }
    if (bad) continue;

    for (let i = 0; i < adj.length; i++) {
      const nx = adj[i][0], ny = adj[i][1], nz = adj[i][2];
      if (openedFn(nx, ny, nz)) continue;
      if (flagVal(nx, ny, nz) !== 0) continue;
      return { kind: "open", x: nx, y: ny, z: nz, reason: "RuleA N==0 (true 0)" };
    }
  }

  // (B) 일반 숫자칸(±n 또는 1000) 제약 수집
  for (let z = 0; z < D; z++) for (let y = 0; y < H; y++) for (let x = 0; x < W; x++) {
    if (!openedFn(x, y, z)) continue;

    const raw = nearVal(x,y,z) | 0;
    if (raw === 0) continue;

    let target = (raw === 1000 ? 0 : raw) | 0;
    let isAbs = (raw === 1000);
    let absFixed = 0;

    const adj = neigh(x, y, z);
    const vs = [];
    for (let i = 0; i < adj.length; i++) {
      const nx = adj[i][0], ny = adj[i][1], nz = adj[i][2];
      if (openedFn(nx, ny, nz)) continue;

      const f = flagVal(nx, ny, nz);
      if (f !== 0) {
        target -= f;
        absFixed += Math.abs(f);
        continue;
      }
      vs.push(addVar(nx, ny, nz));
    }

    if (isAbs && absFixed > 0) isAbs = false;

    if (vs.length > 0 || isAbs) cons.push({ vars: vs, target: target | 0, isAbs: !!isAbs });
  }

  if (vars.length === 0 || cons.length === 0) return null;

  // =========================================================
  // 2) 로컬 규칙 (2D와 동일 구조/정책)
  // =========================================================
  function returnFirstOpenFromList(list, reason) {
    for (let k = 0; k < list.length; k++) {
      const item = list[k];
      const x = Array.isArray(item) ? item[0] : vars[item][0];
      const y = Array.isArray(item) ? item[1] : vars[item][1];
      const z = Array.isArray(item) ? item[2] : vars[item][2];
      if (openedFn(x, y, z)) continue;
      if (flagVal(x, y, z) !== 0) continue;
      return { kind: "open", x, y, z, reason };
    }
    return null;
  }
  function returnFirstFixFromList(list, val, reason) {
    for (let k = 0; k < list.length; k++) {
      const item = list[k];
      const x = Array.isArray(item) ? item[0] : vars[item][0];
      const y = Array.isArray(item) ? item[1] : vars[item][1];
      const z = Array.isArray(item) ? item[2] : vars[item][2];
      if (openedFn(x, y, z)) continue;
      if (flagVal(x, y, z) !== 0) continue;
      return { kind: "markMine", x, y, z, reason, val: val | 0 };
    }
    return null;
  }

  // ---- (2-1) RuleA/B ----
  {
    for (let ci = 0; ci < cons.length; ci++) {
      const c = cons[ci];
      const vs = c.vars;
      const U = vs.length | 0;
      const N = c.target | 0;
      if (U <= 0) continue;

      if (U === 1) {
        const [x, y, z] = vars[vs[0]];
        if (c.isAbs && N === 0) continue;

        if (N === 0 && !c.isAbs) {
          if (!openedFn(x, y, z) && flagVal(x, y, z) === 0)
            return { kind: "open", x, y, z, reason: "RuleB U==1,N==0" };
        } else {
          if (N !== 0 && !openedFn(x, y, z) && flagVal(x, y, z) === 0) {
            if (N < -capW || N > capB) continue;
            return { kind: "markMine", x, y, z, reason: "RuleB U==1 exact", val: N | 0 };
          }
        }
      }

      if (!hasWhites) {
        if (!c.isAbs && N === 0) {
          const r = returnFirstOpenFromList(vs, "RuleA N==0");
          if (r) return r;
        }
        if (classicMode && !c.isAbs && N === U) {
          const r = returnFirstFixFromList(vs, 1, "RuleB N==U");
          if (r) return r;
        }
        if (!classicMode && !c.isAbs && N === (U * capB)) {
          const r = returnFirstFixFromList(vs, capB, "RuleB cap");
          if (r) return r;
        }
      }
    }
  }

  // ---- (2-2) Subset ----
  {
    const small = [];
    for (let ci = 0; ci < cons.length; ci++) {
      const c = cons[ci];
      if (c.isAbs) continue;
      if (!c.vars || c.vars.length === 0) continue;
      if (c.vars.length > 8) continue;
      small.push({ s: new Set(c.vars), t: c.target | 0 });
    }

    function isSubset(A, B) {
      for (const v of A) if (!B.has(v)) return false;
      return true;
    }

    // 2D의 (y,x) 정렬을 3D에선 (z,y,x)로 “차원만 +1” 확장
    function pickFirstCoord(coords) {
      coords.sort((p, q) => (p[2] - q[2]) || (p[1] - q[1]) || (p[0] - q[0]));
      return coords[0];
    }

    for (let i = 0; i < small.length; i++) {
      for (let j = 0; j < small.length; j++) {
        if (i === j) continue;
        const A = small[i], B = small[j];
        if (!isSubset(A.s, B.s)) continue;

        const S = [];
        for (const v of B.s) if (!A.s.has(v)) S.push(v);
        if (S.length === 0) continue;

        const delta = (B.t - A.t) | 0;

        if (S.length === 1) {
          const [x, y, z] = vars[S[0]];
          if (openedFn(x, y, z) || flagVal(x, y, z) !== 0) continue;
          if (delta === 0) return { kind: "open", x, y, z, reason: "subset single exact (0)" };
          if (delta < -capW || delta > capB) continue;
          return { kind: "markMine", x, y, z, reason: "subset single exact", val: delta | 0 };
        }

        if (!hasWhites) {
          if (delta === 0) {
            const coords = S.map(id => vars[id]).filter(([x,y,z]) => !openedFn(x,y,z) && flagVal(x,y,z) === 0);
            if (coords.length) {
              const [x,y,z] = pickFirstCoord(coords);
              return { kind: "open", x, y, z, reason: "subset Δ=0" };
            }
          } else if (delta === (S.length * capB)) {
            const coords = S.map(id => vars[id]).filter(([x,y,z]) => !openedFn(x,y,z) && flagVal(x,y,z) === 0);
            if (coords.length) {
              const [x,y,z] = pickFirstCoord(coords);
              return { kind: "markMine", x, y, z, reason: "subset Δ=|S|*cap", val: capB | 0 };
            }
          }
        }
      }
    }
  }

  // ---- (2-3) Bounds ----
  {
    const n = vars.length | 0;
    if (n > 0 && cons.length > 0) {
      const vmin = new Int16Array(n);
      const vmax = new Int16Array(n);
      for (let i = 0; i < n; i++) {
        vmin[i] = hasWhites ? (-capW | 0) : 0;
        vmax[i] = capB | 0;
      }

      for (let iter = 0; iter < 10; iter++) {
        let any = false;
        for (let ci = 0; ci < cons.length; ci++) {
          const c = cons[ci];
          if (c.isAbs) continue;
          const vs = c.vars;
          if (!vs || vs.length === 0) continue;
          const N = c.target | 0;

          let sumMin = 0, sumMax = 0;
          for (let k = 0; k < vs.length; k++) { sumMin += vmin[vs[k]]; sumMax += vmax[vs[k]]; }

          for (let k = 0; k < vs.length; k++) {
            const id = vs[k];
            const othersMin = sumMin - vmin[id];
            const othersMax = sumMax - vmax[id];
            const newMin = Math.max(vmin[id], N - othersMax);
            const newMax = Math.min(vmax[id], N - othersMin);
            if (newMin > vmin[id]) { vmin[id] = newMin; any = true; }
            if (newMax < vmax[id]) { vmax[id] = newMax; any = true; }
          }
        }
        if (!any) break;
      }

      let best = null;
      for (let id = 0; id < n; id++) {
        if (vmin[id] !== vmax[id]) continue;
        const [x, y, z] = vars[id];
        if (openedFn(x, y, z) || flagVal(x, y, z) !== 0) continue;

        const v = vmin[id] | 0;
        const cand = (v === 0)
          ? { kind: "open", x, y, z, reason: hasWhites ? "bounds (general) ==0" : "bounds min==max==0" }
          : { kind: "markMine", x, y, z, reason: hasWhites ? "bounds (general) exact" : "bounds exact", val: v | 0 };

        // 2D의 (y,x) 비교를 3D에선 (z,y,x)로 확장
        if (!best || (cand.z < best.z) || (cand.z === best.z && (cand.y < best.y || (cand.y === best.y && cand.x < best.x))))
          best = cand;
      }
      if (best) return best;
    }
  }

  // ---- (3) GAC 훅 (2D와 동일한 “옵션 단계”) ----
  {
    const gacFn = (input && typeof input._enforceGACSigned === "function")
      ? input._enforceGACSigned
      : (typeof self._enforceGACSigned === "function" ? self._enforceGACSigned : null);

    if (gacFn) {
      const COMP_CAP = 48;
      if (vars.length <= COMP_CAP) {
        const r = gacFn.call(self, vars, cons, capB, capW);
        if (r && !r.fail && r.decided && r.decided.length) {
          let best = null;
          for (let i = 0; i < r.decided.length; i++) {
            const d = r.decided[i];
            if (openedFn(d.x, d.y, d.z) || flagVal(d.x, d.y, d.z) !== 0) continue;
            const cand = (d.type === "open")
              ? { kind: "open", x: d.x, y: d.y, z: d.z, reason: "GAC domain=={0}" }
              : { kind: "markMine", x: d.x, y: d.y, z: d.z, reason: "GAC singleton", val: (d.val | 0) };

            if (!best || (cand.z < best.z) || (cand.z === best.z && (cand.y < best.y || (cand.y === best.y && cand.x < best.x))))
              best = cand;
          }
          if (best) return best;
        }
      }
    }
  }

  return null;
}

// 원하면 전역으로 노출
window.solveonestep3D = solveonestep3D;
// ===============================
// 3D assist (hint/auto) - one step
// ===============================
function __cellAt3D(x,y,z){
  if (!inBounds(x,y,z)) return null;
  return cells[idx(x,y,z)];
}

function __isFlag3D(c){
  return c && (c.markType === MARK_POS || c.markType === MARK_NEG);
}

function __flagSigned3D(c){
  if (!c) return 0;
  if (c.markType === MARK_POS) return (c.markCount|0);
  if (c.markType === MARK_NEG) return (-(c.markCount|0))|0;
  return 0;
}

function __frontierClosedCells3D(){
  const out = [];
  const seen = new Set();
  for (const a of cells){
    if (!a) continue;
    const anchor = a.isOpen || __isFlag3D(a);
    if (!anchor) continue;

    const ns = neighbors26(a);
    for (const n of ns){
      if (!n) continue;
      if (n.isOpen) continue;
      if (__isFlag3D(n)) continue;          // 깃발은 후보 제외
      // ?(MARK_Q)는 "깃발없음" 취급이므로 후보 포함
      const key = `${n.x},${n.y},${n.z}`;
      if (!seen.has(key)){
        seen.add(key);
        out.push(n);
      }
    }
  }
  return out;
}

// "찍기 불가피" 시: frontier 중 임의 1칸의 정답을 제공
function __pickOneTruthCell3D(){
  const cand = __frontierClosedCells3D();
  if (!cand.length) return null;
  const c = cand[(Math.random() * cand.length) | 0];
  const ans = (c.mineValue|0);
  if (ans === 0) return { kind:"open", x:c.x, y:c.y, z:c.z, reason:"찍기 불가피-한 칸의 정답을 제공", usedGuess:true };
  return { kind:"markMine", x:c.x, y:c.y, z:c.z, val:ans, reason:"찍기 불가피-한 칸의 정답을 제공", usedGuess:true };
}

function __fixWrongFlag3D(){
  for (const c of cells){
    if (!c) continue;
    if (!__isFlag3D(c)) continue;
    const f = __flagSigned3D(c);
    const ans = (c.mineValue|0);
    if (f !== ans){
      return { kind:"fixFlag", x:c.x, y:c.y, z:c.z, val:ans, reason:"잘못 마킹한 칸이 있습니다" };
    }
  }
  return null;
}

function __applyStep3D(step){
  if (!step) return false;
  const c = __cellAt3D(step.x|0, step.y|0, step.z|0);
  setFocusedCell(c);
  if (!c) return false;

  if (step.kind === "open"){
    // ?면 제거 후 열기: openFromClick 안에 이미 처리( MARK_Q 제거/깃발이면 무시 )
    c.openFromClick();
    return true;
  }

  if (step.kind === "fixFlag" || step.kind === "markMine"){
    const v = ("val" in step) ? (step.val|0) : (c.mineValue|0);

    // v==0이면 깃발 제거
    if (v === 0){
      c.setMarkNone();
      return true;
    }

    const abs = Math.min(6, Math.max(1, Math.abs(v|0)));
    c.markType  = (v > 0) ? MARK_POS : MARK_NEG;
    c.markCount = abs;
    c.applyMarkVisual();
    return true;
  }

  return false;
}

// parent에서 호출되는 “1스텝 보조(힌트/자동)”
// 2D 찍기있음 로직과 동일한 우선순위:
// 1) 오답 깃발 수정
// 2) solveonestep3D
// 3) (hint 또는 auto 첫회) 정답 1칸 제공(찍기)
function __mine3d_assist_once(mode){
  mode = mode || { cause:"hint", isFirstAuto:true };

  // 죽음/승리면 종료
  if (gameState === "over" || gameState === "win"){
    return { ok:false, done:true, gameState, step:null };
  }

  // 1) wrong flag
  let step = __fixWrongFlag3D();
  if (step){
    __applyStep3D(step);
    return { ok:true, gameState, step };
  }

  // 2) solveonestep3D
  step = (typeof solveonestep3D === "function") ? solveonestep3D() : null;
  if (step){
    // solveonestep3D는 {kind, x,y,z, val?, reason}
    __applyStep3D(step);
    return { ok:true, gameState, step };
  }

  // 3) guess (hint or first auto only)
  if (mode.cause === "hint" || (mode.cause === "auto" && mode.isFirstAuto)){
    step = __pickOneTruthCell3D();
    if (step){
      __applyStep3D(step);
      return { ok:true, gameState, step };
    }
  }

  return { ok:false, gameState, step:null };
}
(function install3DSolverBridge(){
  const send = (msg) => {
    try { window.parent?.postMessage({ __mine3d: 1, ...msg }, '*'); } catch(e) {}
  };

  let timer = null;
  let running = false;
  let paused  = false;
  let firstAuto = true;

  function syncState(){
    send({ type:'solverState', running, paused });
  }

  function stop(){
    if (timer) { clearInterval(timer); timer = null; }
    running = false;
    paused  = false;
    firstAuto = true;
    syncState();
  }

  function start(){
    if (timer) clearInterval(timer);
    running = true;
    paused  = false;
    firstAuto = true;
    syncState();

    timer = setInterval(() => {
      if (!running || paused) return;

      // 1틱 1스텝
      const r = __mine3d_assist_once({ cause:'auto', isFirstAuto: firstAuto });
      firstAuto = false;

      if (!r || !r.ok || !r.step){
        stop();
        return;
      }

      // (선택) 부모 콘솔에 로그 남기고 싶으면
      send({ type:'solverStep', step: r.step });
    }, 40);
  }

  function hint(){
    const r = __mine3d_assist_once({ cause:'hint', isFirstAuto:true });
    if (r && r.ok && r.step){
      send({ type:'solverStep', step: r.step });
    }
  }

  window.addEventListener('message', (e) => {
    const m = e.data;
    if (!m || !m.__mine3d) return;

    // solver 명령
    if (m.type === 'solver'){
      switch (m.cmd){
        case 'start':  start(); break;
        case 'pause':  paused = true;  syncState(); break;
        case 'resume': paused = false; syncState(); break;
        case 'stop':   stop(); break;
        case 'hint':   hint(); break;
      }
      return;
    }

    // (옵션) 리셋 명령이 오면 자동풀이도 멈춤
    if (m.type === 'reset'){
      stop();
      // 여기서 3D 보드 리셋 함수가 있으면 호출
      // resetBoard3D?.();
      return;
    }
  });

  // 로드 시 ready 신호 (부모가 이미 처리 중)
  window.addEventListener('load', () => send({ type:'ready' }));
})();
// 3D iframe -> parent 키 전달
(function installKeyForward(){
  window.addEventListener('keydown', (e) => {
    // main.html에서 쓰는 키만 전달 (필요하면 더 추가)
    const k = (e.key || '');
    const up = k.length === 1 ? k.toUpperCase() : k;

    const allow = new Set([
      'F1','F2','F3','F4',
      'N','B','I','E','C','M','L','S','T','X','H','A'
    ]);

    if (!allow.has(up)) return;

    e.preventDefault();

    parent.postMessage({
      __mine3d: 1,
      type: 'key',
      key: e.key,
      code: e.code,
      ctrlKey: e.ctrlKey,
      altKey: e.altKey,
      shiftKey: e.shiftKey,
      metaKey: e.metaKey
    }, '*');
  }, true);
})();

</script>

</body>
</html>